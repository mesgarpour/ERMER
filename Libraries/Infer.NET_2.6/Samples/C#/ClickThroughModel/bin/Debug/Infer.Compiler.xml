<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Infer.Compiler</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Dynamic.Binding">
      <summary>
            Represents the type parameters and argument conversions needed to invoke a method.
            </summary>
      <remarks>
        <para>
            Given a generic method definition and a list of arguments, a Binding represents the 
            additional information needed to invoke the method with those arguments.  Specifically,
            it stores a list of type parameters (possibly empty if the method is not generic) and
            a list of conversions, one for each argument.  Note that Bindings are not unique, e.g.
            a type parameter might be instantiated in several different ways, yet still compatible
            with the given arguments.  Each of these choices is a different Binding.
            </para>
        <para>
            This class allows you to find the Binding which is 'best' in the sense of being the most
            specific.  The &lt; operator can be used to compare the specificity of Bindings.
            </para>
      </remarks>
    </member>
    <member name="F:Microsoft.Dynamic.Binding.Types">
      <summary>
            The type inferred for each type parameter.
            </summary>
      <remarks>All entries are non-null.  A missing entry indicates an unconstrained parameter.</remarks>
    </member>
    <member name="F:Microsoft.Dynamic.Binding.Conversions">
      <summary>
            The conversion inferred for each method parameter position.
            </summary>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.#ctor(Microsoft.Dynamic.Binding)">
      <summary>
            Copy constructor.
            </summary>
      <param name="info">
      </param>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.#ctor(System.Reflection.MethodBase)">
      <summary>
            Creare an empty Binding to a given method.
            </summary>
      <param name="method">
      </param>
      <remarks>The conversions are all set to null.</remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.op_LessThan(Microsoft.Dynamic.Binding,Microsoft.Dynamic.Binding)">
      <summary>
            True if A is more specific than B.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>True if A is more specific than B.
            </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ConvertAll(System.Object[])">
      <summary>
            Apply the conversions to a set of arguments.
            </summary>
      <param name="args">An array of length Conversions.Length.  Modified to contain the converted values.</param>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.GetBestBinding(System.Reflection.MethodBase,System.Type[],Microsoft.Dynamic.ConversionOptions,System.Exception@)">
      <summary>
            Find the most specific Binding for a generic method.
            </summary>
      <param name="method">
      </param>
      <param name="actuals">Types from which to infer type parameters.  actuals.Length == number of method parameters.  actuals[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="conversionOptions">Specifies which conversions are allowed.</param>
      <param name="exception">Exception created on failure</param>
      <returns>null if binding fails.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.IsMinimal">
      <summary>
            True if the binding has no explicit conversions (excluding the first) and at most one nonzero conversion.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.InferGenericParameters(System.Reflection.MethodBase,System.Type[],Microsoft.Dynamic.ConversionOptions,System.Collections.Generic.IList{System.Exception})">
      <summary>
            Infer type parameters for a method call.
            </summary>
      <param name="method">
      </param>
      <param name="actuals">Types from which to infer type parameters.  actuals.Length == number of method parameters.  actuals[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="conversionOptions">Specifies which conversions are allowed</param>
      <param name="errors">A list which collects binding errors.</param>
      <returns>An iterator which yields all possible bindings.</returns>
      <remarks>Because it considers all possible bindings for each argument, this function can 
            infer type parameters in cases where the C# 2.0 specification (sec 20.6.4) cannot.</remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ApplyTypeConstraints(System.Reflection.MethodBase,System.Collections.Generic.IEnumerator{Microsoft.Dynamic.Binding},System.Collections.Generic.IList{System.Exception})">
      <summary>
            Filter a stream of bindings via type constraints.
            </summary>
      <param name="method">A generic method which may have type constraints.</param>
      <param name="iter">A stream of Bindings.</param>
      <param name="errors">A list which collects binding errors.</param>
      <returns>A substream of Bindings which all satisfy the type constraints.
            Type parameters which were previously unknown may be filled in by the type constraints, possibly
            in multiple ways.  Thus a single Binding from <paramref name="iter" /> with an unknown type parameter
            may expand into many new Bindings, differing only in the instantiation of that parameter.
            Known type parameters are left unchanged.
            </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ApplyTypeConstraints(Microsoft.Dynamic.Binding,System.Collections.Generic.IList{System.Exception},System.Collections.Generic.ICollection{System.Type})">
      <summary>
            Expand a binding via type constraints.
            </summary>
      <param name="binding">The binding to expand</param>
      <param name="errors">A list which collects binding errors.</param>
      <param name="doneParams">The set of parameters already processed.</param>
      <returns>A stream of Bindings which satisfy the constraints on typeParams[pos] and above.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ApplyTypeConstraints(System.Type,System.Type[],Microsoft.Dynamic.Binding,System.Collections.Generic.IList{System.Exception},System.Int32)">
      <summary>
            Expand a binding via type constraints.
            </summary>
      <param name="actual">
      </param>
      <param name="constraints">The constraints on the type parameter at binding.Types[pos].</param>
      <param name="binding">Any binding.</param>
      <param name="errors">A list which collects binding errors.</param>
      <param name="start">The index of the first constraint to process.</param>
      <returns>A stream of Bindings which satisfy constraints[start] and higher.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.InferGenericParameters(System.Type[],System.Type[],Microsoft.Dynamic.Binding,System.Collections.Generic.IList{System.Exception},System.Int32,System.Int32,System.Boolean,System.Boolean,Microsoft.Dynamic.ConversionOptions)">
      <summary>
            Infer remaining type parameters for a method call or generic type.
            </summary>
      <param name="formals">Types with parameters to infer.</param>
      <param name="actuals">The corresponding types from which to infer parameters.  actuals.Length == formals.Length.  actuals[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="binding">The partial binding inferred from actuals[i &lt; start]. 
            Will be mutated and returned as elements of the stream.</param>
      <param name="errors">A list which collects binding errors.</param>
      <param name="start">The index into the formals array to begin processing.</param>
      <param name="position">The index into binding.Conversions to place the conversion.  If -1, only null conversions are allowed.  Ignored if isMethodCall is true.</param>
      <param name="isMethodCall">True if formals correspond to method parameters.  position is always taken equal to start.</param>
      <param name="allowSubtype">True if implicit subtype conversions are allowed.</param>
      <param name="conversionOptions">Specifies which conversions are allowed.</param>
      <returns>A stream of all possible bindings which match formals[i] to actuals[i], for all i &gt;= start, including conversions.</returns>
      <remarks>Each element of the stream is the same object as <paramref name="binding" />, but modified to (possibly) 
            include more bindings.  <paramref name="binding" /> is returned to its original state at the end of the stream.</remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.InferGenericParameters(System.Type,System.Type,Microsoft.Dynamic.Binding,System.Collections.Generic.IList{System.Exception},System.Int32,System.Boolean,Microsoft.Dynamic.ConversionOptions)">
      <summary>
            Infer type parameter bindings.
            </summary>
      <param name="formal">The type with parameters to infer.</param>
      <param name="actual">A type from which to infer parameters.  May be null to allow any type, or typeof(Nullable) to mean "any nullable type".  May itself contain type parameters.</param>
      <param name="binding">Known bindings, which are taken as fixed.  Conversions[position] must be null.</param>
      <param name="errors">A list which collects binding errors.</param>
      <param name="position">If formal corresponds to a method parameter type, this is the index of the method parameter.  Otherwise it is -1 and no conversions are allowed.</param>
      <param name="allowSubtype">True if implicit subtype conversions are allowed.</param>
      <param name="conversionOptions">Specifies which conversions are allowed.</param>
      <returns>A stream of all possible bindings which match formal to actual, 
            including conversions.</returns>
      <remarks>
        <para>Each element of the stream is the same object as <paramref name="binding" />, but modified to (possibly) 
            include more bindings.  <paramref name="binding" /> is returned to its original state at the end of the stream.
            </para>
        <para>
            If <paramref name="formal" /> has no type parameters, then at most one Binding is returned.
            </para>
      </remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.TypesAssignableFrom(System.Type,System.Boolean)">
      <summary>
            All base classes and interfaces of a given type.
            </summary>
      <param name="type">Any non-null type.  May be a type parameter.</param>
      <param name="includeIList">If true, include IList when <paramref name="type" /> is an array.</param>
      <returns>All base classes and interfaces of <paramref name="type" />, most specific types first.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.Bind(System.Type)">
      <summary>
            Fill in some type parameters.
            </summary>
      <param name="type">A type which may have generic parameters.</param>
      <returns>A type with possibly fewer generic parameters.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ReplaceTypeParameters(System.Type,System.Collections.Generic.IDictionary{System.Type,System.Type})">
      <summary>
            Replace type parameters in a generic type.
            </summary>
      <param name="type">A type which may have generic parameters.</param>
      <param name="typeMap">A dictionary for mapping types</param>
      <returns>A type with possibly fewer generic parameters.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.ForEachTypeParameter(System.Type,System.Action{System.Type})">
      <summary>
            Perform an action for each type parameter inside a type.
            </summary>
      <param name="type">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.Bind(System.Reflection.MethodBase)">
      <summary>
            Specialize a method on the inferred type parameters.
            </summary>
      <param name="method">A non-null generic or non-generic method.</param>
      <returns>A method with all type parameters of that method filled in.  Type parameters of an enclosing type will not be filled in.</returns>
      <remarks>
            Unknown type parameters are replaced with System.Object.
            </remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Binding.IntersectTypes(System.Type,System.Type)">
      <summary>
            Get a type which is the most specific of the input types.
            </summary>
      <param name="t1">
      </param>
      <param name="t2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Dynamic.GenericParameterFactory.SelfReference`1">
      <summary>
            Used in generic parameter constraints to refer to the type being defined.
            </summary>
    </member>
    <member name="M:Microsoft.Dynamic.GenericParameterFactory.Constraints.IsAssignableFrom(Microsoft.Dynamic.GenericParameterFactory.Constraints)">
      <summary>
            True if that is more constrained than this.
            </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Dynamic.GenericParameterFactory.MakeGenericParameter(System.String,Microsoft.Dynamic.GenericParameterFactory.Constraints)">
      <summary>
            Make a generic type parameter with the given constraints.
            </summary>
      <param name="name">
      </param>
      <param name="constraints">
      </param>
      <returns>A generic type parameter.</returns>
      <remarks>
            Algorithm:
            The type parameter is constructed by dynamically generating a type with a generic method.
            For example:
            <c>class Parent { void method&lt;U&gt;() where U : IList&lt;int&gt; {} }</c>
            If the constraints refer to other type parameters, placeholders are added to the parent type.
            For example:
            <c>class Parent&lt;T&gt; { void method&lt;U&gt;() where U : IList&lt;T&gt; {} }</c>
            The parent type is then specialized on the actual type parameters appearing in the constraints.
            The type parameter U is returned.
            </remarks>
    </member>
    <member name="F:Microsoft.Dynamic.Conversion.SubclassCount">
      <summary>
            The number of subclass edges between the two types.
            </summary>
      <remarks>This is only valid if converter is null, i.e. no conversion is needed.  
            If the two types are the same, then SubclassCount == 0.  
            If one is a direct subclass of the other, SubclassCount == 1.
            If one is a subclass of a subclass of the other, SubclassCount == 2, and so on.
            </remarks>
    </member>
    <member name="F:Microsoft.Dynamic.Conversion.IsExplicit">
      <summary>
            True if the conversion is explicit.
            </summary>
      <remarks>Must be false if converter is null.
            An implicit conversion must always succeed and does not lose information.
            Otherwise, it is explicit.
            </remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.op_LessThan(Microsoft.Dynamic.Conversion,Microsoft.Dynamic.Conversion)">
      <summary>
            True if A is a more specific conversion than B.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>True if A is a more specific conversion than B.</returns>
      <remarks>The following criteria are applied in order:
            1. A null conversion versus a non-null conversion.
            2. Among null conversions, the one crossing fewer subclass links.
            3. An implicit conversion versus an explicit conversion.
            </remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.GetWeight">
      <summary>
            Returns a numerical weight such that (a.GetWeight() &lt; b.GetWeight()) iff (a &lt; b)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.TryGetPrimitiveConversion(System.Type,System.Type,Microsoft.Dynamic.Conversion@)">
      <summary>
            Get a Conversion structure to a primitive type.
            </summary>
      <param name="fromType">Any type.</param>
      <param name="toType">A primitive type.</param>
      <param name="info">
      </param>
      <returns>false if no conversion exists.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.ChangeRank(System.Array,System.Int32,System.Type,Microsoft.Dynamic.Converter)">
      <summary>
            Change array rank and convert elements.
            </summary>
      <param name="fromArray">
      </param>
      <param name="toRank">Can be smaller, larger, or equal to fromArray.Rank.</param>
      <param name="toElementType">
      </param>
      <param name="conv">
      </param>
      <returns>A new array of rank toRank with the same contents as fromArray.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.TryGetConversion(System.Type,System.Type,Microsoft.Dynamic.Conversion@)">
      <summary>
            Get a type converter.
            </summary>
      <param name="fromType">non-null.  May contain type parameters. Use typeof(Nullable) to convert from a null value.</param>
      <param name="toType">non-null.  May contain type parameters. May be typeof(void), for which no conversion is needed.</param>
      <param name="info">
      </param>
      <returns>null if no converter was found.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Conversion.ConvertDelegate(System.Type,System.Delegate)">
      <summary>
            Convert a weakly-typed delegate into a strongly-typed delegate.
            </summary>
      <param name="delegateType">The desired delegate type.</param>
      <param name="inner">A delegate with parameters (object[] args).
            The
            return type can be any type convertible to the return type of delegateType, or void if
            the delegateType is void.</param>
      <returns>A delegate of type delegateType.  The arguments of this delegate will be
            passed as (object[]) args to the innerMethod.</returns>
    </member>
    <member name="T:Microsoft.Dynamic.Invoker">
      <summary>
            Static methods to dynamically invoke methods and access fields of an object.
            </summary>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetLoadedType(System.String)">
      <summary>
            Get a type by name.
            </summary>
      <param name="typeName">The name of a type in the System library or any loaded assembly.</param>
      <returns>The Type object.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.InvokeStatic(System.Type,System.String,System.Object[])">
      <summary>
            Invoke the static member which best matches the argument types.
            </summary>
      <param name="type">
      </param>
      <param name="methodName">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetValue(System.Object,System.Object[])">
      <summary>
            Get an element from an array or collection, or invoke a delegate.
            </summary>
      <param name="target">An array, collection, delegate, or method group.</param>
      <param name="args">Indices for the collection or arguments for the delegate.  May be null.</param>
      <returns>The collection element or return value of the delegate.  If args == null, the target itself.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.SetValue(System.Object,System.Object[])">
      <summary>
            Set an element in an array or collection.
            </summary>
      <param name="target">An array or collection.</param>
      <param name="args">Indices followed by the value to set.  Length &gt; 0.</param>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.InvokeMember(System.Type,System.String,System.Reflection.BindingFlags,System.Object,System.Object[])">
      <summary>
            Invoke the member which best matches the argument types.
            </summary>
      <param name="type">The type defining the member.</param>
      <param name="memberName">The name of a field, property, event, instance method, or static method.</param>
      <param name="flags">
      </param>
      <param name="target">The object whose member to invoke.  Ignored for a static field or property.
            If target is non-null, then it is provided as the first argument to a static method.</param>
      <param name="args">Can be empty or null.  Empty means a function call with no arguments.  
            null means get the member itself.</param>
      <returns>The result of the invocation. For SetField/SetProperty the result is null.</returns>
      <exception cref="T:System.MissingMemberException">
      </exception>
      <exception cref="T:System.ArgumentException">
      </exception>
      <remarks>
        <para>
            This routine is patterned after Type.InvokeMember.
            flags must specify Instance, Static, or both.
            </para>
        <para>
            If flags contains CreateInstance, then name is ignored and a constructor is invoked.
            </para>
        <para>
            If memberName names a field/property and flags contains SetField/SetProperty, 
            then the field/property's value is changed to args[args.Length-1].
            If args.Length &gt; 1, the field/property is indexed by args[0:(args.Length-2)].
            </para>
        <para>
            If memberName names a field/property and flags contains GetField/GetProperty, 
            then the field/property's value is returned.  
            If args != null and the field/property is a delegate, then it is invoked with args.
            Otherwise if args != null, the field/property is indexed by args.
            </para>
        <para>
            If memberName names an event and flags contains GetField, 
            then the event's EventInfo is returned.  
            If args != null, then the event is raised with args.
            </para>
        <para>
            If memberName names a method and flags contains InvokeMethod, 
            then it is invoked with args.  A static method is invoked with target and args.
            If args == null, then the result is a DelegateGroup containing all overloads of the method.
            </para>
        <para>
            Other flag values are implemented as in Type.InvokeMember.
            In each case, overloading is resolved by matching the argument types, possibly with conversions.
            </para>
        <para>
            If a matching member is not found, the interfaces of the type are also searched.
            As a last resort, if the memberName is op_Equality or op_Inequality, then a default implementation
            is provided (as in C#).
            </para>
      </remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetTypeArray(System.Object[])">
      <summary>
            Gets the types of the objects in the specified array. 
            </summary>
      <param name="args">An array of objects whose types to determine.  args[i] can be null, whose type is assumed to be typeof(Nullable).</param>
      <returns>An array of Type objects representing the types of the corresponding elements in args. </returns>
      <remarks>This method is the same as Type.GetTypeArray except it allows null values.</remarks>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.Invoke(System.Reflection.MethodBase[],System.Object,System.Object[])">
      <summary>
            Invoke the method which best matches the argument types.
            </summary>
      <param name="methods">A non-empty list of methods, exactly one of which will be invoked.  Can include both static and instance methods.</param>
      <param name="target">The instance for an instance method, or if non-null, the first argument of a static method.</param>
      <param name="args">The remaining arguments of the method.</param>
      <returns>The return value of the method.</returns>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.Invoke(System.Reflection.MethodBase,System.Object,System.Object[])">
      <summary>
            Invoke a generic method by inferring type parameters from the method arguments.
            </summary>
      <param name="method">
      </param>
      <param name="target">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetBestMethod(System.Type,System.String,System.Reflection.BindingFlags,System.Type,System.Type[],System.Exception@)">
      <summary>
            Find the method which best matches the given arguments.
            </summary>
      <param name="type">
      </param>
      <param name="memberName">
      </param>
      <param name="flags">
      </param>
      <param name="targetType">The type of <c>this</c>, for instance methods.  If looking for a static method, use null.</param>
      <param name="argTypes">Types.  argTypes.Length == number of method parameters.  argTypes[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="exception">Exception created on failure</param>
      <returns>null on failure.</returns>
      <exception cref="T:System.ArgumentException">The best matching type parameters did not satisfy the constraints of the generic method.</exception>
      <exception cref="T:System.MissingMethodException">No match was found.</exception>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetBestMethod(System.Reflection.MethodBase[],System.Type,System.Type[],System.Exception@)">
      <summary>
            Find the method which best matches the given arguments.
            </summary>
      <param name="methods">
      </param>
      <param name="targetType">The type of <c>this</c>, for instance methods.  If looking for a static method, use null.</param>
      <param name="argTypes">Types.  argTypes.Length == number of method parameters.  argTypes[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="exception">Exception created on failure</param>
      <returns>A non-null MethodBase.</returns>
      <exception cref="T:System.ArgumentException">The best matching type parameters did not satisfy the constraints of the generic method.</exception>
      <exception cref="T:System.MissingMethodException">No match was found.</exception>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.GetBestMethod(System.Reflection.MethodBase[],System.Type,System.Type[],Microsoft.Dynamic.ConversionOptions,Microsoft.Dynamic.Binding@,System.Exception@)">
      <summary>
            Find the method which best matches the given arguments.
            </summary>
      <param name="methods">Methods to search through</param>
      <param name="targetType">The type of <c>this</c>, for instance methods.  If looking for a static method, use null.</param>
      <param name="argTypes">Types.  argTypes.Length == number of method parameters.  argTypes[i] may be null to allow any type, or typeof(Nullable) to mean "any nullable type".</param>
      <param name="conversionOptions">Specifies which conversions are allowed</param>
      <param name="binding">Modified to contain the generic type arguments and argument conversions needed for calling the method</param>
      <param name="exception">Exception created on failure</param>
      <returns>A non-null MethodBase.</returns>
      <exception cref="T:System.ArgumentException">The best matching type parameters did not satisfy the constraints of the generic method.</exception>
      <exception cref="T:System.MissingMethodException">No match was found.</exception>
    </member>
    <member name="M:Microsoft.Dynamic.Invoker.Clone(System.Object)">
      <summary>
            Clone an object by reflection on its fields.
            </summary>
      <param name="o">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.GraphSearcher`2">
      <summary>
            Performs depth-first search or breadth-first search on a graph.
            </summary>
      <typeparam name="NodeType">
      </typeparam>
      <typeparam name="EdgeType">
      </typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.BreadthFirstSearch`1.SearchQueue">
      <summary>
            A queue of nodes for breadth-first search.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.ConvertedCollection`2">
      <summary>
            A virtual collection whose items are converted from another collection.
            </summary>
      <typeparam name="FromType">
      </typeparam>
      <typeparam name="ToType">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CycleFinder`1">
      <summary>
            Find all elementary cycles of a directed graph
            </summary>
      <typeparam name="NodeType">The node type</typeparam>
      <remarks>
        <para>
            The cycles are described by firing actions according to the pattern:
            BeginCycle, AddNode, AddNode, ..., AddNode, EndCycle, BeginCycle, ..., EndCycle.
            The nodes in a cycle will appear in order of the directed edges between them.
            </para>
        <para>
            The algorithm comes from:
            "Finding all the Elementary Circuits of a Directed Graph"
            Donald B. Johnson 
            SIAM Journal on Computing  (1975) 
            http://dutta.csc.ncsu.edu/csc791_spring07/wrap/circuits_johnson.pdf
            The runtime is O((n+e)(c+1)) where n is the number of nodes, e is the number of edges, and c
            is the number of cycles in the graph.
            </para>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.CycleFinder`1.SearchFrom(`0,`0)">
      <summary>
            Find cycles containing root 
            </summary>
      <param name="node">
      </param>
      <param name="root">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CycleFinder`2">
      <summary>
            Find all elementary cycles of a directed graph
            </summary>
      <typeparam name="NodeType">The node type</typeparam>
      <typeparam name="EdgeType">The edge type</typeparam>
      <remarks>
        <para>
            The cycles are described by firing actions according to the pattern:
            BeginCycle, AddEdge, AddEdge, ..., AddEdge, EndCycle, BeginCycle, ..., EndCycle.
            The edges in a cycle will appear in order of their directions.
            </para>
        <para>
            The algorithm comes from:
            "Finding all the Elementary Circuits of a Directed Graph"
            Donald B. Johnson 
            SIAM Journal on Computing  (1975) 
            http://dutta.csc.ncsu.edu/csc791_spring07/wrap/circuits_johnson.pdf
            The runtime is O((n+e)(c+1)) where n is the number of nodes, e is the number of edges, and c
            is the number of cycles in the graph.
            </para>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.CycleFinder`2.SearchFrom(`0)">
      <summary>
            Find cycles containing root 
            </summary>
      <param name="node">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2">
      <summary>
            Order the nodes to best satisfy cyclic dependencies.
            </summary>
      <remarks>
        <p>
            The algorithm is essentially a topological sort, modified to deal with cycles.
            In case of a directed cycle, we search for a node which can execute before some of its parents.
            This judgement is made by the canExecute predicate.
            </p>
        <p>
            Algorithm:
            For each target node, we run bfs backward to collect a list of ancestors and their finishing times.
            These ancestor nodes are placed in a priority queue according to their finishing time.
            We then examine each node on the queue to determine if its input requirements are satisfied.
            If so, the node is scheduled.  If not, we put it aside to wait until one of its unscheduled parents is scheduled.
            </p>
        <p>
            SourcesOf and CreateNodeData are the only graph methods used.  The Nodes property is not used.
            </p>
      </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.CostUpdater">
      <summary>
            Called to update the cost of scheduling a node.
            </summary>
      <param name="node">
      </param>
      <param name="isScheduled">
      </param>
      <param name="cost">The previous cost, which may be modified in place for efficiency.  May be null.</param>
      <returns>
      </returns>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.IsScheduled">
      <summary>
            Indicates if the node has been placed on the schedule.
            </summary>
      <remarks>
            Unlike WasScheduledLastIteration, this information changes throughout the scheduling process.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.StopScheduling">
      <summary>
            Indicates if scheduling should stop.  Takes the latest node to be scheduled.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.MaxScheduledCost">
      <summary>
            The maximum cost of a scheduled node.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.ApplyThreshold">
      <summary>
            Indicates that only nodes whose cost is less than Threshold will be scheduled.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.addToSchedule">
      <summary>
            Called just before IsScheduled[node] is set to true.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.queue">
      <summary>
            Queue of nodes waiting to be scheduled.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Graphs.CyclicDependencySort`2.Threshold">
      <summary>
            Cost at which nodes will not be scheduled.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.DepthFirstSearch`1.SearchStack">
      <summary>
            A stack of nodes for depth-first search.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.DepthFirstSearch`2.SearchStack">
      <summary>
            A stack of nodes for depth-first search.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.DistanceSearch`1">
      <summary>
            Computes the distance to all nodes reachable from a starting node.
            </summary>
      <typeparam name="NodeType">The node type.</typeparam>
      <remarks>
            The distances are returned via the SetDistance action.  Nodes which are unreachable from the
            starting node will have no distance set.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.IEdge`1">
      <summary>
            An edge with stored endpoints.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
      <remarks>This is a commonly-used interface for an edge object which stores its endpoints.
            Edge handles are not required to implement it.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Edge`1">
      <summary>
            A basic edge object.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CanCreateNodeData`1">
      <summary>
            An interface for attaching data to node handles.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
      <remarks>
            This interface allows general graph algorithms to attach data to graph nodes.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.CanCreateNodeData`1.CreateNodeData``1(``0)">
      <summary>
            Create a mapping from node handles to data.
            </summary>
      <typeparam name="T">The type of data to store.</typeparam>
      <returns>A mapping initialized to defaultValue.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.IGraph`1">
      <summary>
            A graph of nodes and edges.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
      <remarks>
        <p>
            This interface is intended for use by generic algorithms which can operate on any graph type.
            Nodes are treated as opaque handles, generated by the graph, which only the graph knows how to resolve.
            Some graph types might represent nodes as objects with edge data; other graphs might use integer indices or even strings.
            </p>
        <p>
            This interface can be used for both directed and undirected graphs, though the methods only provide
            undirected information (i.e. all neighbors rather than sources vs. targets).
            See <see cref="T:MicrosoftResearch.Infer.Graphs.IMutableGraph`1" /> for methods to modify a graph, and <see cref="T:MicrosoftResearch.Infer.Graphs.IDirectedGraph`1" />
            to get directed edge information.
            In this interface, edges are represented implicitly as (source, target) pairs.
            See <see cref="T:MicrosoftResearch.Infer.Graphs.IGraph`2" /> for methods using explicit edge handles.
            </p>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`1.NeighborCount(`0)">
      <summary>
            Number of adjacent nodes.
            </summary>
      <param name="node">A node handle.</param>
      <returns>The number of nodes adjacent to <paramref name="node" />.</returns>
      <remarks>For a directed graph, this is the number of sources (parents) plus the number of targets (children) of <paramref name="node" /></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`1.NeighborsOf(`0)">
      <summary>
            Adjacent nodes.
            </summary>
      <param name="node">A node handle.</param>
      <returns>The nodes adjacent to <paramref name="node" /></returns>
      <remarks>For a directed graph, this is the sources (parents) and targets (children) of <paramref name="node" />, in any order.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`1.ContainsEdge(`0,`0)">
      <summary>
            Test for an edge.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>True if an edge exists from <paramref name="source" /> to <paramref name="target" /></returns>
      <remarks>
            For some graph types, source and target are not required to be nodes in the graph.
            That is, ContainsEdge(source,target) can be true even if Nodes.Contains(source) is false.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Graphs.IGraph`1.Nodes">
      <summary>
            Collection of node handles.
            </summary>
      <remarks>
            The methods Add(NodeType) and Contains(NodeType) which are defined by <see cref="T:System.Collections.Generic.ICollection`1" />
            are not necessarily supported (in order to use them, you would have to have a valid node handle, which
            implies the node is already in the graph).  The methods Remove(NodeType) and Clear() are only supported
            by mutable graphs, and they are only guaranteed to remove node handles from the Nodes collection; 
            the edges connected to those nodes may still exist in the graph.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Graph`1">
      <summary>
            A directed graph of HasTargets objects.
            </summary>
      <remarks>
        <p>
            Abstractly, a directed graph is a collection of node pairs (node1,node2).
            Each pair is called an edge.  An edge from a node to itself (a 
            self-loop) is allowed.  Duplicate edges are allowed.  Edges to nodes
            outside of the graph are allowed.
            </p>
        <p>
            A node is added via <c>g.Nodes.Add(node)</c> and an edge is added via
            <c>g.AddEdge(node1,node2)</c>.
            </p>
        <p>
            This implementation supports node labels, which can be any object.
            A labeled node is added via <c>g.Nodes.WithLabel(label).Add(node)</c>.
            </p>
        <p>
            The graph is implemented by an adjacency list which can be singly or 
            doubly-linked.
            The list is distributed among the nodes of the graph, which hold their
            child nodes and possibly also their parent nodes (in the 
            doubly-linked case).
            Nodes which implement the HasSources interface will be doubly-linked,
            and other nodes will be singly-linked.
            Thus the graph can be part doubly-linked and part singly-linked.
            Doubly-linked nodes are more efficient to remove from the graph.
            </p>
      </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Graph`1.Data`2">
      <summary>
            Provides node and edge data for an existing graph.
            </summary>
      <typeparam name="NodeDataType">
      </typeparam>
      <typeparam name="EdgeDataType">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`1.AddEdge(`0,`0)">
      <summary>
            Add a directed edge from node to target.
            </summary>
      <param name="source">The source node.</param>
      <param name="target">The target node.</param>
      <remarks>The two nodes need not be in the graph, and will not be added to the graph.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`1.RemoveEdge(`0,`0)">
      <summary>
            Remove a directed edge from source to target.
            </summary>
      <param name="source">The source node.</param>
      <param name="target">The target node.</param>
      <remarks>If there are multiple edges from source to target, only one is removed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`1.ClearEdgesOf(`0)">
      <summary>
            Remove all edges connected to a node.
            </summary>
      <param name="node">
      </param>
      <remarks>
            The node itself is not removed.  In the singly-linked case, the graph is scanned for
            all nodes which link to <paramref name="node" /> and these links are cut.
            In this case, there may still be links from outside the graph.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`1.ClearEdges">
      <summary>
            Remove all edges in the graph.
            </summary>
      <remarks>In the singly-linked case, there may still be links from outside the graph.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`1.Add(MicrosoftResearch.Infer.Graphs.Graph{`0})">
      <summary>
            Add all nodes from another graph.
            </summary>
      <param name="that">
      </param>
      <remarks>Nodes are added as references, i.e. they are not cloned.  No new edges are created.</remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.EdgeFactory`2">
      <summary>
      </summary>
      <typeparam name="NodeType">
      </typeparam>
      <typeparam name="EdgeType">
      </typeparam>
      <param name="source">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.IGraph`2">
      <summary>
            A graph with explicit edge handles.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
      <typeparam name="EdgeType">The type of an edge handle.</typeparam>
      <remarks>
        <p>
            This interface is intended for use by generic algorithms which can operate on any graph type.
            Nodes and edges are treated as opaque handles, generated by the graph, which only the graph knows how to resolve.
            As a consequence, the methods AddEdge(EdgeType) and ContainsEdge(EdgeType) are not necessarily supported, because
            in order to use them, you would have to have a valid edge handle, which implies the edge already exists in the graph.
            </p>
        <p>
            This interface can be used for both directed and undirected graphs, though the methods only provide
            undirected information (i.e. all edges rather than in-edges vs. out-edges).
            See <see cref="T:MicrosoftResearch.Infer.Graphs.IMutableGraph`2" /> for methods to modify a graph, and <see cref="T:MicrosoftResearch.Infer.Graphs.IDirectedGraph`2" />
            to get directed edge information.
            </p>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`2.GetEdge(`0,`0)">
      <summary>
            Get an edge handle.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>An edge handle if the edge exists and is unique.</returns>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.EdgeNotFoundException">If there is no edge from source to target.</exception>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.AmbiguousEdgeException">If there is more than one edge from source to target.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`2.TryGetEdge(`0,`0,`1@)">
      <summary>
            Get an edge handle.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <param name="edge">An edge handle if the edge exists and is unique, otherwise <c>default(EdgeType)</c>.</param>
      <returns>True if there is an edge from source to target.</returns>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.AmbiguousEdgeException">If there is more than one edge from source to target.</exception>
      <remarks>This method combines the functionality of ContainsEdge(source,target) and GetEdge(source,target).</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IGraph`2.EdgesOf(`0)">
      <summary>
            All edges connected to a node.
            </summary>
      <param name="node">A node handle.</param>
      <returns>All edges connected to <paramref name="node" />.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.IMultigraph`2">
      <summary>
            A graph which may have parallel edges.
            </summary>
      <typeparam name="NodeType">The type of a node handle.</typeparam>
      <typeparam name="EdgeType">The type of an edge handle.</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IMultigraph`2.EdgeCount(`0,`0)">
      <summary>
            Count the edges between nodes.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>The number of edges from <paramref name="source" /> to <paramref name="target" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IMultigraph`2.EdgesLinking(`0,`0)">
      <summary>
            Get edge handles.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>All edges from source to target.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IMultigraph`2.AnyEdge(`0,`0,`1@)">
      <summary>
            Get an edge handle.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <param name="edge">An edge handle if an edge exists, otherwise <c>default(EdgeType)</c>.</param>
      <returns>True if there is an edge from source to target.</returns>
      <remarks>This method combines the functionality of ContainsEdge(source,target) and GetAnyEdge(source,target).</remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.CanCreateEdgeData`1">
      <summary>
            An interface for attaching data to edge handles.
            </summary>
      <typeparam name="EdgeType">The type of an edge handle.</typeparam>
      <remarks>
            This interface allows general graph algorithms to attach data to graph edges.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.CanCreateEdgeData`1.CreateEdgeData``1(``0)">
      <summary>
            Create a mapping from edge handles to data.
            </summary>
      <typeparam name="T">The type of data to store.</typeparam>
      <returns>A mapping initialized to defaultValue.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Graph`2">
      <summary>
            A directed graph with explicit node and edge objects.
            </summary>
      <typeparam name="NodeType">
      </typeparam>
      <typeparam name="EdgeType">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Graph`2.Data`2">
      <summary>
            Provides node and edge data for an existing graph.
            </summary>
      <typeparam name="NodeDataType">
      </typeparam>
      <typeparam name="EdgeDataType">
      </typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.Graph`2.EdgeFactory">
      <summary>
            A delegate to create edge objects.
            </summary>
      <remarks>
            The delegate only creates the edge object; it does not register the edge with the endpoints.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`2.GetAnyEdge(`0,`0)">
      <summary>
            Get an edge handle.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>An edge handle if an edge exists.</returns>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.EdgeNotFoundException">If there is no edge from source to target.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`2.CopyEdge(`1,`0,`0)">
      <summary>
            Copy edge data to another source and target.
            </summary>
      <param name="edge">
      </param>
      <param name="source">
      </param>
      <param name="target">
      </param>
      <returns>A new edge with the same data as edge but between source and target.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`2.CopyEdges(`0,`0)">
      <summary>
            Copy edges from one node to another.
            </summary>
      <param name="node">
      </param>
      <param name="node2">
      </param>
      <remarks>
            For every edge (node,x) or (x,node), an edge (node2,x) or (x,node2) is created, with the
            same label.
            The existing edges of <paramref name="node2" /> are left unchanged.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`2.#ctor(MicrosoftResearch.Infer.Graphs.Graph{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="g">
      </param>
      <remarks>Clones all nodes in <paramref name="g" />, preserving edges between them
            and to nodes outside the graph.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Graph`2.CheckValid">
      <summary>
            Check that parent and child edges match.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.VisitState">
      <summary>
            Labels for depth-first search.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.IndexedGraph.GetAnyEdge(System.Int32,System.Int32)">
      <summary>
            Get an edge handle.
            </summary>
      <param name="source">A node handle.</param>
      <param name="target">A node handle.</param>
      <returns>An edge handle if an edge exists.</returns>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.EdgeNotFoundException">If there is no edge from source to target.</exception>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.IndexedGraphWrapper`2">
      <summary>
            Create a graph from a collection of nodes and corresponding adjacency data.
            </summary>
      <typeparam name="Node">The type of a node handle.</typeparam>
      <typeparam name="NodeInfo">The type of a node data structure.</typeparam>
      <remarks>
        <para>
            This class creates a directed graph object from a collection of node handles and data objects.
            The data object is assumed to hold the adjacency information for the handles, in the form
            of a delegate sourcesOfNode(data) which returns a collection of node handles.
            Each node is given an integer index.
            Using these integers you can attach additional data to the graph via CreateNodeData which returns an array.
            </para>
        <para>
            In the simplest case, NodeInfo can be the same as Node in which case this class just stores
            a mapping from nodes to integers and vice versa.  
            (The delegate infoOfNode would simply return its argument.)
            More generally, NodeInfo can store cached information about the node.
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.IndexedGraphWrapper`2.indexOfNode">
      <summary>Provides an index (into info[]) for each node.</summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.IndexedProperty`2.Get">
      <summary>
            Delegate for retrieving data at an index.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.IndexedProperty`2.Set">
      <summary>
            Delegate for setting data at an index.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.IndexedProperty`2.Clear">
      <summary>
            Delegate for clearing the mapping.
            </summary>
      <remarks>
            If the mapping has a default value, this sets all data to that value.
            Otherwise the mapping is undefined at all values.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Graphs.IndexedProperty`2.Item(`0)">
      <summary>
            Get or set data at an index.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.KeyValueList`2">
      <summary>
            A list of KeyValuePairs, accessible as separate lists.
            </summary>
      <typeparam name="KeyType">
      </typeparam>
      <typeparam name="ValueType">
      </typeparam>
      <remarks>
            Unlike a Dictionary, Keys do not have to be unique, and may be changed at any time.
            Keys and Values are always the same length.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.KeyValueList`2.ClearKey(`0)">
      <summary>
            Delete all pairs with a given key.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.KeyValueList`2.ClearValue(`1)">
      <summary>
            Delete all pairs with a given value.
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.KeyValueList`2.#ctor(MicrosoftResearch.Infer.Graphs.KeyValueList{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="list">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.ILabeledCollection`2">
      <summary>
            A collection which is the union of labeled subcollections.
            </summary>
      <typeparam name="ItemType">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
      <remarks>
        <p>
            This interface corresponds to an inverted index, where each label maps to a subset of items.
            This is unlike an IDictionary, where each key maps to a single item.
            When the labels are sparse, an inverted index is more efficient than attaching a label to each item and searching
            through the items.
            The subcollections may overlap.
            </p>
        <p>
            Add(ItemType) is equivalent to using the default label, which may be default(LabelType) or some
            other value such as an empty string ("").
            The other ICollection methods, such as Count and Clear, apply to all items regardless of label.
            </p>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.ILabeledCollection`2.WithLabel(`1)">
      <summary>
            Get a subcollection.
            </summary>
      <param name="label">The label of an existing subcollection or a subcollection to be created.</param>
      <returns>A subcollection of items.</returns>
      <remarks>If the subcollection already exists, it is returned.  Otherwise, a new subcollection is created and returned.
            The result is mutable.  Some LabeledCollection classes may not allow certain labels.
            </remarks>
      <exception cref="T:MicrosoftResearch.Infer.Graphs.InvalidLabelException">If the label is not allowed by the collection.</exception>
    </member>
    <member name="P:MicrosoftResearch.Infer.Graphs.ILabeledCollection`2.Labels">
      <summary>
            The labels of the subcollections.
            </summary>
      <remarks>
            Labels must be unique.  The returned collection must not be modified.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.LabeledCollection`2">
      <summary>
            A default implementation of ILabeledCollection.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
      <remarks>
            This base class implements all of the ICollection methods in terms of the 
            two ILabeledCollection methods.
            This makes it easy to create new ILabeledCollection classes, just by 
            implementing the two ILabeledCollection methods.
            It assumes that the subcollections do not overlap.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.LabeledCollectionWrapper`3">
      <summary>
            A base class for LabeledCollection wrapper classes.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
      <typeparam name="ListType">
      </typeparam>
      <remarks>	
            This class makes it easy to write decorators for LabeledCollections.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.ILabeledDictionary`3">
      <summary>
            A dictionary which is the union of labeled sub-dictionaries.
            </summary>
      <typeparam name="KeyType">
      </typeparam>
      <typeparam name="ValueType">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2">
      <summary>
            A directed graph of HasTargets objects.
            </summary>
      <remarks>
        <para>
            This implementation of graphs also supports edge labels, which can be
            any object.  Thus an edge is actually a triple (node1,node2,label). 
            If not specified, the label defaults to an empty string ("").
            Similar to hash keys, edge labels should not change once 
            the edge is added to the graph.  Instead you must delete the edge and 
            add it back with a new label.  
            Edge labels can be used analogously to properties in C#.
            That is, node1 can link to node2 via the label "Parent", to 
            indicate that node2 is the parent of node1.
            This allows graphs to represent typed linkage structures 
            similar to hand-coded C# object structures.  
            See BinaryTree.cs for an example.
            </para>
        <para>
            Edge labels are not meant to replace edge objects.  If you want a graph
            with explicit mutable edge objects, make these objects into nodes
            with properties Head and Tail.  Then make a bipartite graph between
            the intended node objects and the intended edge objects, using these
            properties as the edge labels.
            You can also create hypergraphs this way.
            </para>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.AddEdge(`0,`0,`1)">
      <summary>
            Add a labeled, directed edge from source to target.
            </summary>
      <param name="source">
      </param>
      <param name="target">
      </param>
      <param name="label">
      </param>
      <remarks>The two nodes need not be in the graph, and will not be added to the graph.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.RemoveEdge(`0,`0,`1)">
      <summary>
            Remove a directed edge from source to target with a given label.
            </summary>
      <param name="source">The source node.</param>
      <param name="target">The target node.</param>
      <param name="label">
      </param>
      <remarks>If there are multiple edges from node to target with the given label, only one is removed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.ClearEdges(`1)">
      <summary>
            Remove all edges in the graph with a given label.
            </summary>
      <remarks>In the singly-linked case, there may still be links from outside the graph.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.CopyEdges(`0,`0)">
      <summary>
            Copy edges from one node to another.
            </summary>
      <param name="fromNode">
      </param>
      <param name="toNode">
      </param>
      <remarks>
            For every edge (fromNode,x) or (x,fromNode), an edge (toNode,x) or (x,toNode) is created, with the
            same label.
            The existing edges of <paramref name="toNode" /> are left unchanged.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.#ctor(MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="g">
      </param>
      <remarks>Clones all nodes in <paramref name="g" />, preserving edges between them
            and to nodes outside the graph.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledEdgeGraph`2.CheckValid">
      <summary>
            Check that parent and child edges match.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.LabeledList`2">
      <summary>
            A list which is a union of labeled sublists.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
      <remarks>
            This class can be used to represent an inverted index, where each label maps to a list of items.
            It is implemented by a Dictionary of List objects, so the labels can have any type.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledList`2.#ctor(MicrosoftResearch.Infer.Graphs.LabeledList{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="list">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.LabeledSet`2">
      <summary>
            A set which is the union of labeled subsets.
            </summary>
      <typeparam name="ItemType">
      </typeparam>
      <typeparam name="LabelType">
      </typeparam>
      <remarks>
            It is implemented as a LabeledList where Add is overridden to prevent adding duplicates.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.MinCut`2">
      <summary>
            Finds a minimum edge cut to separate a set of sources from a set of sinks
            </summary>
      <typeparam name="NodeType">Node type</typeparam>
      <typeparam name="EdgeType">Edge type</typeparam>
      <remarks>
        <para>
            A node can be both a source and a sink.  In this case, edges into the node are considered toward the sink
            and edges out of the node are considered from the source.  Thus the algorithm will cut all paths from the
            node back to itself.
            </para>
        <para>
            By modifying IsSinkEdge, certain edges can be labelled as "sink edges".  These edges are treated as if 
            their target was a sink node.  Making a node both a source and sink is equivalent to making it a source and
            labelling its inward edges as sink edges.
            </para>
        <para>
            The implementation uses the preflow-push algorithm, modified to return the minimum cut,
            as described by Jianxiu Hao and James B. Orlin, 
            "A faster algorithm for finding the minimum cut in a directed graph", 
            Journal of Algorithms 17: 424--446 (1994).
            </para>
        <para>
            This algorithm can sometimes be very slow for certain choices of the capacities.
            This seems to be caused by loss of precision in the float calculations, e.g.
            when a edge with capacity 1e-8 pushes flow into an edge with capacity 1e+8.
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.reverseCapacity">
      <summary>
            Capacity of an edge in the reverse direction (default 0)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.Sources">
      <summary>
            The set of source nodes
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.Sinks">
      <summary>
            The set of sink nodes
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.IsSinkEdge">
      <summary>
            The set of sink edges
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.nodesAtDistance">
      <summary>
            A cache of the nodes at a given distanceToSink
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.flow">
      <summary>
            The flow in the direction of the edge (always between -reverseCapacity and the capacity)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.excess">
      <summary>
            A cache of (inward flow - outward flow)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.sourceGroup">
      <summary>
            The nodes on the source side of the cut
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.MinCut`2.activeNodes">
      <summary>
            All nodes that are not in the sourceGroup, not a sink, and have inward flow &gt; outward flow
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.MinCut`2.GetSourceGroup">
      <summary>
            Compute the min cut and return all nodes connected to any source
            </summary>
      <returns>The set of all nodes connected to any source after removing the min cut edges</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.DirectedNode`1">
      <summary>
            Stores a list of source nodes and target nodes. (Does not store edges.)
            </summary>
      <typeparam name="T">Node type to link to (usually a DirectedNode itself).</typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.DirectedNode`2">
      <summary>
            Stores a list of OutEdges and InEdges.
            </summary>
      <typeparam name="T">Node type used by the edges.</typeparam>
      <typeparam name="E">Edge type to store.</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.LabeledDirectedNode`2.#ctor(MicrosoftResearch.Infer.Graphs.LabeledDirectedNode{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.Node2`1.#ctor(MicrosoftResearch.Infer.Graphs.Node2{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.BasicNode`1">
      <summary>
            Directed graph node holding data of type T
            </summary>
      <typeparam name="T">The data type</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.BasicNode`1.#ctor(MicrosoftResearch.Infer.Graphs.BasicNode{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.BasicNode.#ctor(MicrosoftResearch.Infer.Graphs.BasicNode)">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.BasicEdgeNode.#ctor(MicrosoftResearch.Infer.Graphs.BasicEdgeNode)">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.BasicLabeledDirectedNode.#ctor(MicrosoftResearch.Infer.Graphs.BasicLabeledDirectedNode)">
      <summary>
            Copy constructor.
            </summary>
      <param name="node">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.PathFinder`1">
      <summary>
            Find all elementary paths of a directed graph
            </summary>
      <typeparam name="NodeType">The node type</typeparam>
      <remarks>
        <para>
            The paths are described by firing actions according to the pattern:
            BeginPath, AddNode, AddNode, ..., AddNode, EndPath, BeginPath, ..., EndPath.
            The node on a path will appear in order of the directed edges between them.
            </para>
        <para>
            Only paths which cannot be made longer are returned, i.e. sub-paths of an elementary path are not returned.
            </para>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.PathFinder`1.SearchFrom(`0)">
      <summary>
            Find all paths starting with the given node
            </summary>
      <param name="node">Starting node</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.PathFinder`2">
      <summary>
            Find all elementary paths of a directed graph
            </summary>
      <typeparam name="NodeType">The node type</typeparam>
      <typeparam name="EdgeType">The edge type</typeparam>
      <remarks>
        <para>
            The paths are described by firing actions according to the pattern:
            BeginPath, AddEdge, AddEdge, ..., AddEdge, EndPath, BeginPath, ..., EndPath.
            The edges on a path will appear in order of their directions.
            </para>
        <para>
            Only paths which cannot be made longer are returned, i.e. sub-paths of an elementary path are not returned.
            </para>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.PathFinder`2.SearchFrom(`0)">
      <summary>
            Find all paths starting with the given node
            </summary>
      <param name="node">Starting node</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.NodeOnPathFinder`1">
      <summary>
            Find all nodes on any path from a source set to a sink set
            </summary>
      <typeparam name="NodeType">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.PseudoPeripheralSearch`1">
      <summary>
            Searches for a pair of pseudo-peripheral nodes in a graph.
            </summary>
      <remarks>
            The nodes <c>(start,end)</c> form a pseudo-peripheral pair
            if <c>end</c> is the furthest node from <c>start</c> and <c>start</c> is the
            furthest node from <c>end</c>.  
            If the distance is maximal over all such pairs, then
            the nodes are peripheral. 
            This class does not guarantee that the pair is peripheral, only pseudo-peripheral.
            In a directed graph, distance from <c>start</c> is measured forward and distance from
            <c>end</c> is measured backward.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Graphs.PseudoPeripheralSearch`1.SearchFrom(`0@,`0@)">
      <summary>
            Find a pseudo-peripheral pair.
            </summary>
      <param name="start">On entry, holds an initial seed for the search.  On return, holds the start node of the pair.</param>
      <param name="end">On return, holds the end node of the pair.</param>
      <remarks>Regardless of the seed node provided, a pseudo-peripheral pair will always be found.
            However the seed can affect the quality of the pair (i.e. how distant they are).</remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.Range">
      <summary>
            Represents a collection of integers in sequence from LowerBound to UpperBound.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.MultiRange">
      <summary>
            Represents a multidimensional grid of integer points.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.StackAsList`1">
      <summary>
            Wraps a stack to look like a list where you can only access index 0.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.QueueAsList`1">
      <summary>
            Wraps a Queue to look like a list where you can only access index 0.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.StrongComponents`1">
      <summary>
            Find the strongly connected components of a directed graph.
            </summary>
      <typeparam name="NodeType">The node type.</typeparam>
      <remarks>
        <para>
            A strongly connected component is a maximal set of nodes that can all reach each other by a directed path.
            Every directed graph has a unique partition of nodes into strongly connected components.
            The components form a DAG, since there cannot be any directed cycle among the components.
            </para>
        <para>
            Given a graph and a set of start nodes, this class enumerates the strongly connected components 
            that are reachable from the start nodes.  
            The components are described by firing actions according to the pattern:
            BeginComponent, AddNode, AddNode, ..., AddNode, EndComponent, BeginComponent, ..., EndComponent.
            The nodes in a component will appear in an arbitrary order.
            The components will appear in topological order, i.e. there are no edges from
            a later component to an earlier component.
            </para>
        <para>
            The implementation uses depth first search in each direction (Kosaraju's algorithm), as described by Cormen, Leiserson, and Rivest.
            </para>
      </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Graphs.StrongComponents2`1">
      <summary>
            Find the strongly connected components of a directed graph.
            </summary>
      <typeparam name="NodeType">The node type.</typeparam>
      <remarks>
        <para>
            A strongly connected component is a maximal set of nodes that can all reach each other by a directed path.
            Every directed graph has a unique partition of nodes into strongly connected components.
            The components form a DAG, since there cannot be any directed cycle among the components.
            </para>
        <para>
            Given a graph and a set of start nodes, this class enumerates the strongly connected components 
            that are reachable from the start nodes.  
            The components are described by firing actions according to the pattern:
            BeginComponent, AddNode, AddNode, ..., AddNode, EndComponent, BeginComponent, ..., EndComponent.
            The nodes in a component will appear in an arbitrary order.
            The components will appear in reverse topological order, i.e. there are no edges from
            an earlier component to a later component.
            </para>
        <para>
            The implementation uses Pierce's algorithm (a modification of Tarjan's algorithm):
            "An Improved Algorithm for Finding the Strongly Connected Components of a Directed Graph"
            David J. Pearce, Technical Report, 2005
            http://www.mcs.vuw.ac.nz/~djp/files/P05.ps
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Graphs.StrongComponentChecker`2.IsStrong">
      <summary>
            Modified by SearchFrom
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.HasName">
      <summary>
            Interface which allows an object to expose a name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.HasName.Name">
      <summary>
            The name
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.IAlgorithm">
      <summary>
            Interface for inference algorithms
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for this algorithm's operator methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for this algorithm's evidence method
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.GetMessagePrototype(MicrosoftResearch.Infer.Transforms.ChannelInfo,MicrosoftResearch.Infer.Transforms.MessageDirection,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.String,System.Collections.Generic.IList{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the message prototype for this algorithm in the specified direction
            </summary>
      <param name="channelInfo">The channel information</param>
      <param name="direction">The direction</param>
      <param name="marginalPrototypeExpression">The marginal prototype expression</param>
      <param name="path">Sub-channel path</param>
      <param name="queryTypes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.ModifyFactorAttributes(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.AttributeRegistry{System.Object,MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Allows the algorithm to modify the attributes on a factor. For example context-specific
            message attributes on a method invoke expression
            </summary>
      <param name="factorExpression">The expression</param>
      <param name="factorAttributes">Attribute registry</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.ForEachDefaultQueryType(System.Action{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the default inference query types for a variable for this algorithm.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.IAlgorithm.GetQueryTypeBinding(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Get the query type binding - this is the path to the given query type
            relative to the raw marginal type.
            </summary>
      <param name="qt">The query type</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.IAlgorithm.ShortName">
      <summary>
            Short name for the inference algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.IAlgorithm.DefaultNumberOfIterations">
      <summary>
            Default number of iterations for this algorithm
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.AlgorithmBase">
      <summary>
            Abstract base class for all algorithms
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Algorithm's operator suffix - used in in message update methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for this algorithm's evidence method
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.GetMessagePrototype(MicrosoftResearch.Infer.Transforms.ChannelInfo,MicrosoftResearch.Infer.Transforms.MessageDirection,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.String,System.Collections.Generic.IList{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the message prototype for this algorithm in the specified direction
            </summary>
      <param name="channelInfo">The channel information</param>
      <param name="direction">The direction</param>
      <param name="marginalPrototypeExpression">The marginal prototype expression</param>
      <param name="path">Path name of message</param>
      <param name="queryTypes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.ModifyFactorAttributes(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.AttributeRegistry{System.Object,MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Allows the algorithm to modify the attributes on a factor. For example context-specific
            message attributes on a method invoke expression
            </summary>
      <param name="factorExpression">The expression</param>
      <param name="factorAttributes">Attribute registry</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.ForEachDefaultQueryType(System.Action{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the default inference query types for a variable for this algorithm.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.AlgorithmBase.GetQueryTypeBinding(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Get the query type binding - this is the path to the given query type
            relative to the raw marginal type.
            </summary>
      <param name="qt">The query type</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.AlgorithmBase.Name">
      <summary>
            The algorithm's name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.AlgorithmBase.ShortName">
      <summary>
            Short name for the inference algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.AlgorithmBase.DefaultNumberOfIterations">
      <summary>
            Default number of iterations for this algorithm
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.MaxProductBeliefPropagation">
      <summary>
            Max product belief propagation.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.MaxProductBeliefPropagation.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Max Product operator methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.MaxProductBeliefPropagation.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Max Product evidence method
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.MaxProductBeliefPropagation.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.MaxProductBeliefPropagation.Name">
      <summary>
            Name of the algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.MaxProductBeliefPropagation.ShortName">
      <summary>
            Short name of the algorithm
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.GibbsSampling">
      <summary>
            Gibbs sampling algorithm - includes block Gibbs sampling  
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Gibbs Sampling operator methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Gibbs Sampling evidence method
            Evidence is not supported or supportable for Gibbs. The message
            update methods are marked as unsupported so that an appropriate
            error message is generated by the model compiler
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.GetMessagePrototype(MicrosoftResearch.Infer.Transforms.ChannelInfo,MicrosoftResearch.Infer.Transforms.MessageDirection,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.String,System.Collections.Generic.IList{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the message prototype in the specified direction
            </summary>
      <param name="channelInfo">The channel information</param>
      <param name="direction">The direction</param>
      <param name="marginalPrototypeExpression">The marginal prototype expression</param>
      <param name="path">Path name of message</param>
      <param name="queryTypes">The set of queries to support.  Only used for marginal channels.</param>
      <returns>An expression for the method prototype</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.ModifyFactorAttributes(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.AttributeRegistry{System.Object,MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Allows the algorithm to modify the attributes on a factor. For example, in Gibbs sampling
            different message types are passed depending on the context. This is signalled to the MessageTransform
            by attaching a MessagePath attribute to the method invoke expression for the factor.
            If the factor is a 'variable' pseudo-factor (UsesEqualsDef) then all incoming variables are
            Distributions. Otherwise, incoming messages will depend on the grouping
            </summary>
      <param name="factorExpression">The factor expression</param>
      <param name="factorAttributes">Attribute registry</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.ForEachDefaultQueryType(System.Action{MicrosoftResearch.Infer.QueryType})">
      <summary>
            Get the default inference query types for a variable for this algorithm.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.GibbsSampling.GetQueryTypeBinding(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Get the query type binding for Gibbs sampling - this is the path to the given query type
            relative to the raw marginal type.
            </summary>
      <param name="qt">The query type</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.GibbsSampling.Name">
      <summary>
            Name of the algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.GibbsSampling.ShortName">
      <summary>
            Short name of the algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.GibbsSampling.BurnIn">
      <summary>
            The number of samples to discard at the beginning
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.GibbsSampling.Thin">
      <summary>
            Reduction factor when constructing sample and conditional lists
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.GibbsSampling.DefaultNumberOfIterations">
      <summary>
            Default number of iterations for Gibbs sampling
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ExpectationPropagation">
      <summary>
            The expectation propagation inference algorithm, see also  
            http://research.microsoft.com/~minka/papers/ep/roadmap.html.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.ExpectationPropagation.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Expectation Propagation operator methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ExpectationPropagation.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for Expectation Propagation evidence method
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ExpectationPropagation.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.ExpectationPropagation.Name">
      <summary>
            Name of the algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ExpectationPropagation.ShortName">
      <summary>
            Short name of the algorithm
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.VariableGroup">
      <summary>
            A group of variables processed together by an inference algorithm
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariableGroup.#ctor">
      <summary>
            Default constructor for when explicitly attaching GroupMember attributes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariableGroup.FromVariables(MicrosoftResearch.Infer.Models.Variable[])">
      <summary>
            Static constructor
            </summary>
      <param name="vars">List of variables</param>
      <returns>The variable group</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariableGroup.#ctor(MicrosoftResearch.Infer.VariableGroup)">
      <summary>
            Copy constructor
            </summary>
      <param name="that">The variable group we are copying from</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariableGroup.ToString">
      <summary>
            Returns a string representation of this variable group.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.VariableGroup.Variables">
      <summary>
            List of variables in the group
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.VariableGroup.Name">
      <summary>
            Name of the group
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.VariationalMessagePassing">
      <summary>
            The variational message passing algorithm, see also  
            http://www.johnwinn.org/Research/VMP.html and 
            http://en.wikipedia.org/wiki/Variational_message_passing.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariationalMessagePassing.GetOperatorMethodSuffix(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for variational message passing operator methods
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariationalMessagePassing.GetEvidenceMethodName(System.Collections.Generic.List{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Gets the suffix for variational message passing evidence method
            </summary>
      <param name="factorAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.VariationalMessagePassing.GetAlgorithmConversionOperator(System.Type,MicrosoftResearch.Infer.IAlgorithm,System.Boolean,System.Collections.Generic.List{System.Object})">
      <summary>
            Gets the operator which converts a message to/from another algorithm
            </summary>
      <param name="channelType">Type of message</param>
      <param name="alg2">The other algorithm</param>
      <param name="isFromFactor">True if from, false if to</param>
      <param name="args">Where to add arguments of the operator</param>
      <returns>A method reference for the operator</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.VariationalMessagePassing.Name">
      <summary>
            Name of the algorithm
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.VariationalMessagePassing.ShortName">
      <summary>
            Short name of the algorithm
            </summary>
    </member>
    <member name="T:MicrosoftResearch.TransformFramework.ICompilerAttribute">
      <summary>
            All compiler attributes must implement this interface
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Attrib">
      <summary>
            For use in MSL only, to add attributes to variables.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Attrib.Var``1(``0,MicrosoftResearch.TransformFramework.ICompilerAttribute[])">
      <summary>
            Adds a set of attributes to a variable.
            </summary>
      <typeparam name="T">The type of the variable</typeparam>
      <param name="variable">The variable to add attributes to</param>
      <param name="attrs">The attributes to add</param>
      <returns>The variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Attrib.AllVars(MicrosoftResearch.TransformFramework.ICompilerAttribute,System.Object[])">
      <summary>
            Adds a single attribute to a set of variables.
            </summary>
      <param name="attr">The attribute to add</param>
      <param name="vars">The variables to add the attribute to</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Attrib.InitialiseTo(System.Object,System.Object)">
      <summary>
            Specifies the initial marginal of a variable.
            </summary>
      <param name="var">The variable whose initial marginal is to be set</param>
      <param name="initialMessages">The initial marginal (or array of marginals)</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.InferenceEngine">
      <summary>
            An inference engine, used to perform inference tasks in Infer.NET.
            </summary>
      <remarks>
            The Debug class may be used to get debug messages for the inference engine.
            For example, use <code>Debug.Listeners.Add(new TextWriterTraceListener(Console.Out));</code>
            to get debug information for when compiled models and marginals are re-used.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.allEngineInstances">
      <summary>
            List of weak references to engine instances.  The weak references allow the instances
            to be garbage collected when they are no longer being used.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.algs">
      <summary>
            Internal list of built-in algorithms
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.DefaultEngine">
      <summary>
            Default inference engine whose settings will be copied onto newly created engines.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.mb">
      <summary>
            The ModelBuilder used to construct MSL from in-memory graphs of Variables etc.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.compiler">
      <summary>
            The Compiler used to compile MSL into a compiled algorithm.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.InferenceEngine.groups">
      <summary>
            Variable groupings for the algorithm
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.#ctor">
      <summary>
            Creates an inference engine which uses the default inference algorithm
            (currently this is expectation propagation).
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.#ctor(MicrosoftResearch.Infer.IAlgorithm)">
      <summary>
            Creates an inference engine which uses the specified inference algorithm.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.CreateCompiler">
      <summary>
            Create a new ModelCompiler object
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.#ctor(System.Boolean)">
      <summary>
            Creates an inference engine, optionally copying values from the default engine.
            </summary>
      <param name="copyValuesFromDefault">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.GetCodeToInfer(MicrosoftResearch.Infer.Models.IVariable)">
      <summary>
            Get the abstract syntax tree for the generated code.
            </summary>
      <returns>A list of type declaration objects.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Compile">
      <summary>
            Compiles the last built model into a CompiledAlgorithm which implements
            the specified inference algorithm on the model.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Infer(MicrosoftResearch.Infer.Models.IVariable)">
      <summary>
            Infers the marginal distribution for the specified variable.
            </summary>
      <param name="var">The variable whose marginal is to be inferred</param>
      <returns>The marginal distribution (or an approximation to it)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Infer(MicrosoftResearch.Infer.Models.IVariable,MicrosoftResearch.Infer.QueryType)">
      <summary>
            Performs an inference query for the specified variable, given a query type.
            </summary>
      <param name="var">The variable whose marginal is to be inferred</param>
      <param name="queryType">The type of query</param>
      <returns>The marginal distribution (or an approximation to it)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Infer``1(MicrosoftResearch.Infer.Models.IVariable)">
      <summary>
            Infers the marginal distribution for the specified variable.
            </summary>
      <typeparam name="TReturn">Desired return type which may be a distribution type or an array type if the argument is a VariableArray</typeparam>
      <param name="var">The variable whose marginal is to be inferred</param>
      <returns>The marginal distribution (or an approximation to it)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Infer``1(MicrosoftResearch.Infer.Models.IVariable,MicrosoftResearch.Infer.QueryType)">
      <summary>
            Infers the marginal distribution for the specified variable, and the specified
            query type
            </summary>
      <typeparam name="TReturn">Desired return type</typeparam>
      <param name="var">The variable whose marginal is to be inferred</param>
      <param name="queryType">The query type</param>
      <returns>The marginal distribution (or an approximation to it)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.ConvertDistributionToType``1(System.Object)">
      <summary>
            Attempts to convert the supplied object to the specified target type.
            Throws an ArgumentException if this is not possible.
            </summary>
      <remarks>
            Currently supports converting DistributionArray instances to .NET arrays and
            converting PointMass instances to distributions configured as point masses.
            </remarks>
      <typeparam name="T">The target type</typeparam>
      <param name="obj">The source object</param>
      <returns>The source object converted to type T</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.GetOutputMessage``1(MicrosoftResearch.Infer.Models.IVariable)">
      <summary>
            Computes the output message (message to the prior) for the specified variable.
            </summary>
      <typeparam name="Distribution">Desired distribution type</typeparam>
      <param name="var">The variable whose output message is to be inferred</param>
      <returns>The output message (or an approximation to it)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.GetCompiledInferenceAlgorithm(MicrosoftResearch.Infer.Models.IVariable[])">
      <summary>
            Returns a compiled algorithm which can later be used to infer marginal
            distributions for the specified variables.  This method allows more fine-grained
            control over the inference procedure.
            </summary>
      <remarks>This method should not be used unless fine-grained control over the
            inference is required.  Infer.NET will cache the last compiled algorithm
            and re-use it if possible.
            </remarks>
      <param name="vars">The variables whose marginals are to be computed by the returned algorithm.</param>
      <returns>An IGeneratedAlgorithm object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.GetRelevantModelExpressions(MicrosoftResearch.Infer.Models.IVariable[])">
      <summary>
            For advanced use. Returns all the model expressions that are relevant to
            inferring the set of variables provided.  This may be useful for constructing visualisations of the model.
            </summary>
      <remarks>
            The returned collection includes Variable and VariableArray objects which the engine has determined are
            relevant to inferring marginals over the variables provided.  This will at least include
            the provided variables, but may include other relevant variables as well.  It will also
            include MethodInvoke objects which act as priors, constraints or factors in the model.
            </remarks>
      <param name="vars">The variables to build a model for</param>
      <returns>A collection of model expressions</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.InvalidateCompiledAlgorithms">
      <summary>
            Ensures that the last compiled algorithm will not be re-used.  This should be called
            whenever a change is made that requires recompiling (but not rebuilding) the model.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Reset">
      <summary>
            For message passing algorithms, reset all messages to their initial values.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.SetTo(MicrosoftResearch.Infer.InferenceEngine)">
      <summary>
            Configures this inference engine by copying the settings from the supplied inference engine.
            </summary>
      <param name="engine">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.ShowFactorManager(System.Boolean)">
      <summary>
            Shows the factor manager, indicating which factors are available in Infer.NET and which
            are supported for each built-in inference algorithm.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.GetBuiltInAlgorithms">
      <summary>
            Returns an array of the built-in inference algorithms.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.ShowFactorManager(System.Boolean,MicrosoftResearch.Infer.IAlgorithm[])">
      <summary>
            Shows the factor manager, indicating which factors are available in Infer.NET and which
            are supported for the supplied list of inference algorithms.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferenceEngine.Group(MicrosoftResearch.Infer.Models.Variable[])">
      <summary>
            Add a variable group
            </summary>
      <param name="variables">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.Name">
      <summary>
            The full name of the inference engine, including version
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ModelName">
      <summary>
            Model name, used when naming generated classes.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.OptimiseForVariables">
      <summary>
            The variables to optimize the engine to infer.
            If set to a list of variables, only the specified variables can be inferred by this engine. 
            If set to null, any variable can be inferred by this engine.
            </summary>
      <remarks>
            Setting this property to a list of variables can improve performance by removing redundent
            computation and storage needed to infer marginals for variables which are not on the list.</remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ResetOnObservedValueChanged">
      <summary>
            If true (default), Infer resets messages to their initial values if an observed value has changed.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.Compiler">
      <summary>
            The model compiler that this inference engine uses.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.Algorithm">
      <summary>
            The default inference algorithm to use.  This can be overridden for individual
            variables or factors using the Algorithm attribute.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.NumberOfIterations">
      <summary>
            The number of iterations to use when executing the compiled inference algorithm.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowProgress">
      <summary>
            If true, prints progress information to the console during inference.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowTimings">
      <summary>
            If true, prints timing information to the console during inference. 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowMsl">
      <summary>
            If true, prints the model definition in Model Specification Language (MSL), prior
            to compiling the model. 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowWarnings">
      <summary>
            If true, any warnings encountered during model compilation will be printed to the console. 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowFactorGraph">
      <summary>
            If true, displays the factor graph for the model, prior to compiling it.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.SaveFactorGraphToFolder">
      <summary>
            If not null, the factor graph will be saved (in DGML format) to a file in the specified folder (created if necessary) under the model name and the extension ".dgml"
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.ShowSchedule">
      <summary>
            If true, displays the schedule for the model, after the scheduler has run.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.BrowserMode">
      <summary>
            Controls when the model compiler browser is shown
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceEngine.Groups">
      <summary>
            List of groups
            </summary>
    </member>
    <member name="E:MicrosoftResearch.Infer.InferenceEngine.ProgressChanged">
      <summary>
            Event that is fired when the progress of inference changes, typically at the
            end of one iteration of the inference algorithm.
            </summary>
    </member>
    <member name="E:MicrosoftResearch.Infer.InferenceEngine.MessageUpdated">
      <summary>
            Event that is fired when a message that has been marked with ListenToMessages has been updated.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.BrowserMode">
      <summary>
            Controls when the model compiler browser is shown.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.BrowserMode.Never">
      <summary>
            Never show the browser
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.BrowserMode.OnError">
      <summary>
            Show the browser only if an error occurs in compiling the model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.BrowserMode.Always">
      <summary>
            Always show the browser
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.InferenceProgressEventHandler">
      <summary>
            Delegate for handlers of inference progress events.
            </summary>
      <param name="engine">The inference engine which invoked the inference query</param>
      <param name="progress">The progress object describing the progress of the inference algorithm</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.InferenceProgressEventArgs">
      <summary>
            Provides information about the progress of the inference algorithm, as it
            is being executed.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceProgressEventArgs.Iteration">
      <summary>
            The iteration of inference that has just been completed.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.InferenceProgressEventArgs.Algorithm">
      <summary>
            The compiled algorithm which is performing the inference.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.MessageUpdatedEventHandler">
      <summary>
            Delegate for handlers of message updated events.
            </summary>
      <param name="algorithm">The generated algorithm which is being executed</param>
      <param name="messageEvent">The event object describing the message that has been computed</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.MessageUpdatedEventArgs">
      <summary>
            Provides information about a message that has just been updated, in the course
            of executing an inference algorithm.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.MessageUpdatedEventArgs.MessageId">
      <summary>
            The name of the variable holding the message
            in the generated code.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.MessageUpdatedEventArgs.Message">
      <summary>
            The message that was computed.  Note: this is the actual message
            and not a copy, so it should not be modified.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.InferNet">
      <summary>
            Class used in MSL only.
            </summary>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.InferNet.Infer(System.Object)">
      <summary>
            For use in MSL only.
            </summary>
      <param name="obj">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.InferNet.FireEvent``1(``0,System.String,System.Action{MicrosoftResearch.Infer.MessageUpdatedEventArgs},System.Boolean)">
      <summary>
            For use in MSL - fires an event when a message is updated (and optionally writes a trace as well).
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="input">
      </param>
      <param name="text">
      </param>
      <param name="onMessageUpdated">
      </param>
      <param name="doTraceAsWell">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.ValueRange">
      <summary>
            Specifies the range of values taken by an integer variable, or the dimension of a Dirichlet variable.
            This attribute can be used to explicitly specify the value range for a variable
            in cases where it cannot be deduced by the model compiler.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.ValueRange.Range">
      <summary>
            The range indicating the values a variable can take or the dimension of the variable.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.ValueRange.#ctor(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a ValueRange with the specified range.
            </summary>
      <param name="range">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.ValueRange.ToString">
      <summary>
            Returns a string representation of the ValueRange.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.MarginalPrototype">
      <summary>
            Specifies a prototype marginal distribution for a variable. This attribute
            can be used to explicitly specify the marginal distribution type for a variable
            in cases where it cannot be deduced by the model compiler.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.MarginalPrototype.prototype">
      <summary>
            The prototype marginal distribution
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.MarginalPrototype.#ctor(System.Object)">
      <summary>
            Creates a new marginal prototype attribute. This attribute
            targets variables.
            </summary>
      <param name="prototype">The marginal prototype</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.MarginalPrototype.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.Sequential">
      <summary>
            When attached to a Range, indicates that the elements of the range should be updated sequentially rather than in parallel.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.InitialiseTo">
      <summary>
            When attached to a Variable, specifies the initial forward messages to be used at the start of inference.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.InitialiseBackwardTo">
      <summary>
            When attached to a Variable, specifies the initial backward messages to be used at the start of inference.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.InitialiseBackward">
      <summary>
            When attached to a Variable, indicates that the backward messages should be treated as initialised by the scheduler, even though they will be initialised to uniform
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Algorithm">
      <summary>
            Attribute which associates a specified algorithm to a targetted variable or statement.
            This is used for hybrid inference where different algorithms are used for different parts
            of the model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Algorithm.algorithm">
      <summary>
            The algorithm
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Algorithm.#ctor(MicrosoftResearch.Infer.IAlgorithm)">
      <summary>
            Creates a new Algorithm attribute which assigns the given algorithm to the target
            </summary>
      <param name="algorithm">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Algorithm.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.FactorAlgorithm">
      <summary>
            Attribute which associates a specified algorithm to all factors that define a variable.
            This is used for hybrid inference where different algorithms are used for different parts
            of the model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.FactorAlgorithm.algorithm">
      <summary>
            The algorithm
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.FactorAlgorithm.#ctor(MicrosoftResearch.Infer.IAlgorithm)">
      <summary>
            Creates a new Algorithm attribute which assigns the given algorithm to the target's factor
            </summary>
      <param name="algorithm">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.FactorAlgorithm.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.GroupMember">
      <summary>
            Group member attribute - attached to MSL variables based on
            inference engine groups
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.GroupMember.Group">
      <summary>
            The associated variable group
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.GroupMember.IsRoot">
      <summary>
            This variable is a root in this group
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.GroupMember.#ctor(MicrosoftResearch.Infer.VariableGroup,System.Boolean)">
      <summary>
            Creates a group member attribute on a variable
            </summary>
      <param name="vg">The variable group</param>
      <param name="isRoot">Whether this variable is the root of the group</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.GroupMember.ToString">
      <summary>
            Returns a string representation of this group member attribute.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.DoNotInfer">
      <summary>
            When attached to a variable, indicates that the variable will not be inferred, producing more efficient generated code.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Output">
      <summary>
            Attribute which indicates that the output message will be recovered from
            the targetted variable. The output message of a variable is its marginal divided by
            its inbox message, and is used in situations where variables are shared
            between different models
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.DerivedVariable">
      <summary>
            For expert use only!  When sharing a variable between multiple models (e.g. using SharedVariable)
            you can add this attribute to have the variable be treated as a derived variable, even if it 
            is not derived in the submodel where it appears.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.TraceMessages">
      <summary>
            Attribute to generate trace outputs for the messages associated with the target variable
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.TraceMessages.Containing">
      <summary>
            If non-null, only trace messages where the string representing the message expression
            contains this string.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ListenToMessages">
      <summary>
            Attribute to cause message update events to be generated for the messages associated with the target variable
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ListenToMessages.Containing">
      <summary>
            If non-null, only trace messages where the string representing the message expression
            contains this string.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ExampleAttribute">
      <summary>
            Attribute used to label classes containing code examples. The examples browser
            will use this information to organise the code examples
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.ExampleAttribute.#ctor(System.String,System.String)">
      <summary>
            Creates a new ExamplesViewer attribute with a specified category and description
            </summary>
      <param name="category">Category of the example</param>
      <param name="description">Description of the example</param>
    </member>
    <member name="P:MicrosoftResearch.Infer.ExampleAttribute.Category">
      <summary>
            Category of the example
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ExampleAttribute.Description">
      <summary>
            Description of the example
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ExampleAttribute.Prefix">
      <summary>
            Prefix
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.GivePriorityTo">
      <summary>
            Attached to Variable or MethodInvoke to give priority in the operator search path
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.DivideMessages">
      <summary>
            Attached to Variable objects to specify if outgoing messages should be computed by division
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Partitioned">
      <summary>
            Attached to Ranges to specify that only one element should be in memory at a time (per thread)
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.PointEstimate">
      <summary>
            Attached to Variable objects to indicate that their uncertainty should be ignored during inference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler">
      <summary>
            A model compiler takes a model specified in MSL and compiles it into the code
            required to perform inference in that model, as specified by the inference engine settings
            and model attributes.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.CompileEventArgs">
      <summary>
            Data passed to event handlers for the Compiling and Compiled events.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`1">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`2">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`3">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`4">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`5">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`6">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`7">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`8">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`9">
      <exclude />
    </member>
    <member name="T:MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod`10">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.resolveEventHandler(System.Object,System.ResolveEventArgs)">
      <summary>
            Assembly resolve event handler. Ref: James Margetson's Excel Add-in bug.
            AddIn cannot automatically resolve generated assembly.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.#ctor">
      <summary>
            Creates a model compiler
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.GivePriorityTo(System.Object)">
      <summary>
            Resolve ambiguous matches for message operators in favor of the given container.  Accumulates with all previous calls.
            </summary>
      <param name="container">A Type, namespace string, Module, or Assembly.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.RemovePriority(System.Object)">
      <summary>
            Remove any priority of container given by previous calls to GivePriorityTo.
            </summary>
      <param name="container">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``1(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0},``0)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``1(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``2(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1},``0,``1)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``2(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``3(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2},``0,``1,``2)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``3(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``4(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3},``0,``1,``2,``3)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``4(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``5(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4},``0,``1,``2,``3,``4)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``5(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``6(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,``5)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``6(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``7(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``7(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``8(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6,``7)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``8(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``9(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``9(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``10(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.Compile``10(MicrosoftResearch.Infer.ModelCompiler.ModelDefinitionMethod{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.CompileWithParamArray(System.Reflection.MethodBase,System.Object[])">
      <summary>
            Compiles the model defined in MSL by the specified method.  The model parameters are set
            to the specified values.  This method should only be used when the method has more than 10 parameters,
            otherwise one of the strongly typed <code>Compile</code> methods should be used.
            </summary>
      <param name="method">
      </param>
      <param name="varValues">
      </param>
      <returns>An instance of the compiled model, with all parameters set.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.CompileWithoutParams(System.Reflection.MethodBase)">
      <summary>
            Compiles the model defined in MSL by the specified method.  The model parameters are not
            set - they must be set before the model is executed.
            </summary>
      <param name="method">
      </param>
      <returns>An instance of the compiled model, without any parameters set.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.GetTransformedDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration,System.Reflection.MethodBase,MicrosoftResearch.Transforms.AttributeRegistry{System.Object,MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Get the abstract syntax tree for the generated code.
            </summary>
      <param name="itd">
      </param>
      <param name="method">
      </param>
      <param name="inputAttributes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.ConstructTransformChain(System.Reflection.MethodBase)">
      <summary>
            Construct the transform chain for the given method
            </summary>
      <param name="method">The method</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.ModelCompiler.SetTo(MicrosoftResearch.Infer.ModelCompiler)">
      <summary>
            Configures this model compiler by copying settings from the supplied model compiler.
            </summary>
      <param name="compiler">The compiler to copy settings from</param>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.DeclarationProvider">
      <summary>
            Declaration provider for model defined in MSL
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.WriteSourceFiles">
      <summary>
            Controls if source code files are written to disk.  If true, source code files will be 
            written out to the GeneratedSourceFolder.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.UseExistingSourceFiles">
      <summary>
            If true, existing source code files will be used instead of re-generated.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.IncludeDebugInformation">
      <summary>
            Controls if debug information is included in generated DLLs.  If true, debug information will 
            be included which allows stepping through the generated code in a debugger.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.ShowProgress">
      <summary>
            If true, prints compilation progress information to the console during model compilation.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.ShowWarnings">
      <summary>
            If true, compiler warnings are printed to the console.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.CatchExceptions">
      <summary>
            If true, compiler exceptions are caught and displayed in the transform browser, rather than propagating to the caller.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.TreatWarningsAsErrors">
      <summary>
            If true, compiler warnings are treated as errors.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.AllowDerivedParents">
      <summary>
            If true, allow factor arguments marked 'stochastic' to be derived.  This can cause inference to diverge on some models.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.Algorithm">
      <summary>
            The inference algorithm to use.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.GenerateInMemory">
      <summary>
            Controls if inference assembly is generated in memory or on disk.
            </summary>
      <remarks>This is set to true by default. Set to false if you want to debug into the generated code</remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.GeneratedSourceFolder">
      <summary>
            The path (absolute or relative) where source code files will be generated.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.UseParallelForLoops">
      <summary>
            If true, use Parallel.For() instead of top-level for loops in the generated code.  
            Requires the Microsoft Parallel Extensions to be installed.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.UseSerialSchedules">
      <summary>
            Find serial schedules for graphs with offset indexing.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.AllowSerialInitialisers">
      <summary>
            Allow initialisation to use serial schedules.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.UseSpecialFirstIteration">
      <summary>
            Experimental feature: generate a schedule using InitializeTo for the first iteration and another schedule ignoring InitializeTo for the remaining iterations.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.IgnoreEqualObservedValuesForValueTypes">
      <summary>
            Let's you control what happens when you set an observed value which is equal
            to the old observed value (for value types). If this property is true, setting an equal
            value will be ignored.  If false, setting an equal value may cause inference to be re-run.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.IgnoreEqualObservedValuesForReferenceTypes">
      <summary>
            Let's you control what happens when you set an observed value which is equal
            to the old observed value (for reference types). If this property is true, setting an equal
            value will be ignored.  If false, setting an equal value may cause inference to be re-run.
            </summary>
      <remarks>
            The default value of 'false' is safe, but may be inefficient if you often set observed values 
            to be the same value.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.AddComments">
      <summary>
            If true, comments will be added to the generated code.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.OptimiseInferenceCode">
      <summary>
            Optimises generated code by removing redundant messages or operations.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.ReturnCopies">
      <summary>
            If true, code will be generated to return copies of the internal marginal distributions.  
            If this is not done, the returned marginals are volatile and may be modified in place when inference runs again.  
            Set to false to save memory/time.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.UnrollLoops">
      <summary>
            If true, all loops with constant bounds will be unrolled.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.FreeMemory">
      <summary>
            Trade memory for time.
            If true, memory usage is reduced for increase in time.  Temporary storage will be freed when inference completes, requiring re-allocation every time inference is run.
            If false, memory usage is increased for reduction in time.  Temporary storage will be kept and re-used for later inference runs.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.RequiredQuality">
      <summary>
            Sets the component quality band which is required for running inference. By default
            this is QualityBand.Experimental.
            </summary>
      <remarks>
            If the quality of any component is below this quality band, then an
            Infer.NET model compiler error is generated. This can be switched off
            by setting it to QualityBand.Unknown
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.RecommendedQuality">
      <summary>
            Sets the quality band at which is recommended for running inference. By default
            this is QualityBand.Preview.
            </summary>
      <remarks>
            If the quality of any component is below this quality band, then an
            Infer.NET model compiler warning is generated. This can be switched off
            by setting it to QualityBand.Unknown
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.PriorityList">
      <summary>
            A list of message operator containers, highest priority first.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.BrowserMode">
      <summary>
            Controls when the model compiler browser is shown
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.ModelCompiler.ShowSchedule">
      <summary>
            If true, displays the schedule for the model, after the scheduler has run.
            </summary>
    </member>
    <member name="E:MicrosoftResearch.Infer.ModelCompiler.Compiling">
      <summary>
            Event raised before a model is compiled.
            </summary>
    </member>
    <member name="E:MicrosoftResearch.Infer.ModelCompiler.Compiled">
      <summary>
            Event raised after a model is compiled or fails to compile.
            </summary>
    </member>
    <member name="E:MicrosoftResearch.Infer.ModelCompiler.ParametersChanged">
      <summary>
            Event raised when a compilation parameter is changed.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilationFailedException">
      <summary>
            Exception thrown when Infer.NET model compilation encounters errors.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilationFailedException.Results">
      <summary>
            The errors and warnings thrown by the failed stage of compilation.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.IStatementBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Get a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.EmptyBlockException">
      <summary>
            Thrown when an empty block is closed.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.EmptyBlockException.#ctor(System.String)">
      <summary>
            Create an EmptyBlockException with the given message.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.StatementBlock">
      <summary>
            Abstract base class for statement blocks
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.StatementBlock.openBlocks">
      <summary>
            A list of currently open blocks.  This is a thread-specific static variable and
            will have a different value for each thread.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.StatementBlock.OpenBlock">
      <summary>
            Adds this block to a thread-specific list of open blocks.  
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.StatementBlock.CloseBlock">
      <summary>
            Removes this block from a thread-specific list of open blocks.  
            If this block is not the final element of the list, gives an error.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.StatementBlock.CloseAllBlocks">
      <summary>
            Close blocks in order to recover from exceptions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.StatementBlock.Dispose">
      <summary>
            Causes CloseBlock() to be called, so that this class can be used as the argument of a using() statement.
            </summary>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.StatementBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Get a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.HasRange">
      <summary>
            Indicates that a StatementBlock has an associated range that it loops over.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.HasRange.Range">
      <summary>
            The Range being looped over.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ForEachBlock">
      <summary>
            'For each' block
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ForEachBlock.range">
      <summary>
            Range associated with the 'for each' block
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ForEachBlock.#ctor(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Constructs 'for each' block from a range
            </summary>
      <param name="range">The range</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ForEachBlock.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ForEachBlock.OpenBlock">
      <summary>
            Adds this block to a thread-specific list of open blocks.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ForEachBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Get a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ForEachBlock.Range">
      <summary>
            Range associated with the 'for each' block
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ForEachBlock.Index">
      <summary>
            The index variable associated with the range
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.RepeatBlock">
      <summary>
            'Repeat' block
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.RepeatBlock.#ctor(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Constructs 'for each' block from a range
            </summary>
      <param name="count">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.RepeatBlock.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.RepeatBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Get a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.RepeatBlock.Count">
      <summary>
            The variable that indicates the (possibly fractional) number of repeats. 
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ConditionBlock">
      <summary>
            Base class for condition blocks
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ConditionBlock.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ConditionBlock.OpenBlock">
      <summary>
            Adds this block to a thread-specific list of open blocks.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ConditionBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Gets a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ConditionBlock.ConditionVariableUntyped">
      <summary>
            The condition variable for this condition block.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ConditionBlock`1">
      <summary>
            Represents a conditional block in a model definition.  Anything defined inside 
            the block is placed inside a gate, whose condition is the condition of the block.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ConditionBlock`1.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ConditionBlock`1.Equals(System.Object)">
      <summary>
            Equals override
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ConditionBlock`1.GetHashCode">
      <summary>
            Hash code override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ConditionBlock`1.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ConditionBlock`1.ConditionVariable">
      <summary>
            The random variable which controls when this IfBlock is active.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ConditionBlock`1.ConditionValue">
      <summary>
            The value of the condition variable which switches on this IfBlock.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ConditionBlock`1.ConditionVariableUntyped">
      <summary>
            The condition variable for this condition block.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IfBlock">
      <summary>
            An If block is a condition block with a binary condition.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.IfBlock.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.CaseBlock">
      <summary>
            A case block is a condition block with a condition of the form (i==value) for integer i.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SwitchBlock">
      <summary>
            A switch block is a condition block which acts like multiple case blocks ranging over the values
            of the integer condition variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SwitchBlock.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SwitchBlock.OpenBlock">
      <summary>
            Adds this block to a thread-specific list of open blocks.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SwitchBlock.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Gets a statement for the entire block, and a pointer to its body.
            </summary>
      <param name="innerBlock">On return, a pointer to the body of the block.</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.SwitchBlock.Range">
      <summary>
            Get switch block's range
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IModelExpression">
      <summary>
            Interface to a modelling expression, such as a constant, variable or parameter.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.IModelExpression.GetExpression">
      <summary>
            Get the code model expression
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IModelExpression.Name">
      <summary>
            Expression name
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IModelExpression`1">
      <summary>
            Generic inferface to a modelling expression of type T.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.HasObservedValue">
      <summary>
            Interface for a variable to have an observed value
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.HasObservedValue.IsObserved">
      <summary>
            Returns true if the variable is observed.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.HasObservedValue.ObservedValue">
      <summary>
            Observed value property
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariable">
      <summary>
            A marker interface for variables.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.CanGetContainers">
      <summary>
            Interface for getting list of containers
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.CanGetContainers.GetContainers``1">
      <summary>
            Get list of containers for a variable
            </summary>
      <typeparam name="T">Type of variable</typeparam>
      <returns>
      </returns>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.MethodInvoke.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a method invoke.  This method
            returns the method invoke object, so that is can be used in an inline expression.
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>This object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.GetAttributes``1">
      <summary>
            Get all attributes of this variable having type AttributeType.
            </summary>
      <typeparam name="AttributeType">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.CanBeInlined">
      <summary>
            True if the expression contains a loop index and all other variable references are givens.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.GetLocalRangeSet">
      <summary>
            Get the set of ranges used as indices in the arguments of the MethodInvoke, that are not included in its ForEach containers.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.GetLocalRangeList">
      <summary>
            Get the set of ranges used as indices in the arguments of the MethodInvoke, that are not included in its ForEach containers.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.GetRangeBrackets(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Models.IModelExpression})">
      <summary>
            Get a dictionary mapping all array indexer expressions (including sub-expressions) to a list of their Range indexes, in order.
            </summary>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.GetRangeBrackets(MicrosoftResearch.Infer.Models.IModelExpression,System.Collections.Generic.IDictionary{MicrosoftResearch.Infer.Models.IModelExpression,System.Collections.Generic.List{System.Collections.Generic.List{MicrosoftResearch.Infer.Models.Range}}})">
      <summary>
            If arg is an array indexer expression, get a list of all Range indexes, in order.  Indexes that are not Ranges instead get their Ranges added to dict.
            </summary>
      <param name="arg">
      </param>
      <param name="dict">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.MethodInvoke.IsIndexedByAll(MicrosoftResearch.Infer.Models.IModelExpression,System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Models.Range})">
      <summary>
            True if arg is indexed by at least the given ranges.
            </summary>
      <param name="arg">
      </param>
      <param name="ranges">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.MethodInvoke.Name">
      <summary>
            The name of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.MethodInvoke.Arguments">
      <summary>
            The method arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.MethodInvoke.ReturnValue">
      <summary>
            The expression the return value of the method will be assigned to.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ModelBuilder">
      <summary>
            Builds an MSL model from an in-memory graph of model expression objects.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ModelBuilder.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ModelBuilder.negatedConditionVariables">
      <summary>
            The set of condition variables used in 'IfNot' blocks.  Filled in during search.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.ModelBuilder.constants">
      <summary>
            Mapping from constant values to their declarations in the generated code.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.Build(MicrosoftResearch.Infer.InferenceEngine,System.Boolean,System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Models.IVariable})">
      <summary>
            Builds the model necessary to infer marginals for the supplied variables and algorithm.
            </summary>
      <param name="engine">The inference algorithm being used</param>
      <param name="inferOnlySpecifiedVars">If true, inference will be restricted to only the variables given.</param>
      <param name="vars">Variables to infer.</param>
      <returns>
      </returns>
      <remarks>
            Algorithm: starting from the variables to infer, we search through the graph to build up a "searched set".
            Each Variable and MethodInvoke in this set has an associated timestamp.
            We sort by timestamp, and then generate code.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SetModelName(System.String)">
      <summary>
            Set modelType.Name to a valid identifier.
            </summary>
      <param name="name">The desired name.  Need not be a valid identifier.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.GetGeneratedSyntax(MicrosoftResearch.Infer.InferenceEngine)">
      <summary>
            Get the abstract syntax tree for the generated code.
            </summary>
      <param name="engine">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildMethodInvoke(MicrosoftResearch.Infer.Models.MethodInvoke,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Add a statement of the form x = f(...) to the MSL.
            </summary>
      <param name="method">Stores the method to call, the argument variables, and target variable.</param>
      <param name="lhs">Stores the name and type of the target variable, if it is not already declared.  Otherwise null.</param>
      <remarks>
            If any variable in the statement is an item variable, then we surround the statement with a loop over its range.
            Since there may be multiple item variables, and each item may depend on multiple ranges, we may end up with multiple loops.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SearchExpression``1(MicrosoftResearch.Infer.Models.IModelExpression{``0})">
      <summary>
            Search a variable expression
            </summary>
      <typeparam name="T">Domain type of the variable expression</typeparam>
      <param name="var">The variable expression</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SearchVariable``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Define a variable in the MSL.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="var">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildExpression``1(MicrosoftResearch.Infer.Models.IModelExpression{``0})">
      <summary>
            Build a variable expression
            </summary>
      <typeparam name="T">Domain type of the variable expression</typeparam>
      <param name="expr">The variable expression</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildVariable``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Define a variable in the MSL.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="variable">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildConstant``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Define a constant in the MSL.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="constant">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SearchItem(MicrosoftResearch.Infer.Models.Variable)">
      <summary>
            Search all variables referred to by an item variable.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SearchRange(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Search all variables referred to by a Range.
            </summary>
      <param name="r">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.SearchContainers(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Models.IStatementBlock})">
      <summary>
            Build condition variable expressions associated with each condition block
            Build range variable expressions associated with each range
            </summary>
      <param name="containers">Containers - condition blocks or foreach block</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildRandVar``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Add the definition of a random variable to the MSL, inside of the necessary containers.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="variable">
      </param>
      <remarks>
            A scalar variable is declared and defined in one line such as: <c>int x = factor(...);</c>.
            An array variable is first declared with an initializer such as: <c>int[] array = new int[4];</c>.
            Then it is defined either with a bulk factor such as: <c>array = factor(...);</c>,
            or it is defined via its item variable.
            An item variable is defined by 'for' loop whose body is: <c>array[i] = factor(...);</c>.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ModelBuilder.BuildGiven``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Define a given variable in the MSL.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="variable">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.Range">
      <summary>
            A range of values from 0 to N-1. The size N may be an integer expression or constant.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.name">
      <summary>
            Name
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.nameInGeneratedCode">
      <summary>
            Name used in generated code
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.attributes">
      <summary>
            The attributes associated with this Range.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.Count">
      <summary>
            Global counter used to generate variable names.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Range.CountLock">
      <summary>
            Lock for counter
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a range.  This method
            returns the range object, so that is can be used in an inline expression.
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The range object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.AddAttribute(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Adds an attribute to this range.  Attributes can be used
            to modify how inference is performed on the range.
            </summary>
      <param name="attr">The attribute to add</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.GetAttributes``1">
      <summary>
            Get all attributes of this range having type AttributeType.
            </summary>
      <typeparam name="AttributeType">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.#ctor(System.Int32)">
      <summary>
            Constructs a range containing values from 0 to N-1.
            </summary>
      <param name="N">The number of elements in the range, including zero.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.#ctor(MicrosoftResearch.Infer.Models.IModelExpression{System.Int32})">
      <summary>
            Constructs a range whose size is given by an integer-value expression.
            </summary>
      <param name="size">An expression giving the size of the range</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.#ctor(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Copy constructor
            </summary>
      <param name="parent">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.Clone">
      <summary>
            Create a copy of a range.  The copy can be used to index the same arrays as the original range.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.Named(System.String)">
      <summary>
            Inline method to name a range
            </summary>
      <param name="name">Name for the range</param>
      <returns>this</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.GetExpression">
      <summary>
            Gets the expression for the index variable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.Replace(System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range},System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IModelExpression})">
      <summary>
            Construct a new Range in which all subranges and size expressions have been replaced according to given Dictionaries.
            </summary>
      <param name="rangeReplacements">
      </param>
      <param name="expressionReplacements">Modified on exit to contain newly created ranges</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.IsCompatibleWith(MicrosoftResearch.Infer.Models.IModelExpression)">
      <summary>
            True if index is compatible with this range
            </summary>
      <param name="index">Index expression</param>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.CheckCompatible(MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IVariableArray)">
      <summary>
            Throws an exception if an index expression is not valid for subscripting an array.
            </summary>
      <param name="index">Index expression</param>
      <param name="array">Array that the expression is indexing</param>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.CheckCompatible(System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Models.IModelExpression},System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Models.IModelExpression})">
      <summary>
            Throws an exception if two index expression collections do not contain the same elements (regardless of order).
            </summary>
      <param name="set1">First set of index expressions</param>
      <param name="set2">Second set of index expressions</param>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Range.GetStatement(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}@)">
      <summary>
            Get 'for statement' for iterating over the range.
            </summary>
      <param name="innerBlock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Range.Size">
      <summary>
            Model expression for size of the range
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Range.Parent">
      <summary>
            Range from which this range was cloned, or null if none.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Range.Name">
      <summary>
            Name of the range
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Range.NameInGeneratedCode">
      <summary>
            Name used in generated code
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Range.SizeAsInt">
      <summary>
            Returns the size of the range as an integer.  This will fail if the size is not a constant,
            for example, if it is a Given value.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ISharedVariable">
      <summary>
            Interface for shared variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariable.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Sets the shared variable's inbox for a given model and batch number
            </summary>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariable.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infers the shared variable's output message for a given model and batch number
            </summary>
      <param name="engine">Inference engine</param>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariable.InferOutput(MicrosoftResearch.Infer.IGeneratedAlgorithm,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infers the shared variable's output message for a given model and batch number
            </summary>
      <param name="ca">Compiled algorithm</param>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariable.GetEvidenceCorrection">
      <summary>
            Gets the evidence correction for this shared variable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.ISharedVariable.IsEvidenceVariable">
      <summary>
            Whether this shared variable is an evidence variable
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariable`1">
      <summary>
            Abstract base class for shared variables. Shared variables allow a model to be split
            into submodels in which variables are shared. Each submodel can have many copies. 
            </summary>
      <typeparam name="DomainType">Domian type of the variable</typeparam>
      <remarks>A typical use of this is for large data sets where the likelihood parts of the
            model cannot all fit in memory. The solution is to divide the data into chunks (or 'batches'), and specify
            a single submodel which includes the likelihood factors and variables for one chunk, along
            with the shared parameters; the number of copies of the submodel is set to the number
            of chunks. In a related pattern, there are one or more additional submodels for defining
            the parameter variables.</remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`1.Name">
      <summary>
            Name of the shared variable.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Random``1(``0,System.Boolean)">
      <summary>
            Creates a shared random variable with the specified prior distribution.
            </summary>
      <typeparam name="DistributionType">Distribution type</typeparam>
      <param name="prior">Prior</param>
      <param name="divideMessages">Use division (the faster default) for calculating messages to batches</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Random``1(MicrosoftResearch.Infer.Models.Range,``0,System.Boolean)">
      <summary>
            Creates a 1D array of shared random variables of size given by the specified range.
            </summary>
      <typeparam name="DistributionArrayType">The type of the supplied prio.r</typeparam>
      <param name="range">Range.</param>
      <param name="prior">A distribution over an array, to use as the prior.</param>
      <param name="divideMessages">Use division (the faster default) for calculating messages to batches</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Random``1(MicrosoftResearch.Infer.Models.VariableArray{`0},MicrosoftResearch.Infer.Models.Range,``0,System.Boolean)">
      <summary>
            Creates a 1D jagged array of shared random variables.
            </summary>
      <typeparam name="DistributionArrayType">
      </typeparam>
      <param name="itemPrototype">A fresh variable object representing an array element.</param>
      <param name="range">Outer range.</param>
      <param name="prior">Prior for the array.</param>
      <param name="divideMessages">Use division (the faster default) for calculating messages to batches</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Random``2(``0,MicrosoftResearch.Infer.Models.Range,``1,System.Boolean)">
      <summary>
            Creates a generic jagged array of shared random variables.
            </summary>
      <typeparam name="ItemType">Item type</typeparam>
      <typeparam name="DistributionArrayType">Distribution array type</typeparam>
      <param name="itemPrototype">A fresh variable object representing an array element.</param>
      <param name="range">Outer range</param>
      <param name="prior">Prior for the array.</param>
      <param name="divideMessages">Use division (the faster default) for calculating messages to batches</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Named(System.String)">
      <summary>
            Inline method for naming a shared variable.
            </summary>
      <param name="name">The name</param>
      <returns>this</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.ToString">
      <summary>
            ToString override.
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.Marginal``1">
      <summary>
            Get the marginal distribution for the shared variable, converted to type T.
            </summary>
      <typeparam name="T">The desired type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)">
      <summary>
            Gets a copy of the variable for the specified model.
            </summary>
      <param name="model">Model id.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Sets the definition of the shared variable.
            </summary>
      <param name="model">Model id.</param>
      <param name="definition">Defining variable.</param>
      <returns>
      </returns>
      <remarks>Use this method if the model is defining the shared variable rather than
            using one defined in this or another model.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Sets the shared variable's inbox for a given model and batch.
            </summary>
      <param name="modelNumber">
      </param>
      <param name="batchNumber">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the shared variable's output message for the given model and batch number.
            </summary>
      <param name="engine">The inference engine.</param>
      <param name="modelNumber">The model id.</param>
      <param name="batchNumber">The batch number.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.InferOutput(MicrosoftResearch.Infer.IGeneratedAlgorithm,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the shared variable's output message for the given model and batch number.
            </summary>
      <param name="ca">The compiled algorithm.</param>
      <param name="modelNumber">The model id.</param>
      <param name="batchNumber">The batch number.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`1.GetEvidenceCorrection">
      <summary>
            Gets the evidence correction for this shared variable.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.SharedVariable`1.IsEvidenceVariable">
      <summary>
            Marks this shared variable as one that calculates evidence
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariable`2">
      <summary>
            A helper class that represents a variable which is shared between multiple models.
            For example, where a very large model has been divided into sections corresponding to
            batches of data, an instance of this class can be used to help learn each parameter
            shared between the batches.
            </summary>
      <remarks>
        <para>
            Shared variables are used as follows. First the shared variable is created with a prior distribution.
            Then a copy is created for each model using the <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.GetCopyFor(MicrosoftResearch.Infer.Models.Model)" /> method.
            Each model has a BatchCount which is the number of data batches you want to process with that model.
            Before performing inference in each model and batch, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should be called for each shared variable.
            After all shared variables have their inputs set, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should then be called for each model and batch.
            These two steps are done automatically by <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" />.
            For inference to converge, you must loop multiple times through all the models, calling <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" /> or SetInput/InferOutput each time.
            At any point the current marginal of the shared variable can be retrieved using <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal" />.
            </para>
        <para>In some situations, shared variables cannot be created directly from a prior distribution, for
            example in a hierarchical model. In these situations, create the shared variable with a uniform
            prior, and use <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.Variable{`0})" /> to define the variable. 
            </para>
        <para>A shared variable which calculates evidence must be treated as a special case; such variables can be marked
            using <see cref="P:MicrosoftResearch.Infer.Models.SharedVariable`1.IsEvidenceVariable" />, and the evidence is recovered using <see cref="M:MicrosoftResearch.Infer.Models.Model.GetEvidenceForAll(MicrosoftResearch.Infer.Models.Model[])" /></para>
      </remarks>
      <typeparam name="DomainType">The domain type</typeparam>
      <typeparam name="DistributionType">The marginal distribution type</typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.Prior">
      <summary>
            Prior
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.CurrentMarginal">
      <summary>
            Marginal
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.Outputs">
      <summary>
            Dictionary of output messages keyed by model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.variables">
      <summary>
            Dictionary of variable copies indexed by model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.priors">
      <summary>
            Dictionary of priors indexed by model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.DefiningModel">
      <summary>
            Defining model - only one single-batch model can define a shared variable, and this is optional.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.algorithm">
      <summary>
            The algorithm
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.Count">
      <summary>
            Global counter used to generate variable names.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.CountLock">
      <summary>
            A lock for the global counter
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariable`2.DivideMessages">
      <summary>
            If true (the default), uses division to calculate the messages to batches.
            This is more efficient, but may introduce round-off errors.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Named(System.String)">
      <summary>
            Constructs a new shared variable with a given domain type and distribution type
            </summary>
      <param name="name">Name of the shared variable</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.GetCopyFor(MicrosoftResearch.Infer.Models.Model)">
      <summary>
            Gets a copy of this shared variable for the specified model
            </summary>
      <param name="model">The model identifier</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Sets the definition of the shared variable
            </summary>
      <param name="model">Model id</param>
      <param name="definition">Defining variable</param>
      <returns>
      </returns>
      <remarks>Use this method if the model is defining the shared variable rather than
            using one defined in this or another model.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Sets the shared variable's inbox given model and batch number
            </summary>
      <param name="model">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.MessageToBatch(MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Returns the shared variable's inbox message given model and batch number
            </summary>
      <param name="model">Model id</param>
      <param name="batchNumber">Batch number</param>
      <returns>The inbox message</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.MessageToBatch(MicrosoftResearch.Infer.Models.Model,System.Int32,`1)">
      <summary>
            Returns the shared variable's inbox message given model and batch number
            </summary>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
      <param name="result">Where to put the result</param>
      <returns>The inbox message</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal``1">
      <summary>
            Get the marginal distribution, converted to type T
            </summary>
      <typeparam name="T">The desired type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal">
      <summary>
            Returns the marginal distribution
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.GetEvidenceCorrection">
      <summary>
            Gets the evidence correction for this shared variable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the output message given a model id and a batch id
            </summary>
      <param name="engine">Inference engine</param>
      <param name="modelNumber">Model number</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.IGeneratedAlgorithm,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the output message given a model id and a batch id
            </summary>
      <param name="ca">Compiled algorithm</param>
      <param name="modelNumber">Model number</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableSet">
      <summary>
            A Set of SharedVariables that allows SetInput/InferOutput to be called on all of them at once.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.#ctor">
      <summary>
            Constructs a set of shared variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Set inboxes, for the given model and batch number, for all
            shared variables in this set
            </summary>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the output messages, for the given model and batch number, for all
            shared variables in this set
            </summary>
      <param name="engine">Inference engine</param>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.InferOutput(MicrosoftResearch.Infer.IGeneratedAlgorithm,MicrosoftResearch.Infer.Models.Model,System.Int32)">
      <summary>
            Infer the output messages, for the given model and batch number, for all
            shared variables in this set
            </summary>
      <param name="ca">Compiled algorithm</param>
      <param name="modelNumber">Model id</param>
      <param name="batchNumber">Batch number</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.GetEvidence">
      <summary>
            Gets the evidence for this set of shared variable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableSet.GetEvidenceCorrection">
      <summary>
            Not supported for <see cref="T:MicrosoftResearch.Infer.Models.SharedVariableSet" /></summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.SharedVariableSet.IsEvidenceVariable">
      <summary>
            Not supported for <see cref="T:MicrosoftResearch.Infer.Models.SharedVariableSet" /></summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.Model">
      <summary>
            A model identifier used to manage SharedVariables.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Model.SharedVariables">
      <summary>
            The set of SharedVariables registered with this model.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Model.BatchCount">
      <summary>
            The number of data batches that will be processed with this model.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Model.Name">
      <summary>
            Name of the model
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Model.Count">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Model.CountLock">
      <summary>
            Lock for Count
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.#ctor(System.Int32)">
      <summary>
            Create a new model identifier to which SharedVariables can be registered.
            </summary>
      <param name="batchCount">The number of data batches that will be processed with this model.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.Named(System.String)">
      <summary>
            Inline method for naming a shared variable model
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)">
      <summary>
            Update all the SharedVariables registered with this model.
            </summary>
      <param name="engine">
      </param>
      <param name="batchNumber">A number from 0 to BatchCount-1</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.IGeneratedAlgorithm,System.Int32)">
      <summary>
            Update all the SharedVariables registered with this model.
            </summary>
      <param name="engine">
      </param>
      <param name="batchNumber">A number from 0 to BatchCount-1</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.GetEvidenceForAll(MicrosoftResearch.Infer.Models.Model[])">
      <summary>
            Gets evidence for all the specified models
            </summary>
      <param name="models">An array of models</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Model.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.ISharedVariableArray`2">
      <summary>
            Interface for jagged 1D shared variable arrays
            </summary>
      <typeparam name="ItemType">Variable type of an item</typeparam>
      <typeparam name="ArrayType">Domain type of the array</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariableArray`2.Marginal``1">
      <summary>
            Get the marginal, converted to type T
            </summary>
      <typeparam name="T">The desired type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariableArray`2.GetCopyFor(MicrosoftResearch.Infer.Models.Model)">
      <summary>
            Get a copy of the variable array for the specified model
            </summary>
      <param name="model">The model id</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariableArray`2.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray{`0,`1})">
      <summary>
            Sets the definition of the shared variable
            </summary>
      <param name="model">Model id</param>
      <param name="definition">Defining variable</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.ISharedVariableArray`2.Named(System.String)">
      <summary>
            Inline method to name shared variable arrays
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableArray`1">
      <summary>
            Interface for flat 1D shared variable arrays
            </summary>
      <typeparam name="DomainType">Domain type of the variable</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.Marginal``1">
      <summary>
            Get the marginal, converted to type T
            </summary>
      <typeparam name="T">The desired type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)">
      <summary>
            Get a copy of the variable array for the specified model
            </summary>
      <param name="model">The model id</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray{`0})">
      <summary>
            Sets the definition of the shared variable
            </summary>
      <param name="model">The model id</param>
      <param name="definition">Defining variable</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.Named(System.String)">
      <summary>
            Inline method to name shared variable arrays
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableArray`2">
      <summary>
            A helper class that represents a variable array which is shared between multiple models.
            For example, where a very large model has been divided into sections corresponding to
            batches of data, an instance of this class can be used to help learn each parameter
            shared between the batches.
            </summary>
      <remarks>
        <para>
            Shared variable arrays are used as follows. First the shared variable array is created with a prior distribution.
            Then a copy is created for each model using the <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)" /> method.
            Each model has a BatchCount which is the number of data batches you want to process with that model.
            Before performing inference in each model and batch, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should be called for each shared variable.
            After all shared variables have their inputs set, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should then be called for each model and batch.
            These two steps are done automatically by <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" />.
            For inference to converge, you must loop multiple times through all the models, calling <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" /> or SetInput/InferOutput each time.
            At any point the current marginal of the shared variable array can be retrieved using <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal" />.
            </para>
        <para>In some situations, shared variable arrays cannot be created directly from a prior distribution, for
            example in a hierarchical model. In these situations, create the shared variable array with a uniform
            prior, and use <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray{`0})" /> to define the variable. 
            </para>
      </remarks>
      <typeparam name="DomainType">The domain type of an array element</typeparam>
      <typeparam name="DistributionArrayType">The marginal distribution type of the array</typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariableArray`2.range">
      <summary>
            Range for the array of shared variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`2.Named(System.String)">
      <summary>
            Inline method for naming an array of shared variables
            </summary>
      <param name="name">Name</param>
      <returns>this</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableArray`3">
      <summary>
            A helper class that represents a jagged variable array which is shared between multiple models.
            For example, where a very large model has been divided into sections corresponding to
            batches of data, an instance of this class can be used to help learn each parameter
            shared between the batches.
            </summary>
      <remarks>
        <para>
            Shared variable arrays are used as follows. First the shared variable array is created with a prior distribution.
            Then a copy is created for each model using the <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)" /> method.
            Each model has a BatchCount which is the number of data batches you want to process with that model.
            Before performing inference in each model and batch, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should be called for each shared variable.
            After all shared variables have their inputs set, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should then be called for each model and batch.
            These two steps are done automatically by <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" />.
            For inference to converge, you must loop multiple times through all the models, calling <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" /> or SetInput/InferOutput each time.
            At any point the current marginal of the shared variable array can be retrieved using <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal" />.
            </para>
        <para>In some situations, shared variable arrays cannot be created directly from a prior distribution, for
            example in a hierarchical model. In these situations, create the shared variable array with a uniform
            prior, and use <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray{`0})" /> to define the variable. 
            </para>
      </remarks>
      <typeparam name="ItemType">The variable type of an array element</typeparam>
      <typeparam name="ArrayType">The domain type of the array.</typeparam>
      <typeparam name="DistributionArrayType">The marginal distribution type of the array</typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariableArray`3.range">
      <summary>
            Range for the array of shared variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray`3.Named(System.String)">
      <summary>
            Inline method for naming an array of shared variables
            </summary>
      <param name="name">Name</param>
      <returns>this</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1">
      <summary>
            Interface for flat 2D shared variable arrays
            </summary>
      <typeparam name="DomainType">Domain type of the variable</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1.Marginal``1">
      <summary>
            Gets the marginal
            </summary>
      <typeparam name="DistributionType">The returned distribution array type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)">
      <summary>
            Get a copy of the variable array for the specified model
            </summary>
      <param name="model">The model id</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray2D{`0})">
      <summary>
            Sets a copy of the shared variable to a definition
            </summary>
      <param name="model">Model id</param>
      <param name="definition">Defining variable</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1.Named(System.String)">
      <summary>
            Inline method to name shared variable arrays
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.SharedVariableArray2D`2">
      <summary>
            A helper class that represents a variable array which is shared between multiple models.
            For example, where a very large model has been divided into sections corresponding to
            batches of data, an instance of this class can be used to help learn each parameter
            shared between the batches.
            </summary>
      <remarks>
        <para>
            Shared variable arrays are used as follows. First the shared variable array is created with a prior distribution.
            Then a copy is created for each model using the <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray`1.GetCopyFor(MicrosoftResearch.Infer.Models.Model)" /> method.
            Each model has a BatchCount which is the number of data batches you want to process with that model.
            Before performing inference in each model and batch, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.SetInput(MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should be called for each shared variable.
            After all shared variables have their inputs set, <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.InferOutput(MicrosoftResearch.Infer.InferenceEngine,MicrosoftResearch.Infer.Models.Model,System.Int32)" /> should then be called for each model and batch.
            These two steps are done automatically by <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" />.
            For inference to converge, you must loop multiple times through all the models, calling <see cref="M:MicrosoftResearch.Infer.Models.Model.InferShared(MicrosoftResearch.Infer.InferenceEngine,System.Int32)" /> or SetInput/InferOutput each time.
            At any point the current marginal of the shared variable array can be retrieved using <see cref="M:MicrosoftResearch.Infer.Models.SharedVariable`2.Marginal" />.
            </para>
        <para>In some situations, shared variable arrays cannot be created directly from a prior distribution, for
            example in a hierarchical model. In these situations, create the shared variable array with a uniform
            prior, and use <see cref="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`1.SetDefinitionTo(MicrosoftResearch.Infer.Models.Model,MicrosoftResearch.Infer.Models.VariableArray2D{`0})" /> to define the variable. 
            </para>
      </remarks>
      <typeparam name="DomainType">The domain type of an array element</typeparam>
      <typeparam name="DistributionArrayType">The marginal distribution type of the array</typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariableArray2D`2.range0">
      <summary>
            Ranges for the array of shared variables
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.SharedVariableArray2D`2.range1">
      <summary>
            Ranges for the array of shared variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.SharedVariableArray2D`2.Named(System.String)">
      <summary>
            Inline method for naming an array of shared variables
            </summary>
      <param name="name">Name</param>
      <returns>this</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.Variable">
      <summary>
            A variable in a model
            </summary>
      <remarks>
            Variables can be base or derived.  A base Variable is explicitly declared as a variable in MSL.
            A derived Variable is simply an expression built from variables.
            For example, the expression <c>a[i]</c> is a derived Variable called an item variable.
            Every method that manipulates Variable objects must be aware of this distinction.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.AutoNaming">
      <summary>
            Automatically generate names for variables based on their definition.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.definition">
      <summary>
            Stores the parent factor for the variable, and the factor arguments.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.conditionalDefinitions">
      <summary>
            Stores definitions of this variable which are given in condition blocks.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.isObserved">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.initialiseTo">
      <summary>
            An expression for initialising the forward messages for this variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.initialiseBackwardTo">
      <summary>
            An expression for initialising the backward messages for this variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.childFactors">
      <summary>
            Factors that this variable is an argument of.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.indices">
      <summary>
            The indices this variable is indexed by, if any.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.attributes">
      <summary>
            The attributes associated with this variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.array">
      <summary>
            The array this variable is an element of, if it is an array element.
            </summary>
      <remarks>null if the variable is not an array element.</remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable.operatorFactorRegistry">
      <summary>
            Operator to factor registry
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ToString">
      <summary>
            Overridden ToString method
            </summary>
      <returns>
      </returns>
      <exclude />
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IsDefinedInContext(System.Collections.Generic.List{MicrosoftResearch.Infer.Models.ConditionBlock})">
      <summary>
            True if the variable is defined in the given condition context.
            </summary>
      <remarks>
            Suppose we have x.SetTo(def) inside [c==0][d==0]
            Then x.IsDefinedInContext is true inside [c==0][d==0], [c==0][d==0][e==0], [c==0], and nothing.
            x.IsDefinedInContext is false inside [c==0][d==1] and [c==1].
            In other words, IsDefinedInContext is true when the context is a prefix of the definition context,
            or when the definition context is a prefix of the context.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IsPrefixOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            True if prefix is a prefix of list.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="prefix">
      </param>
      <param name="list">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ShorterIsPrefixOfLonger``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            True if the shorter list is a prefix of the longer list.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.HasAnyItemDefined">
      <summary>
            True if the variable (or any item of it) is defined in the given context.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.HasAnyItemDefined(System.Collections.Generic.IList{MicrosoftResearch.Infer.Models.ConditionBlock})">
      <summary>
            True if the variable (or any item of it) is defined in the given context.
            </summary>
      <param name="currentConditions">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetDefinitionsMadeWithin(System.Collections.Generic.List{MicrosoftResearch.Infer.Models.ConditionBlock})">
      <summary>
            Enumerates all definitions made within the given context.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
      <remarks>
            If context is [c==0][d==0] then a definition made inside [c==0][d==0] or [c==0][d==0][e==0] will be returned
            but a definition made inside [c==0] or [c==0][d==1] will not be returned.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.SetDefinition(MicrosoftResearch.Infer.Models.MethodInvoke)">
      <summary>
            Sets the definition for the variable, in a given condition block context
            </summary>
      <param name="methodInvoke">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetDomainType">
      <summary>
            Gets the domain type of a Variable&lt;T&gt;
            </summary>
      <returns>The type parameter T of Variable&lt;T&gt;</returns>
      <remarks>
        <c>this</c> must be a Variable&lt;T&gt;
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetExpression">
      <summary>
            Gets a syntax tree which refers to this variable in MSL.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a variable.  This method
            returns the variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AddAttribute(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Adds an attribute to this variable.  Attributes can be used
            to modify how inference is performed on this variable.
            </summary>
      <param name="attr">The attribute to add</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AddAttribute(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AddAttributes(MicrosoftResearch.TransformFramework.ICompilerAttribute[])">
      <summary>
            Adds multiple attributes to this variable.
            </summary>
      <param name="attrs">The attributes to add</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AddAttributes(System.Collections.Generic.IEnumerable{MicrosoftResearch.TransformFramework.ICompilerAttribute})">
      <summary>
            Adds multiple attributes to this variable.
            </summary>
      <param name="attrs">The attributes to add</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AddDefinitionAttribute(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Add an attribute to the factor defining this variable.
            </summary>
      <param name="attribute">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetValueRange">
      <summary>
            Get the ValueRange attribute of this variable, if any has been set, otherwise throws an exception.
            </summary>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentException">If the variable has no ValueRange attribute.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetValueRange(System.Boolean)">
      <summary>
            Get the ValueRange attribute of this variable, if any has been set.
            </summary>
      <param name="throwIfMissing">Indicates if a missing attribute should throw an exception.</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentException">If the variable has no ValueRange attribute and <paramref name="throwIfMissing" /> is true.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.SetValueRange(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Sets the ValueRange attribute of this variable, replacing any previously set.
            </summary>
      <param name="valueRange">A range defining the set of values this variable can take on.  Only meaningful for Variable&lt;int&gt; and Variable&lt;Vector&gt;</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.SetSparsity(MicrosoftResearch.Infer.Maths.Sparsity)">
      <summary>
            Sets the Sparsity attribute of this variable, replacing any previously set.
            </summary>
      <param name="sparsity">A sparsity specification for vector messages</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetAttributes``1">
      <summary>
            Get all attributes of this variable having type AttributeType.
            </summary>
      <typeparam name="AttributeType">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.RemoveAllAttributes``1">
      <summary>
            Remove all attributes of the specified type
            </summary>
      <typeparam name="AttributeType">The attribute type to remove</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.HasAttribute``1">
      <summary>
            Determines if this variable has at least one attribute of type AttributeType.
            </summary>
      <typeparam name="AttributeType">The type of attribute to look for</typeparam>
      <returns>True if the variable has one or more attribute of that type, false otherwise</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetFirstAttribute``1">
      <summary>
            Gets the first attribute of the specified type
            </summary>
      <typeparam name="AttributeType">The type of attribute to look for</typeparam>
      <returns>The first attribute of the specified type</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetContainers``1">
      <summary>
            List of containers for this variable (ForEachBlock, IfBlock, etc.)
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItemExpression">
      <summary>
            Helper function for implementing GetExpression.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.MakeItem(MicrosoftResearch.Infer.Models.IVariableArray,MicrosoftResearch.Infer.Models.IModelExpression[])">
      <summary>
            Modify the variable to be an element of an array, keeping the same definition.
            </summary>
      <param name="varArray">
      </param>
      <param name="inds">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CheckCompatibleIndexing(MicrosoftResearch.Infer.Models.Variable)">
      <summary>
            Throws an exception if this variable and value are defined over a different set of ranges.
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(``0)">
      <summary>
            Defines a constant
            </summary>
      <typeparam name="T">The type of the constant</typeparam>
      <param name="value">The value of the constant</param>
      <returns>The constant object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(``0[])">
      <summary>
            Defines a constant which is a 1D array.
            </summary>
      <typeparam name="T">The element type</typeparam>
      <param name="value">The constant array</param>
      <returns>A new constant variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(``0[],MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Defines a constant which is a 1D array.
            </summary>
      <typeparam name="T">The element type</typeparam>
      <param name="value">The constant array</param>
      <param name="r">The range associated with this constant array</param>
      <returns>A new constant variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(``0[][],MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Defines a constant which is a 2-D jagged array
            </summary>
      <typeparam name="T">The element type</typeparam>
      <param name="value">The constant array</param>
      <param name="r1">The range associated with the first index</param>
      <param name="r2">The range associated with the second index</param>
      <returns>A new constant jagged array variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(``0[][][],MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Defines a constant 3-D jagged array
            </summary>
      <typeparam name="T">The element type</typeparam>
      <param name="value">The constant array</param>
      <param name="r1">The range associated with the first index</param>
      <param name="r2">The range associated with the second index</param>
      <param name="r3">The range associated with the third index</param>
      <returns>A new constant jagged array variable.</returns>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(System.Collections.Generic.IList{``0})">
      <summary>
            Defines a constant which is a 1D array.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="value">The constant list.</param>
      <returns>A new constant variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Defines a constant which is a 1D array.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="value">The constant list.</param>
      <param name="r">The range associated with this constant list.</param>
      <returns>A new constant variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constant``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Defines a constant which is a 2-D jagged array.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="value">The constant list of lists.</param>
      <param name="r1">The range associated with the first index.</param>
      <param name="r2">The range associated with the second index.</param>
      <returns>A new constant jagged array variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(``0)">
      <summary>
            Creates a variable and observes it.
            </summary>
      <typeparam name="T">The type of the observed value</typeparam>
      <param name="observedValue">The observed value</param>
      <returns>A new variable</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(``0[])">
      <summary>
            Creates a variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value</param>
      <returns>A new variable</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(``0[],MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value</param>
      <param name="r">The range used to index the array</param>
      <returns>A new variable</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(``0[][],MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a jagged variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value</param>
      <param name="r1">The range used for the first index</param>
      <param name="r2">The range used for the second index</param>
      <returns>A new variable</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(``0[][][],MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a jagged variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value</param>
      <param name="r1">The range used for the first index</param>
      <param name="r2">The range used for the second index</param>
      <param name="r3">The range used for the third index</param>
      <returns>A new variable</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(System.Collections.Generic.IList{``0})">
      <summary>
            Creates a variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value.</param>
      <returns>A new variable.</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value.</param>
      <param name="r">The range used to index the array.</param>
      <returns>A new variable.</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Observed``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a jagged variable array and observes it.
            </summary>
      <typeparam name="T">The type of the observed array elements.</typeparam>
      <param name="observedValue">The observed value.</param>
      <param name="r1">The range used for the first index.</param>
      <param name="r2">The range used for the second index.</param>
      <returns>A new variable.</returns>
      <remarks>The variable is not constant; its ObservedValue can be changed.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Random``1(MicrosoftResearch.Infer.Distributions.IDistribution{``0})">
      <summary>
            Creates a random variable with a specified prior distribution.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="dist">The prior distribution.</param>
      <returns>Returns a random variable that is statistically defined by the specified prior.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Random``2(MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Creates a random variable with a specified prior distribution.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <typeparam name="TDist">The distribution type.</typeparam>
      <param name="dist">The prior distribution.</param>
      <returns>Returns a random variable that is statistically defined by the specified prior.</returns>
      <remarks>
            Consider using <see cref="M:MicrosoftResearch.Infer.Models.Variable`1.Random``1(MicrosoftResearch.Infer.Models.Variable{``0})" /> instead, as then the second type can be automatically inferred.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.New``1">
      <summary>
            Creates a variable with no statistical definition.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <returns>A random variable without a statistical definition.</returns>
      <remarks>
            This method is intended for constructing variables whose statistical definition is conditional,
            and will be provided later using If/Case/Switch blocks.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ForEach(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a new 'for each' block
            </summary>
      <param name="range">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Repeat(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a new 'repeat' block
            </summary>
      <param name="count">The count of times to repeat the contained block</param>
      <returns>The repeat block</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable array with a specified size.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r">
            A <c>Range</c> object that is initialized with the array's length. 
            </param>
      <returns>
            Returns a <c>VariableArray</c> object whose size is specified by <paramref name="r" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IList``1(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable IList with a specified size.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r">
            A <c>Range</c> object that is initialized with the array's length. 
            </param>
      <returns>
            Returns a <c>VariableArray</c> object whose size is specified by <paramref name="r" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``1(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable IArray with a specified size.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r">
            A <c>Range</c> object that is initialized with the array's length. 
            </param>
      <returns>
            Returns a <c>VariableArray</c> object whose size is specified by <paramref name="r" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
             Creates a 2D random variable array with specified dimensions.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r1">
            A <c>Range</c> object that is initialized with the size of the array's first dimension. 
            </param>
      <param name="r2">
            A <c>Range</c> object that is initialized with the size of the array's second dimension. 
            </param>
      <returns>
            Returns a <c>VariableArray2D</c> object whose dimensions are pecified by <paramref name="r1" /> and <paramref name="r2" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``1(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
             Creates a 2D random variable array with specified dimensions.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r1">
            A <c>Range</c> object that is initialized with the size of the array's first dimension. 
            </param>
      <param name="r2">
            A <c>Range</c> object that is initialized with the size of the array's second dimension. 
            </param>
      <returns>
            Returns a <c>VariableArray2D</c> object whose dimensions are pecified by <paramref name="r1" /> and <paramref name="r2" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
             Creates a 3D random variable array with specified dimensions.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="r1">
            A <c>Range</c> object that is initialized with the size of the array's first dimension. 
            </param>
      <param name="r2">
            A <c>Range</c> object that is initialized with the size of the array's second dimension. 
            </param>
      <param name="r3">
            A <c>Range</c> object that is initialized with the size of the array's third dimension. 
            </param>
      <returns>
            Returns a <c>VariableArray3D</c> object whose dimensions are pecified by <paramref name="r1" />, 
            <paramref name="r2" />, and <paramref name="r3" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Models.Range})">
      <summary>
            Creates a 1D or 2D random variable array whose dimensions are specified by a list of <c>Range</c> objects.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="ranges">A list of <c>Range</c> objects, each object initialized to 
            the size of one of the array's dimensions. The list can contain no more than two <c>Range objects</c></param>
      <returns>
            Returns a <c>VariableArray</c> or <c>VariableArray2D</c> object whose dimensions are specified
            by <paramref name="ranges" />.
            </returns>
      <exception cref="T:System.NotSupportedException">Throws <c>NotSupportedException</c> if <paramref name="ranges" />
            contains more than two <c>Range</c> objects.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable array that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of the array is
            a <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IList``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable IList that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of the array is
            a <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable IArray that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of the array is
            a <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.VariableArray2D{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable array that contains a jagged array of 2D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray2D</c> object that serves as the item prototype.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>
            Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of the array is
            a <c>VariableArray2D</c>object whose prototype is defined by <paramref name="array" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``1(MicrosoftResearch.Infer.Models.VariableArray2D{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 1D random variable IArray that contains a jagged array of 2D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray2D</c> object that serves as the item prototype.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>
            Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of the array is
            a <c>VariableArray2D</c>object whose prototype is defined by <paramref name="array" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a 2-D random variable array that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r1">A <c>Range</c> object that is initialized with the size of the array's first dimension. </param>
      <param name="r2">A <c>Range</c> object that is initialized with the size of the array's second dimension. </param>
      <returns>
            Returns a <c>VariableArray2D</c> object whose dimensions are defined by <paramref name="r1" /> and <paramref name="r2" />.
            Each element of the array is a <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 2-D random variable IArray2D that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A <c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r1">A <c>Range</c> object that is initialized with the size of the array's first dimension. </param>
      <param name="r2">A <c>Range</c> object that is initialized with the size of the array's second dimension. </param>
      <returns>
            Returns a <c>VariableArray2D</c> object whose dimensions are defined by <paramref name="r1" /> and <paramref name="r2" />.
            Each element of the array is a <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
             Creates a 3-D <c>VariableArray</c> object that contains a jagged array of 1D random variables.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">A<c>VariableArray</c> object that serves as the item prototype.</param>
      <param name="r1">A <c>Range</c> object that is initialized with the size of the array's first dimension. </param>
      <param name="r2">A <c>Range</c> object that is initialized with the size of the array's second dimension. </param>
      <param name="r3">A <c>Range</c> object that is initialized with the size of the array's third dimension. </param>
      <returns>
            Returns a <c>VariableArray3D</c> object whose dimensions are defined by <paramref name="r1" />, <paramref name="r2" />,
            and <paramref name="r3" />.
            Each element of the array is a 1D <c>VariableArray</c>object whose prototype is defined by <paramref name="array" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 1D array of 1D random variable arrays
            </summary>
      <typeparam name="TItem">The variable type of an item after two levels of indexing.</typeparam>
      <typeparam name="TArray">The domain type of an item.</typeparam>
      <param name="array">A variable object that serves as a prototype for the array elements.</param>
      <param name="r">A <c>Range</c> object that specifies the array length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of this
            array is a object of type <c>VariableArray&lt;TItem,TArray&gt;</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IList``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 1D IList of 1D random variable arrays
            </summary>
      <typeparam name="TItem">The variable type of an item after two levels of indexing.</typeparam>
      <typeparam name="TArray">The domain type of an item.</typeparam>
      <param name="array">A variable object that serves as a prototype for the array elements.</param>
      <param name="r">A <c>Range</c> object that specifies the array length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of this
            array is a object of type <c>VariableArray&lt;TItem,TArray&gt;</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IArray``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 1D IArray of 1D random variable arrays
            </summary>
      <typeparam name="TItem">The variable type of an item after two levels of indexing.</typeparam>
      <typeparam name="TArray">The domain type of an item.</typeparam>
      <param name="array">A variable object that serves as a prototype for the array elements.</param>
      <param name="r">A <c>Range</c> object that specifies the array length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is defined by <paramref name="r" />. Each element of this
            array is a object of type <c>VariableArray&lt;TItem,TArray&gt;</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Array``2(``0,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 1D array of random variables
            </summary>
      <typeparam name="TItem">The variable type of an item.</typeparam>
      <typeparam name="TArray">The domain type of the variable.</typeparam>
      <param name="itemPrototype">A variable object that serves as a prototype for the array elements.</param>
      <param name="r">A <c>Range</c> object that is initialized with the array's length.</param>
      <returns>Returns a <c>VariableArray</c> object whose length is also defined by <paramref name="r" />. Each element of this
            array is a object of type <c>TItem</c> whose prototype is defined by <paramref name="itemPrototype" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constrain``1(MicrosoftResearch.Infer.Factors.ConstrainMethod{``0},MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Applies a constraint using a constraint method with one argument.
            </summary>
      <param name="constraint">The method that represents the constraint</param>
      <param name="arg1">The argument for the constraint</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constrain``2(MicrosoftResearch.Infer.Factors.ConstrainMethod{``0,``1},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Applies a constraint using a constraint method with two arguments.
            </summary>
      <param name="constraint">The method that represents the constraint</param>
      <param name="arg1">First argument for the constraint</param>
      <param name="arg2">Second argument for the constraint</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constrain``3(MicrosoftResearch.Infer.Factors.ConstrainMethod{``0,``1,``2},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1},MicrosoftResearch.Infer.Models.Variable{``2})">
      <summary>
            Applies a constraint using a constraint method with three arguments.
            </summary>
      <param name="constraint">The method that represents the constraint</param>
      <param name="arg1">First argument for the constraint</param>
      <param name="arg2">Second argument for the constraint</param>
      <param name="arg3">Third argument for the constraint</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Constrain``4(MicrosoftResearch.Infer.Factors.ConstrainMethod{``0,``1,``2,``3},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1},MicrosoftResearch.Infer.Models.Variable{``2},MicrosoftResearch.Infer.Models.Variable{``3})">
      <summary>
            Applies a constraint using a constraint method with four arguments.
            </summary>
      <param name="constraint">The method that represents the constraint</param>
      <param name="arg1">First argument for the constraint</param>
      <param name="arg2">Second argument for the constraint</param>
      <param name="arg3">Third argument for the constraint</param>
      <param name="arg4">Fourth argument for the constraint</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainInternal(System.Reflection.MethodInfo,MicrosoftResearch.Infer.Models.Variable[])">
      <summary>
      </summary>
      <param name="methodInfo">
      </param>
      <param name="args">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianFromMeanAndPrecision(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Gaussian-distributed random variable with mean and precision represented
            by random variables.
            </summary>
      <param name="mean">A <c>double</c> random variable that represents the mean value.</param>
      <param name="precision">A <c>double</c> random variable that represents the precision value.</param>
      <returns>
            Returns a Gaussian-distributed random variable with the specified mean and precision.
            </returns>
      <remarks>The variance is 1/precision.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianFromMeanAndPrecision(System.Double,System.Double)">
      <summary>
            Creates a Gaussian-distributed random variable with specified mean and precision.
            </summary>
      <param name="mean">The mean.</param>
      <param name="precision">The precision.</param>
      <returns>
            Returns a Gaussian-distributed random variable with the specified mean and precision.
            </returns>
      <remarks>The variance is 1/precision.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Gaussian-distributed random variable with the mean and variance represented by random variables.
            </summary>
      <param name="mean">A <c>double</c> random variable that represents the mean.</param>
      <param name="variance">A <c>double</c> random variable that represents the variance.</param>
      <returns>Returns a Gaussian-distributed random variable with the specified mean and variance.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{System.Double},System.Double)">
      <summary>
            Creates a Gaussian-distributed random variable with a specified variance, and the mean
            represented by a random variable.
            </summary>
      <param name="mean">An <c>int</c> random variable that represents the mean.</param>
      <param name="variance">The variance.</param>
      <returns>Returns a Gaussian-distributed random variable with the specified mean and variance.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianFromMeanAndVariance(System.Double,System.Double)">
      <summary>
            Creates a Gaussian-distributed random variable with specified mean and variance.
            </summary>
      <param name="mean">The mean.</param>
      <param name="variance">The variance.</param>
      <returns>Returns a Gaussian-distributed random variable with the specified mean and variance.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.TruncatedGaussian(System.Double,System.Double,System.Double,System.Double)">
      <summary>
             Returns a random variable that is statistically defined by a truncated Gaussian distribution
             with specified mean, variance and bounds. 
            </summary>
      <param name="mean">The mean.</param>
      <param name="variance">The variance.</param>
      <param name="lowerBound">The distribution's upper bound.</param>
      <param name="upperBound">The distribution's lower bound.</param>
      <returns>Returns a truncated Gaussian-distributed random variable with the specified mean, variance,
            and bounds.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianListFromMeanAndPrecision(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}})">
      <summary>
            Returns a random variable over a sparse list domain where each element is statistically
            defined in terms of the corresponding mean and precision elements in sparse vectors
            of means and precisions
            </summary>
      <param name="mean">The sparse list of means variable</param>
      <param name="precision">The sparse list of precisions variable</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianListFromMeanAndPrecision(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}})">
      <summary>
            Returns a random variable over a sparse list domain where each element is statistically
            defined in terms of the corresponding mean and precision elements in sparse vectors
            of means and precisions
            </summary>
      <param name="mean">The sparse list of means</param>
      <param name="precision">The sparse list of precisions variable</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianListFromMeanAndPrecision(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
      <summary>
            Returns a random variable over a sparse vector domain where each element is statistically
            defined in terms of the corresponding mean and precision elements in sparse vectors
            of means and precisions
            </summary>
      <param name="mean">The sparse list of means variable</param>
      <param name="precision">The sparse list of precisions</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GaussianListFromMeanAndPrecision(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
      <summary>
            Returns a random variable over a sparse vector domain where each element is statistically
            defined in terms of the corresponding mean and precision elements in sparse vectors
            of means and precisions
            </summary>
      <param name="mean">The sparse list of means</param>
      <param name="precision">The sparse list of precisions</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.VectorGaussianFromMeanAndPrecision(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix})">
      <summary>
            Creates a vector Gaussian-distributed random vector with the mean and precision matrix represented
            by random variables.
            </summary>
      <param name="mean">A <c>Vector</c> random variable that represents the mean.</param>
      <param name="precision">A <c>PositiveDefiniteMatrix</c> random variable that represents the precision matrix.</param>
      <returns>Returns a vector Gaussian-distributed random variable with the specified mean and precision matrix.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.VectorGaussianFromMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
      <summary>
            Creates a Gaussian-distributed random vector with a specified mean and precision matrix.
            </summary>
      <param name="mean">A <c>Vector</c> object that specifies the mean values.</param>
      <param name="precision">A <c>PositiveDefiniteMatrix</c> object that specified the precision matrix.</param>
      <returns>Returns a vector Gaussian-distributed random variable with the specified mean and precision matrix.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.VectorGaussianFromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
      <summary>
            Creates a Gaussian-distributed random vector from a mean vector and variance positive definite matrix.
            </summary>
      <param name="mean">The mean vector of the Gaussian</param>
      <param name="variance">The variance matrix of the Gaussian</param>
      <returns>Gaussian-distributed random vector variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.VectorGaussianFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
      <summary>
            Creates a Gaussian-distributed random vector from a mean vector and variance positive definite matrix.
            </summary>
      <param name="mean">A variable containing mean vector of the Gaussian</param>
      <param name="variance">The variance matrix of the Gaussian</param>
      <returns>Gaussian-distributed random vector variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.VectorGaussianFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix})">
      <summary>
            Creates a Gaussian-distributed random vector from a mean vector and variance positive definite matrix.
            </summary>
      <param name="mean">A variable containing mean vector of the Gaussian</param>
      <param name="variance">The variance matrix of the Gaussian</param>
      <returns>Gaussian-distributed random vector variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromShapeAndScale(System.Double,System.Double)">
      <summary>
            Creates a Gamma-distributed random variable with specified shape and scale parameters.
            </summary>
      <param name="shape">The shape parameter value.</param>
      <param name="scale">The scale parameter value.</param>
      <returns>Returns a Gamma-distributed random variable with the specified shape and scale parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromShapeAndScale(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Gamma-distributed random variable with its shape and scale parameters represented by random variables.
            </summary>
      <param name="shape">A <c>double</c> random variable that represents the shape parameter.</param>
      <param name="scale">A <c>double</c> random variable that represents the scale parameter.</param>
      <returns>Returns a Gamma-distributed random variable with the specified shape and scale parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromShapeAndRate(System.Double,System.Double)">
      <summary>
            Creates a Gamma-distributed random variable with specified shape and rate parameters.
            </summary>
      <param name="shape">The shape parametervalue.</param>
      <param name="rate">The rate parameter value.</param>
      <returns>Returns a Gamma-distributed random variable with the specified shape and rate parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromShapeAndRate(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Gamma-distributed random variable with its shape and rate parameters represented by random variables.
            </summary>
      <param name="shape">A <c>double</c> random variable that represents the shape parameter.</param>
      <param name="rate">A <c>double</c> random variable that represents the rate parameter.</param>
      <returns>Returns a Gamma-distributed random variable with the specified shape and rate parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromMeanAndVariance(System.Double,System.Double)">
      <summary>
            Creates a Gamma-distributed random variable with specified mean and variance parameters.
            </summary>
      <param name="mean">The mean parameter value.</param>
      <param name="variance">The variance parameter value.</param>
      <returns>Returns a Gamma-distributed random variable with the specified mean and variance parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GammaFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Gamma-distributed random variable with its mean and variance parameters represented by random variables.
            </summary>
      <param name="mean">A <c>double</c> random variable that represents the mean parameter.</param>
      <param name="variance">A <c>double</c> random variable that represents the variance parameter.</param>
      <returns>Returns a Gamma-distributed random variable with the specified mean and variance parameters.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.WishartFromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
      <summary>
            Creates a Wishart-distributed random variable with specified shape and scale.
            </summary>
      <param name="shape">The shape.</param>
      <param name="scale">The scale matrix.</param>
      <returns>Returns a Wishart-distributed random variable with the specified shape and scale matrix.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.WishartFromShapeAndScale(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix})">
      <summary>
            Creates a Wishart-distributed random matrix with the shape and scale represented by random variables.
            </summary>
      <param name="shape">A <c>double</c> random variable that represents the shape.</param>
      <param name="scale">A <c>PositiveDefiniteMatrix</c> random variable that represents the scale matrix.</param>
      <returns>Returns a Wishart-distributed random variable with the specified shape and scale matrix.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.WishartFromShapeAndRate(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix})">
      <summary>
            Creates a Wishart-distributed random matrix with the shape and rate represented by random variables.
            </summary>
      <param name="shape">A <c>double</c> random variable that represents the shape.</param>
      <param name="rate">A <c>PositiveDefiniteMatrix</c> random variable that represents the rate matrix.</param>
      <returns>Returns a Wishart-distributed random variable with the specified shape and rate matrix.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Bernoulli(System.Double)">
      <summary>
            Creates a Boolean random variable with a specified probability of being true.
            </summary>
      <param name="probTrue">A <c>double</c>value from [0, 1] that specifies the probability that
            the variable is true.</param>
      <returns>Returns a Boolean random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Bernoulli(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Boolean random variable with the probability of being true specified by a random variable.
            </summary>
      <param name="probTrue">A <c>double</c> random variable over [0,1], typically statistically defined by a
            <c>Beta</c> distribution, that specifies the probability that the output variable is true.</param>
      <returns>Returns a Boolean random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliList(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}})">
      <summary>
            Creates a random variable whose domain is a sparse list of bools.
            </summary>
      <param name="probTrue">The sparse list of probTrue elements</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliList(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
      <summary>
            Creates a random variable whose domain is a sparse list of bools.
            </summary>
      <param name="probTrue">The sparse list of probTrue elements</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliIntegerSubset(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}})">
      <summary>
            Creates a random variable whose domain is a list of type integer.
            </summary>
      <param name="probInSubset">The probability of a given integer being in the random list. This is given as random variable over a sparse list - i.e. most of the probabilities are the same.</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliIntegerSubset(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
      <summary>
            Creates a random variable whose domain is a list of type integer.
            </summary>
      <param name="probInSubset">The probability of a given integer being in the random list. This is given as a sparse list - i.e. most of the probabilities are the same.</param>
      <returns>A <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset" /> distributed random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliFromLogOdds(System.Double)">
      <summary>
            Creates a Boolean random variable with the probability of being true specified by the input's
            logistic function.
            </summary>
      <param name="logOdds">The input's logistic function, which specifies the probability that the
            variable is true as probTrue = 1/(1 + exp(-logOdds)).</param>
      <returns>Returns a Boolean random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BernoulliFromLogOdds(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Boolean random variable with the probability of being true specified by the input's
            logistic function, which is represented by a random variable.
            </summary>
      <param name="logOdds">A <c>double</c> random variable that represents the logistic function,
            which specifies the probability that the variable is true as probTrue = 1/(1 + exp(-logOdds))</param>
      <returns>Returns a Boolean random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(System.Double[])">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with a specified
            set of probabilities.
            </summary>
      <param name="probs">An array that specifies the probability of each possible value, from [0, probs.Length-1].
            The array must have more than one element. The probabilities should sum to 1.0.
            If not, the probabilities will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="probs" /> contains only one element.
            To specify a uniform Discrete distribution, use <c>Variable.DiscreteUniform.</c></exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(MicrosoftResearch.Infer.Models.Range,System.Double[])">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with a specified
            number of possible values, and a corresponding set of probabilities.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the number of possible values.</param>
      <param name="probs">An array that specifies the probability of each possible value, from [0, probs.Length-1].
            The array must have more than one element. The probabilities should sum to 1.0.
            If not, the probabilities will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="probs" /> contains only one element.
            To specify a uniform Discrete distribution, use <c>Variable.DiscreteUniform.</c></exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with the set of possible
            values specified by a <c>Vector</c> object.
            </summary>
      <param name="v">A <c>Vector</c> object that specifies the probability of each possible value, from [0, probs.Length-1].
            The probabilities should sum to 1.0. If not, the probabilities will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with the number of possible
            values specified by a <c>Range</c> object and the probabilities by a <c>Vector</c> object.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the number of possible values.</param>
      <param name="v">A <c>Vector</c> object that specifies the probability of each possible value, from [0, probs.Length-1].
            The probabilities should sum to 1.0. If not, the probabilities will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DiscreteUniform(System.Int32)">
      <summary>
            Create a random integer by drawing uniformly from the range 0..(size-1)
            </summary>
      <param name="size">The number of possible values.</param>
      <returns>A random variable with an equal probability of taking any value in the range 0..(size-1)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DiscreteUniform(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a random integer by drawing uniformly from a range.
            </summary>
      <param name="range">A <c>Range</c> object specifying the number of possible values.</param>
      <returns>A random integer with an equal probability of taking any value in the range.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DiscreteUniform(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with the number
            of possible values specified by an <c>int</c> random variable.
            </summary>
      <param name="size">An <c>int</c> random variable that represents the number of possible values.</param>
      <returns>Returns a random variable that is statistically defined by a Discrete distribution with equal
            probabilities for each possible value.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DiscreteUniform(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a random variable that is statistically defined by a uniform Discrete distribution with the number
            of possible values specified by <c>Range</c> object, and the upper bound specified by a random variable.
            </summary>
      <param name="valueRange">A <c>Range</c> object for <paramref name="size" /> that represents the value range.</param>
      <param name="size">A random variable that represents the dimension of the discrete distribution.</param>
      <returns>Returns a random variable that is statistically defined by a Discrete distribution with equal
            probabilities for each possible value.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with the probabilities of
            the possible values specified by an <c>Vector</c> random variable.
            </summary>
      <param name="probs">A <c>Vector</c> random variable that represents the probabilities of the
            possible values.  The probabilities should sum to 1.0. If not, the probabilities will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Discrete(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a random variable that is statistically defined by a Discrete distribution with the number of
            possible values specified by a <c>Range</c> object and the probabilities of
            the possible values specified by an <c>Vector</c> random variable.
            </summary>
      <param name="valueRange">A range defining the possible values for the variable.</param>
      <param name="probs">A variable holding the set of probabilities of having each value.  Must add up to one.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumDiscrete``1(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a random variable with a Discrete distribution using probabilities specified by a <c>Vector</c>
            object for each of the values of the specified enum type.
            </summary>
      <typeparam name="TEnum">The enum type.</typeparam>
      <param name="probs">A <c>Vector</c> random variable that represents of probabilities for each of the enum's
            values. The probabilities must sum to one. If not, they will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumDiscrete``1(System.Double[])">
      <summary>
            Creates a random variable with a Discrete distribution with specified probabilities for each of the
            values of the specified enum type.
            </summary>
      <typeparam name="TEnum">The enum type.</typeparam>
      <param name="probs">A <c>double</c> array that contains the probabilities for each of the enum's
            values. The probabilities must sum to one. If not, they will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumDiscrete``1(MicrosoftResearch.Infer.Models.Range,System.Double[])">
      <summary>
            Creates a random variable with a Discrete distribution with the dimension specified by a <c>Range</c>
            object and specified probabilities for each of the values of the enum type.
            </summary>
      <typeparam name="TEnum">The enum type.</typeparam>
      <param name="valueRange">A <c>Range</c> object initialized to the number of enum elements.</param>
      <param name="probs">A <c>double</c> array that contains the probabilities for each of the enum's
            values. The probabilities must sum to one. If not, they will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumDiscrete``1(MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a random variable with a Discrete distribution with the probabilities for each of
            the values of the enum type specified by a <c>Vector</c> object.
            </summary>
      <typeparam name="TEnum">The enum type.</typeparam>
      <param name="probs">A <c>Vector</c> object that contains the probabilities for each of the enum's
            values. The probabilities must sum to one. If not, they will be normalized.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumDiscrete``1(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a random variable with a Discrete distribution with the number of possible values
            specified by a <c>Range</c> object and the probabilities for each of
            the values of the enum type specified by a <c>Vector</c> object.
            </summary>
      <typeparam name="TEnum">The type of the enum</typeparam>
      <param name="valueRange">A <c>Range</c> object initialized to the number of enum values.</param>
      <param name="probs">The vector of probabilities of having each value.  Must add up to one.</param>
      <returns>Returns a random variable that is statistically defined by the specified Discrete distribution.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumUniform``1">
      <summary>
            Creates a random variable with a Discrete distribution with a uniform distribution.
            </summary>
      <typeparam name="TEnum">The enum type.</typeparam>
      <returns>Returns a random variable that is statistically defined by the a Discrete distribution with equal
            probabilities for all possible values.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumUniform``1(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a random variable with a Discrete distribution with the dimension specified by a <c>Range</c>
            object and a uniform distribution.
            </summary>
      <typeparam name="TEnum">The type of the enum</typeparam>
      <param name="valueRange">A range over the enum values.</param>
      <returns>Enum random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.EnumToInt``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Creates a random int variable corresponding to a random enum variable.  The returned
            variable can be used as the condition for a Switch or Case block.
            </summary>
      <typeparam name="TEnum">The enum type</typeparam>
      <param name="enumVar">The enum variable</param>
      <returns>An integer random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DiscreteFromLogProbs(MicrosoftResearch.Infer.Models.VariableArray{System.Double})">
      <summary>
            Creates a random int variable x where p(x=k) is proportional to exp(logProbs[k]), i.e. the softmax function of the logProbs.
            </summary>
      <param name="logProbs">Arguments to the softmax.</param>
      <returns>An integer random variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BetaFromMeanAndVariance(System.Double,System.Double)">
      <summary>
             Creates a Beta-distributed random variable with specified mean and variance
            </summary>
      <param name="mean">The distribution's mean.</param>
      <param name="variance">The distribution's variance.</param>
      <returns>Returns a Beta-distributed random variable whose mean and variance are specified by <paramref name="mean" />
            and <paramref name="variance" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.BetaFromMeanAndVariance(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
             Creates a Beta-distributed random variable with the mean and variance specified by random variables.
            </summary>
      <param name="mean"> A <c>double</c> random variable that represents the distribution's mean.</param>
      <param name="variance"> A <c>double</c> random variable that represents the distribution's variance.</param>
      <returns> Returns a Beta-distributed random variable whose mean and variance are specified by random variables, <paramref name="mean" />
            and <paramref name="variance" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Beta(System.Double,System.Double)">
      <summary>
            Creates a Beta-distributed random variable from initial success/failure counts.
            </summary>
      <param name="trueCount">The initial success count.</param>
      <param name="falseCount">The initial failure count.</param>
      <returns>Returns a Beta-distributed random variable that is statistically defined by
            Beta(trueCount,falseCount).</returns>
      <remarks>
            The distribution's formula is
            <c>prob(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>
            where x is between [0, 1].
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Beta(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Beta-distributed random variable from initial success/failure counts that are
            represented by random variables.
            </summary>
      <param name="trueCount">A <c>double</c> random variable that represents the initial success count.</param>
      <param name="falseCount">A <c>double</c> random variable that represents the initial failure count.</param>
      <returns>Returns a Beta-distributed random variable that is statistically defined by
            Beta(trueCount,falseCount).</returns>
      <remarks>
            The distribution's formula is
            <c>prob(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>
            where x is between [0, 1].
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletUniform(System.Int32)">
      <summary>
            Create a uniform Dirichlet-distributed random variable with a specified dimension.
            </summary>
      <param name="dimension">The the Dirichlet distribution's dimensionality.</param>
      <returns>Returns a uniform Dirichlet-distributed random variable. The distribution's pseudo-counts are
            all 1.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletUniform(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Create a uniform Dirichlet-distributed random variable with a specified dimension.
            </summary>
      <param name="dimension">The the Dirichlet distribution's dimensionality.</param>
      <returns>Returns a uniform Dirichlet-distributed random variable. The distribution's pseudo-counts are
            all 1.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletUniform(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Creates a uniform Dirichlet-distributed random variable with dimension specified by a
            <c>Range</c> object.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the  Dirichlet
            distribution's dimensionality.</param>
      <returns>Returns a uniform Dirichlet-distributed random variable. The distribution's pseudo-counts are
            all set to 1.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletSymmetric(System.Int32,System.Double)">
      <summary>
            Creates a symmetric Dirichlet-distributed random variable with a specified dimension
            and a common pseudo-count.
            </summary>
      <param name="dimension">The the Dirichlet distribution's dimensionality.</param>
      <param name="pseudocount">A pseudo-count, that is applied to all dimensions.</param>
      <returns>Returns a symmetric Dirichlet-distributed random variable with the pseudo-counts
            set to <paramref name="pseudocount" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletSymmetric(System.Int32,MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a symmetric Dirichlet-distributed random variable with a specified dimension
            and a common pseudo-count, which is represented by a random variable.
            </summary>
      <param name="dimension">The the Dirichlet distribution's dimensionality.</param>
      <param name="pseudocount">A pseudo-count, represented by a random variable, which
            is applied to all dimensions.</param>
      <returns>Returns a symmetric Dirichlet-distributed random variable with the pseudo-counts
            set to <paramref name="pseudocount" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.DirichletSymmetric(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a symmetric Dirichlet-distributed random variable with the dimension specified by
            a <c>Range</c> object and a common pseudo-count, which is represented by a random variable.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the  Dirichlet
            distribution's dimensionality.</param>
      <param name="pseudocount">A pseudo-count, represented by a random variable, which
            is applied to all dimensions.</param>
      <returns>Returns a symmetric Dirichlet-distributed random variable with the pseudo-counts
            set to <paramref name="pseudocount" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(System.Double[])">
      <summary>
            Creates a Dirichlet-distributed random variable with a specified set of pseudo-counts.
            </summary>
      <param name="u">An array containing the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable with the pseudo-counts specified
            by <paramref name="u" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(MicrosoftResearch.Infer.Models.Range,System.Double[])">
      <summary>
            Creates a Dirichlet-distributed random variable with the dimensionality specified by
            a <c>Range</c> object and a specified set of pseudo-counts.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the  Dirichlet
            distribution's dimensionality.</param>
      <param name="u">An array containing the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable of dimension <paramref name="u" /></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a Dirichlet-distributed random variable with a set of pseudo-counts specified
            by a <c>Vector</c> object.
            </summary>
      <param name="v">A <c>Vector</c> object containing the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable with the pseudo-counts specified
            by <paramref name="v" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a Dirichlet-distributed random variable with pseudo-counts specified by a random variable.
            </summary>
      <param name="pseudoCount">A <c>Vector</c> random variable that represents the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable with the pseudo-counts specified
            by <paramref name="pseudoCount" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates a Dirichlet-distributed random variable with the dimensionality specified by
            a <c>Range</c> object and the pseudo-counts specified by a <c>Vector</c> object.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the Dirichlet
            distribution's dimensionality.</param>
      <param name="v">A <c>Vector</c> object containing the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable with the dimensionality specified by
            <paramref name="valueRange" /> and the pseudo-counts specified
            by <paramref name="v" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Dirichlet(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a Dirichlet-distributed random variable with the dimensionality specified by
            a <c>Range</c> object and the pseudo-counts represented by a random variable.
            </summary>
      <param name="valueRange">A <c>Range</c> object that is initialized to the  Dirichlet
            distribution's dimensionality.</param>
      <param name="v">A <c>Vector</c> random variable that represents the pseudo-counts.</param>
      <returns>Returns a Dirichlet-distributed random variable with the dimensionality specified by
            <paramref name="valueRange" /> and the pseudo-counts specified
            by <paramref name="v" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Double(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Create a double-precision random variable that is constrained to equal the given integer variable.
            </summary>
      <param name="integer">An integer variable</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Double(MicrosoftResearch.Infer.Models.IModelExpression{System.Int32})">
      <summary>
            Create a double-precision random variable that is constrained to equal the given integer expression.
            </summary>
      <param name="integer">An integer expression</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Poisson(System.Double)">
      <summary>
            Creates a Poisson-distributed random variable with a specified mean.
            </summary>
      <param name="mean">The mean.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Poisson(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Poisson-distributed random variable with the mean represented by a random variable.
            </summary>
      <param name="mean">A random variable that represents the mean.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Binomial(System.Int32,MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Binomially-distributed random variable with the specified probability of success per trial and number of trials.
            </summary>
      <param name="trialCount">The number of trials</param>
      <param name="probSuccess">A variable containing the probability of success per trial</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Binomial(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a Binomially-distributed random variable with the specified probability of success per trial and number of trials.
            </summary>
      <param name="trialCount">A variable containing the number of trials</param>
      <param name="probSuccess">A variable containing the probability of success per trial</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.MultinomialList(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a list x of random integers where x[i] is the number of times that value i is drawn in the given number of trials.
            </summary>
      <param name="trialCount">The number of trials</param>
      <param name="probs">A variable containing the probability distribution for drawing each value per trial.</param>
      <returns>A variable containing a list of counts</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Multinomial(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates an array x of random integers where x[i] is the number of times that value i is drawn in the given number of trials.
            </summary>
      <param name="trialCount">The number of trials</param>
      <param name="probs">A variable containing the probability distribution for drawing each value per trial.  Must have a ValueRange attribute specifying the number of possible values.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Multinomial(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Maths.Vector)">
      <summary>
            Creates an array x of random integers where x[i] is the number of times that value i is drawn in the given number of trials.
            </summary>
      <param name="trialCount">The number of trials</param>
      <param name="probs">A variable containing the probability distribution for drawing each value per trial.  Must have a ValueRange attribute specifying the number of possible values.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Multinomial(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates an array x of random integers where x[i] is the number of times that value i is drawn in the given number of trials.
            </summary>
      <param name="trials">A range whose length is the number of trials.  This is becomes the ValueRange for each x[i].</param>
      <param name="probs">A variable containing the probability distribution for drawing each value per trial.  Must have a ValueRange attribute specifying the number of possible values.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.FunctionEvaluate(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Distributions.IFunction},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Evaluate a random function at a point
            </summary>
      <param name="func">A random function</param>
      <param name="x">The location to evaluate the function</param>
      <returns>A new variable equal to <c>func(x)</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IsPositive(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a boolean random variable indicating if the supplied double random variable is positive.
            </summary>
      <param name="x">The random variable to test for positivity</param>
      <returns>True if (x &gt; 0)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IsBetween(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a boolean random variable indicating if the supplied double random variable is between
            the specified limits.
            </summary>
      <param name="x">The double variable to test</param>
      <param name="lowerBound">The lower limit</param>
      <param name="upperBound">The upper limit</param>
      <returns>True if (lowerBound &lt;= x) and (x &lt; upperBound)</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.InnerProduct(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Returns a double random variable which is the inner product of two vector variables.
            </summary>
      <param name="a">The first vector variable</param>
      <param name="b">The second vector variable</param>
      <returns>
        <c>sum_i a[i]*b[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.InnerProduct(MicrosoftResearch.Infer.Models.VariableArray{System.Double},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Returns a double random variable which is the inner product of two vector variables.
            </summary>
      <param name="a">The first vector variable</param>
      <param name="b">The second vector variable</param>
      <returns>
        <c>sum_i a[i]*b[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.SumWhere(MicrosoftResearch.Infer.Models.VariableArray{System.Boolean},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Returns a double random variable which is the inner product of a array of binary variables and a vector variable.
            </summary>
      <param name="a">The first, binary vector variable</param>
      <param name="b">The second vector variable</param>
      <returns>
        <c>sum_i a[i]*b[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.MatrixTimesVector(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Matrix},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Returns a Vector variable which is the product of a Matrix variable with a Vector variable
            </summary>
      <param name="a">The matrix</param>
      <param name="b">The variable</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.MatrixTimesScalar(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Create a matrix variable whose [i,j] entry equals a[i,j]*b
            </summary>
      <param name="a">The matrix</param>
      <param name="b">The scalar</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.MatrixMultiply(MicrosoftResearch.Infer.Models.VariableArray2D{System.Double},MicrosoftResearch.Infer.Models.VariableArray2D{System.Double})">
      <summary>
            Returns a 2-D array of variables which is the matrix product of two other 2-D arrays of variables
            </summary>
      <param name="a">The first 2-D array</param>
      <param name="b">The second 2-D array</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Sum(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{System.Double}})">
      <summary>
            Returns a double variable which is the sum of the elements of an array variable.
            For sum of two variables, use the + operator.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>sum_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Sum(MicrosoftResearch.Infer.Models.Variable{System.Double[]})">
      <summary>
            Returns a double variable which is the sum of the elements of an array variable.
            For sum of two variables, use the + operator.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>sum_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Sum_Expanded(MicrosoftResearch.Infer.Models.VariableArray{System.Double})">
      <summary>
            Returns a double variable which is the sum of the elements of an array variable.
            For sum of two variables, use the + operator.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>sum_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CreateVariableArray``1(MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.IModelExpression)">
      <summary>
            Create an array that includes all ranges in the prototype (that are not open in ForEach blocks)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">Modified to be an array</param>
      <param name="prototype">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Sum(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector}})">
      <summary>
            Returns a <see cref="M:MicrosoftResearch.Infer.Models.Variable.Vector(MicrosoftResearch.Infer.Models.Variable{System.Double[]})" /> variable which is the sum of the elements of an array variable.
            </summary>
      <param name="array">The array variable.</param>
      <returns>
        <c>sum_i array[i]</c>.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Sum(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector[]})">
      <summary>
            Returns a <see cref="M:MicrosoftResearch.Infer.Models.Variable.Vector(MicrosoftResearch.Infer.Models.Variable{System.Double[]})" /> variable which is the sum of the elements of an array variable.
            </summary>
      <param name="array">The array variable.</param>
      <returns>
        <c>sum_i array[i]</c>.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Max(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a double variable which is the max of two double variables
            </summary>
      <param name="a">The first variable</param>
      <param name="b">The second variable</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Exp(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a variable which takes e to the power of another random variable
            </summary>
      <param name="exponent">The specified exponent</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Log(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a variable equal to the natural logarithm of d
            </summary>
      <param name="d">The variable argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Logistic(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Creates a variable equal to 1/(1+exp(-x))
            </summary>
      <param name="x">The variable argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Softmax(MicrosoftResearch.Infer.Models.VariableArray{System.Double})">
      <summary>
            Creates a vector variable y where y[i] = exp(x[i])/(sum_j exp(x[j])).  y has the same length as x.
            </summary>
      <param name="x">The variable array argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Softmax(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{System.Double}})">
      <summary>
            Creates a vector variable y where y[i] = exp(x[i])/(sum_j exp(x[j])).  y has the same length as x.
            </summary>
      <param name="x">The vector variable argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Softmax(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a vector variable y where y[i] = exp(x[i])/(sum_j exp(x[j])).  y has the same length as x.
            </summary>
      <param name="x">The vector variable argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Softmax(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Collections.ISparseList{System.Double}})">
      <summary>
            Creates a vector variable y where y[i] = exp(x[i])/(sum_j exp(x[j])).  y has the same length as x.
            </summary>
      <param name="x">The sparse list variable argument</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ProductExp(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Returns a Gaussian variable which is the product of A times the exponential of B. 
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Rotate(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            A random vector equal to the vector (x,y) rotated by an angle about the origin.
            </summary>
      <param name="x">First coordinate of the vector to rotate</param>
      <param name="y">Second coordinate of the vector to rotate</param>
      <param name="angle">Counter-clockwise rotation angle in radians</param>
      <returns>A new variable</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AllTrue(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{System.Boolean}})">
      <summary>
            Returns a boolean variable which is true if all array elements are true.
            For AND of two variables, use the &amp; operator.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>AND_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.AllTrue(MicrosoftResearch.Infer.Models.Variable{System.Boolean[]})">
      <summary>
            Returns a boolean variable which is true if all array elements are true.
            For AND of two variables, use the &amp; operator.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>AND_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CountTrue(MicrosoftResearch.Infer.Models.Variable{System.Boolean[]})">
      <summary>
            Returns an integer variable equal to the number of array elements that are true.
            </summary>
      <param name="array">The array variable</param>
      <returns>
        <c>sum_i array[i]</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Concat(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a random Vector by concatenating two random Vectors.
            </summary>
      <param name="first">First vector</param>
      <param name="second">Second vector</param>
      <returns>A new vector variable whose value is equal to <c>Vector.Concat(first,second)</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Vector(MicrosoftResearch.Infer.Models.Variable{System.Double[]})">
      <summary>
            Create a random Vector from values in an array.
            </summary>
      <param name="array">A random array</param>
      <returns>A new vector variable whose value is equal to <c>Vector.FromArray(array)</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ArrayFromVector(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a random array from values in a Vector.
            </summary>
      <param name="vector">A random vector</param>
      <param name="range">The range to use for indexing the array.  Must match the length of the vector.</param>
      <returns>A new array whose elements are equal to the elements of the vector</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subvector(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Copy a contiguous subvector of a random vector.
            </summary>
      <param name="source">Random vector</param>
      <param name="startIndex">Index of the first element to copy</param>
      <param name="count">Number of elements to copy</param>
      <returns>A new vector variable whose value is equal to <c>Vector.Subvector(source, startIndex, count)</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItem(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Copy an element of a vector.
            </summary>
      <param name="source">Random vector.</param>
      <param name="index">Index of the element to copy.</param>
      <returns>A new double variable equal to <c>source[index]</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Copy``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Returns a copy of the argument
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="x">variable to copy.</param>
      <returns>A new variable that is constrained to equal the argument.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Copy``1(MicrosoftResearch.Infer.Models.VariableArray{``0})">
      <summary>
            Copy an array
            </summary>
      <typeparam name="T">The domain type of an array element.</typeparam>
      <param name="array">array to copy.</param>
      <returns>A new array that is constrained to equal the argument.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Copy``1(MicrosoftResearch.Infer.Models.VariableArray{MicrosoftResearch.Infer.Models.VariableArray{``0},``0[][]})">
      <summary>
            Copy an array
            </summary>
      <typeparam name="T">The domain type of an array element.</typeparam>
      <param name="array">array to copy.</param>
      <returns>A new array that is constrained to equal the argument.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Copy``2(MicrosoftResearch.Infer.Models.VariableArray{MicrosoftResearch.Infer.Models.VariableArray{``0,``1},``1[]})">
      <summary>
            Copy an array
            </summary>
      <typeparam name="TItem">The item prototype</typeparam>
      <typeparam name="T">The domain type of an array element.</typeparam>
      <param name="array">array to copy.</param>
      <returns>A new array that is constrained to equal the argument.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Cut``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Returns a cut of the argument. Cut is equivalent to random(infer()).
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="x">variable to copy.</param>
      <returns>A new variable that is constrained to equal the argument.</returns>
      <remarks>Cut allows forward messages to pass through unchanged, whereas backward messages are cut off.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Replicate``1(MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Replicates a value multiple times.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="value">The value to replicate.</param>
      <param name="range">The range used to index the output array.</param>
      <returns>The array of replicated values.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Replicate``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Replicates an array multiple times.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">The array to replicate.</param>
      <param name="range">The range used to index the output array.</param>
      <returns>The array of replicated arrays.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Replicate``1(MicrosoftResearch.Infer.Models.VariableArray{MicrosoftResearch.Infer.Models.VariableArray{``0},``0[][]},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Replicates an array multiple times.
            </summary>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">The array to replicate.</param>
      <param name="range">The range used to index the output array.</param>
      <returns>The array of replicated arrays.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Replicate``2(MicrosoftResearch.Infer.Models.VariableArray{MicrosoftResearch.Infer.Models.VariableArray{``0,``1},``1[]},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Replicates an array multiple times.
            </summary>
      <typeparam name="TItem">The element variable type.</typeparam>
      <typeparam name="T">The domain type.</typeparam>
      <param name="array">The array to replicate.</param>
      <param name="range">The range used to index the output array.</param>
      <returns>The array of replicated arrays.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing different items of a source array.
            </summary>
      <typeparam name="T">The domain type of array elements.</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  The indices must all be different.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            To allow duplicate indices, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" />.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{``0}},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing different items of a source list
            </summary>
      <typeparam name="T">The domain type of array elements.</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  The indices must all be different.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            To allow duplicate indices, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" />.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing different items of a source list
            </summary>
      <typeparam name="T">The domain type of array elements.</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  The indices must all be different.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            To allow duplicate indices, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" />.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.VariableArray{MicrosoftResearch.Infer.Models.Variable{System.Int32},System.Collections.Generic.IList{System.Int32}})">
      <summary>
            Gets a variable array containing different items of a source list.
            </summary>
      <typeparam name="T">The domain type of array elements.</typeparam>
      <param name="array">The source array.</param>
      <param name="indices">Variable array containing the indices of the elements to get.  The indices must all be different.</param>
      <returns>variable array with the specified items.</returns>
      <remarks>
            To allow duplicate indices, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" />.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Subarray``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing different items of a source list
            </summary>
      <typeparam name="TItem">The inner variable type</typeparam>
      <typeparam name="T">The domain type of array elements</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  The indices must all be different.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            To allow duplicate indices, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" />.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ReplaceRanges``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Create a new array like 'array' but where the first range is changed to indices.Range
            </summary>
      <typeparam name="TItem">
      </typeparam>
      <typeparam name="T">
      </typeparam>
      <param name="array">
      </param>
      <param name="indices">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing (possibly duplicated) items of a source array
            </summary>
      <typeparam name="T">The domain type of array elements</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  Indices may be duplicated.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            If the indices are known to be all different, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" /> for greater efficiency.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.Variable{System.Collections.Generic.IList{``0}},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing (possibly duplicated) items of a source array
            </summary>
      <typeparam name="T">The domain type of array elements</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  Indices may be duplicated.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            If the indices are known to be all different, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" /> for greater efficiency.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItems``1(MicrosoftResearch.Infer.Models.VariableArray{``0},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing (possibly duplicated) items of a source array
            </summary>
      <typeparam name="T">The domain type of array elements</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  Indices may be duplicated.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            If the indices are known to be all different, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" /> for greater efficiency.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItems``2(MicrosoftResearch.Infer.Models.VariableArray{``0,``1[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})">
      <summary>
            Gets a variable array containing (possibly duplicated) items of a source array
            </summary>
      <typeparam name="TItem">The inner variable type</typeparam>
      <typeparam name="T">The domain type of array elements</typeparam>
      <param name="array">The source array</param>
      <param name="indices">Variable array containing the indices of the elements to get.  Indices may be duplicated.</param>
      <returns>variable array with the specified items</returns>
      <remarks>
            If the indices are known to be all different, use <see cref="M:MicrosoftResearch.Infer.Models.Variable.Subarray``1(MicrosoftResearch.Infer.Models.Variable{``0[]},MicrosoftResearch.Infer.Models.VariableArray{System.Int32})" /> for greater efficiency.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Char(MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Maths.Vector})">
      <summary>
            Creates a character random variable defined by a discrete distribution induced by a given probability vector.
            </summary>
      <param name="probabilities">The probability vector.</param>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharUniform">
      <summary>
            Creates a character random variable from a uniform distribution over all possible characters.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharLower">
      <summary>
            Creates a character random variable from a uniform distribution over lowercase letters 'a'..'z'.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharUpper">
      <summary>
            Creates a character random variable from a uniform distribution over uppercase letters 'A'..'Z'.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharLetter">
      <summary>
            Creates a character random variable from a uniform distribution over letters in 'a'..'z' and 'A'..'Z'.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharDigit">
      <summary>
            Creates a character random variable from a uniform distribution over digits '0'..'9'.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharLetterOrDigit">
      <summary>
            Creates a character random variable from a uniform distribution over 'a'..'z', 'A'..'Z' and '0'..'9'.
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharWord">
      <summary>
            Creates a character random variable from a uniform distribution over word characters
            ('a'..'z', 'A'..'Z', '0'..'9', '_' and '\'').
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharNonWord">
      <summary>
            Creates a character random variable from a uniform distribution over all characters except
            ('a'..'z', 'A'..'Z', '0'..'9', '_' and '\'').
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CharWhitespace">
      <summary>
            Creates a character random variable from a uniform distribution over whitespace characters
            ('\t'..'\r', ' ').
            </summary>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringUniform">
      <summary>
            Creates a string random variable from a uniform distribution over all possible strings.
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLower">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of lowercase letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLower" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLower(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of lowercase letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLower" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringUpper">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of uppercase letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharUpper" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringUpper(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of uppercase letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharUpper" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLetters">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLetter" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLetters(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of letters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLetter" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringDigits">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of digits (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharDigit" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringDigits(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of digits (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharDigit" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLettersOrDigits">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of letters or digits (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLetterOrDigit" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringLettersOrDigits(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of letters or digits (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharLetterOrDigit" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringWhitespace">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of whitespace characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharWhitespace" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringWhitespace(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of whitespace characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharWhitespace" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringWord">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of word characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharWord" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringWord(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of word characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharWord" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringNonWord">
      <summary>
            Creates a string random variable from a uniform distribution over all non-empty strings
            of non-word characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharNonWord" />).
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringNonWord(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            of non-word characters (see <see cref="M:MicrosoftResearch.Infer.Models.Variable.CharNonWord" />) with length in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length
            .</param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringCapitalized">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            consisting of an uppercase letter followed by one or more lowercase letters.
            </summary>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringCapitalized(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings
            consisting of an uppercase letter followed by one or more lowercase letters, with length in specified bounds.
            </summary>
      <param name="minLength">The minimum possible string length. Should be 2 or more.</param>
      <param name="maxLength">The maximum possible string length.
            If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringOfLength(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings of given length.
            </summary>
      <param name="length">The desired string length.</param>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringOfLength(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Distributions.DiscreteChar})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings of given length.
            String characters are restricted to be non zero probability characters under the given character distribution.
            </summary>
      <param name="length">The desired string length.</param>
      <param name="allowedCharacters">The distribution specifying the allowed string characters.</param>
      <returns>The created random variable.</returns>
      <remarks>The resulting random variable has an improper distribution.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.String(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings with length
            in given bounds.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.String(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{MicrosoftResearch.Infer.Distributions.DiscreteChar})">
      <summary>
            Creates a string random variable from a uniform distribution over all strings with length
            in given bounds. String characters are restricted to be non zero probability characters under the given character distribution.
            </summary>
      <param name="minLength">The minimum possible string length.</param>
      <param name="maxLength">
            The maximum possible string length. If <see langword="null" />, there will be no upper limit on length.
            </param>
      <param name="allowedCharacters">The distribution specifying the allowed string characters.</param>
      <returns>The created random variable.</returns>
      <remarks>
            If <paramref name="maxLength" /> is set to <see langword="null" />,
            the resulting random variable has an improper distribution.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringFromArray(MicrosoftResearch.Infer.Models.VariableArray{System.Char})">
      <summary>
            Creates a string random variable from an array of characters.
            </summary>
      <param name="chars">The array of characters.</param>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Substring(MicrosoftResearch.Infer.Models.Variable{System.String},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a string random variable which is a substring of a given string.
            </summary>
      <param name="str">The string.</param>
      <param name="start">The substring start index.</param>
      <param name="length">The substring length.</param>
      <returns>The created random variable for the substring of <paramref name="str" />.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringFormat(MicrosoftResearch.Infer.Models.Variable{System.String},MicrosoftResearch.Infer.Models.Variable{System.String}[])">
      <summary>
            Replaces argument placeholders such as {0}, {1} etc with arguments having the corresponding index,
            similar to what <see cref="M:System.String.Format(System.String,System.Object[])" /> does.
            </summary>
      <param name="format">The string with argument placeholders.</param>
      <param name="args">The array of arguments.</param>
      <returns>
        <paramref name="format" /> with argument placeholders replaced by arguments.</returns>
      <remarks>
            This method has the following notable differences from <see cref="M:System.String.Format(System.String,System.Object[])" />:
            <list type="bullet"></list><item><description>Placeholder for each of the arguments must be present in the format string exactly once.</description></item><item><description>No braces are allowed except for those used to specify placeholders.</description></item></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.StringFormat(MicrosoftResearch.Infer.Models.Variable{System.String},MicrosoftResearch.Infer.Models.VariableArray{System.String})">
      <summary>
            Replaces argument placeholders such as {0}, {1} etc with arguments having the corresponding index,
            similar to what <see cref="M:System.String.Format(System.String,System.Object[])" /> does.
            </summary>
      <param name="format">The string with argument placeholders.</param>
      <param name="args">The array of arguments.</param>
      <returns>
        <paramref name="format" /> with argument placeholders replaced by arguments.</returns>
      <remarks>
            This method has the following notable differences from <see cref="M:System.String.Format(System.String,System.Object[])" />:
            <list type="bullet"></list><item><description>Placeholder for each of the arguments must be present in the format string exactly once.</description></item><item><description>No braces are allowed except for those used to specify placeholders.</description></item></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetItem(MicrosoftResearch.Infer.Models.Variable{System.String},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Creates a character random variable representing the character on a given position inside a given string.
            </summary>
      <param name="str">The string.</param>
      <param name="position">The character position.</param>
      <returns>The created random variable.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainTrue(MicrosoftResearch.Infer.Models.Variable{System.Boolean})">
      <summary>
            Constrains a boolean variable to be true.
            </summary>
      <param name="v">The variable to constrain to be true</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainFalse(MicrosoftResearch.Infer.Models.Variable{System.Boolean})">
      <summary>
            Constrains a boolean variable to be false.
            </summary>
      <param name="v">The variable to constrain to be false</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainPositive(MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Constrains a double variable to be positive.
            </summary>
      <param name="v">The variable to constrain to be positive</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainBetween(MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Constrains a double variable to be between two limits.
            </summary>
      <param name="x">The variable to constrain</param>
      <param name="lowerBound">The lower limit</param>
      <param name="upperBound">The upper limit</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqual``1(MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Constrains two variables to be equal.
            </summary>
      <typeparam name="T">The type of the variables</typeparam>
      <param name="a">The first variable</param>
      <param name="b">The second variable</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqual``1(``0,MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Constrains a variable to equal a constant value.
            </summary>
      <typeparam name="T">The type of the variable</typeparam>
      <param name="a">The constant value</param>
      <param name="b">The variable</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqual``1(MicrosoftResearch.Infer.Models.Variable{``0},``0)">
      <summary>
            Constrains a variable to equal a constant value.
            </summary>
      <typeparam name="T">The type of the variable</typeparam>
      <param name="a">The variable</param>
      <param name="b">The constant value</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqualRandom``2(MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Constrains a variable to be equal to a random sample from a distribution.
            </summary>
      <typeparam name="T">The variable type</typeparam>
      <typeparam name="TDist">The distribution type</typeparam>
      <param name="a">The variable to constrain</param>
      <param name="b">The distribution</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqualRandom``2(``0,MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Constrains a value to be equal to a random sample from a distribution.
            </summary>
      <typeparam name="T">The variable type</typeparam>
      <typeparam name="TDist">The distribution type</typeparam>
      <param name="a">The variable to constrain</param>
      <param name="b">The distribution</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.ConstrainEqualRandom``2(MicrosoftResearch.Infer.Models.Variable{``0},``1)">
      <summary>
            Constrains a variable to be equal to a random sample from a known distribution.
            </summary>
      <typeparam name="T">The variable type</typeparam>
      <typeparam name="TDist">The distribution type</typeparam>
      <param name="a">The variable to constrain</param>
      <param name="b">The distribution</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Potts(MicrosoftResearch.Infer.Models.Variable{System.Boolean},MicrosoftResearch.Infer.Models.Variable{System.Boolean},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Adds a Potts factor between two boolean variables (max product only!).
            </summary>
      <remarks>
            This factor has the value of 1 if a==b and exp(-logCost) otherwise.</remarks>
      <param name="a">The first bool variable</param>
      <param name="b">The second bool variable</param>
      <param name="logCost">The negative log cost if the variables are not equal</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Potts(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Adds a Potts factor between two int variables (max product only!).
            </summary>
      <remarks>
            This factor has the value of 1 if a==b and exp(-logCost) otherwise.</remarks>
      <param name="a">The first int variable</param>
      <param name="b">The second int variable</param>
      <param name="logCost">The negative log cost if the variables are not equal</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Linear(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Adds a linear factor between two int variables (max product only!).
            </summary>
      <remarks>
            This factor has the value of exp( -|a-b|* logUnitCost ).</remarks>
      <param name="a">The first int variable</param>
      <param name="b">The second int variable</param>
      <param name="logUnitCost">The negative log cost per unit absolute different between the variables</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.LinearTrunc(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Double},MicrosoftResearch.Infer.Models.Variable{System.Double})">
      <summary>
            Adds a truncated linear factor between two int variables (max product only!).
            </summary>
      <remarks>
            This factor has the value of exp( - min( |a-b|* logUnitCost, maxCost) )).</remarks>
      <param name="a">The first int variable</param>
      <param name="b">The second int variable</param>
      <param name="logUnitCost">The negative log cost per unit absolute different between the variables</param>
      <param name="maxCost">The maximum negative log cost</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.GetOperatorArity(MicrosoftResearch.Infer.Models.Operator)">
      <summary>
            Gets the number of parameters of a given operator.
            </summary>
      <param name="op">The operator.</param>
      <returns>The number of parameters of the operator.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.RegisterOperatorFactor(MicrosoftResearch.Infer.Models.Operator,System.Delegate)">
      <summary>
            Registers a factor method against a particular operator.
            </summary>
      <param name="op">The operator to register against</param>
      <param name="factorMethod">The factor method to register</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.LookupOperatorFactor(MicrosoftResearch.Infer.Models.Operator,System.Type[])">
      <summary>
            Retrieves the factor method for a given operator and parameter types.
            </summary>
      <param name="op">The operator.</param>
      <param name="parameterTypes">The types of the parameters.</param>
      <returns>The retrieved factor method, or <see langword="null" /> if no suitable method found.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.If(MicrosoftResearch.Infer.Models.Variable{System.Boolean})">
      <summary>
            Opens a stochastic if statement, active when the argument is true.  
            </summary>
      <remarks>
            This method should be used as the argument to a using() statement,
            so that the if statement is automatically closed.  If this is not possible, 
            the returned IfBlock must be closed manually by calling CloseBlock().
            </remarks>
      <param name="b">The condition of the if block</param>
      <returns>An IfBlock object which must be closed before inference is performed.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.IfNot(MicrosoftResearch.Infer.Models.Variable{System.Boolean})">
      <summary>
            Opens a stochastic if statement, active when the argument is false.  
            </summary>
      <remarks>
            This method should be used as the argument to a using() statement,
            so that the if statement is automatically closed.  If this is not possible, 
            the returned IfBlock must be closed manually by calling CloseBlock().
            </remarks>
      <param name="b">The condition of the if block</param>
      <returns>An IfBlock object which must be closed before inference is performed.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Case(MicrosoftResearch.Infer.Models.Variable{System.Int32},System.Int32)">
      <summary>
            Opens a stochastic case statement, active when the integer argument has the specified value.  
            </summary>
      <remarks>
            This method should be used as the argument to a using() statement,
            so that the if statement is automatically closed.  If this is not possible, 
            the returned CaseBlock must be closed manually by calling CloseBlock().
            </remarks>
      <param name="i">The condition of the case block</param>
      <param name="value">The value of the condition for which the block is active</param>
      <returns>A CaseBlock object which must be closed before inference is performed.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.CloseAllBlocks">
      <summary>
            Close blocks in order to recover from exceptions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable.Switch(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Opens a stochastic switch statement using the specified condition variable.  This is equivalent
            to creating a set of identical Variable.Case() statements for each value of i.  Within a switch block,
            you can use the variable i as an array index.
            </summary>
      <remarks>
            This method should be used as the argument to a using() statement,
            so that the if statement is automatically closed.  If this is not possible, 
            the returned SwitchBlock must be closed manually by calling CloseBlock().
            </remarks>
      <param name="i">The condition of the switch block</param>
      <returns>A SwitchBlock object which must be closed before inference is performed.</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.NameInGeneratedCode">
      <summary>
            Name used in generated code
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.Definition">
      <summary>
            Gets the definition of this variable in the current context.  Will return
            null if the variable is undefined or if it is only defined in a subcontext (such as an If or Switch).
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsDefined">
      <summary>
            True if the variable is defined in the current condition context.
            </summary>
      <remarks>
            Suppose we have x.SetTo(def) inside [c==0][d==0]
            Then x.IsDefined is true inside [c==0][d==0], [c==0][d==0][e==0], [c==0], and nothing.
            x.IsDefined is false inside [c==0][d==1] and [c==1].
            In other words, x.IsDefined is true when the current condition context is a prefix of the definition context,
            or when the definition context is a prefix of the current condition context.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsObserved">
      <summary>
            Is Observed property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsReadOnly">
      <summary>
            Read only property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.Inline">
      <summary>
            Temporary property to allow variables to be used as expressions.  Setting
            this true, means that wherever the variable is used, its definition will be substituted instead.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.Containers">
      <summary>
            The loops and conditionals this variable is contained in
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsReplicated">
      <summary>
            True if the variable was created inside a ForEachBlock.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.ArrayVariable">
      <summary>
            The array that this variable is an element of (otherwise null).
            </summary>
      <remarks>
            This array may be created implicitly by applying ForEach to a variable.  In that case, the variable
            becomes an element of a fresh array.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsArrayElement">
      <summary>
            Whether this variable is an element of an array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable.IsBase">
      <summary>
            Return true if a base variable, false if derived
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.Variable`1">
      <summary>
            A typed variable in a model.
            </summary>
      <typeparam name="T">The domain of the variable.</typeparam>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.isReadOnly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.observedValue">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.Count">
      <summary>
            Global counter used to generate variable names.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.CountLock">
      <summary>
            Counter lock
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.Variable`1.declaration">
      <summary>
            Cache of GetDeclaration.  Stores the name and type of the variable.
            </summary>
      <remarks>
            Always null for derived variables.
            The declaration must be cached because we later use reference equality between declarations.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Implicit(`0)~MicrosoftResearch.Infer.Models.Variable{`0}">
      <summary>
            Provides implicit conversion from .NET instances to constant Infer.NET variables.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.ClearObservedValue">
      <summary>
            Clear the observed value.
            </summary>
      <remarks>Calling this method sets the <see cref="P:MicrosoftResearch.Infer.Models.Variable`1.IsReadOnly" /> and <see cref="P:MicrosoftResearch.Infer.Models.Variable.IsObserved" /> flags to false.
            This cannot be called for array items. </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.#ctor(MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Clone">
      <summary>
            Clone this variable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.SetTo(MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Sets the value of a random variable.  Should only be invoked on variables created using New() which 
            do not yet have a value.
            </summary>
      <param name="variable">A variable whose definition will be consumed by <c>this</c> and no longer available for use</param>
      <remarks>
        <paramref name="variable" /> must have exactly the same set of ranges as <c>this</c>.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.RemovedBySetTo">
      <summary>
            A special factor attached to variables whose definition was consumed by SetTo().
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.SetTo(System.Reflection.MethodInfo,MicrosoftResearch.Infer.Models.IModelExpression[])">
      <summary>
            Set the parent factor of the variable.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.SetTo(MicrosoftResearch.Infer.Models.MethodInvoke)">
      <summary>
            Set the parent factor of the variable.
            </summary>
      <param name="methodInvoke">The parent factor and its arguments.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.CreateVariableArrayFromItem(MicrosoftResearch.Infer.Models.Variable{`0},System.Collections.Generic.IList{MicrosoftResearch.Infer.Models.Range})">
      <summary>
            Creates a variable array with the given ranges and modify item to be an item of that array, keeping the same definition.
            </summary>
      <param name="item">
      </param>
      <param name="ranges">
      </param>
      <returns>
      </returns>
      <remarks>
            Only the definition and containers of item are used.  item.array and item.indices are ignored.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.MakeItem(MicrosoftResearch.Infer.Models.IVariableArray,MicrosoftResearch.Infer.Models.IModelExpression[])">
      <summary>
            Modify the variable to be an element of an array, keeping the same definition.
            </summary>
      <param name="varArray">
      </param>
      <param name="inds">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.SetDeclaration(System.Object)">
      <summary>
            Change the declaration of the variable if none has been set yet.
            </summary>
      <param name="declaration">
      </param>
      <returns>True if the declaration was changed, false otherwise.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Named(System.String)">
      <summary>
            Set the name of the variable.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a variable.  This method
            returns the variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Attrib(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseTo``1(``0)">
      <summary>
            Provide a marginal distribution to initialize inference.
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialMarginal">
      </param>
      <returns>
        <c>this</c>
      </returns>
      <remarks>Only relevant for iterative algorithms.  May be ignored by some inference algorithms.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseTo``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Provide a marginal distribution to initialize inference.
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialMarginal">
      </param>
      <returns>
        <c>this</c>
      </returns>
      <remarks>Only relevant for iterative algorithms.  May be ignored by some inference algorithms.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseTo``1(MicrosoftResearch.Infer.Models.IModelExpression{``0})">
      <summary>
            Set the initialiseTo field if it is valid to do so
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialMarginal">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseBackwardTo``1(``0)">
      <summary>
            Provide a backward distribution to initialize inference.
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialBackward">
      </param>
      <returns>
        <c>this</c>
      </returns>
      <remarks>Only relevant for iterative algorithms.  May be ignored by some inference algorithms.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseBackwardTo``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Provide a backward distribution to initialize inference.
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialBackward">
      </param>
      <returns>
        <c>this</c>
      </returns>
      <remarks>Only relevant for iterative algorithms.  May be ignored by some inference algorithms.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.InitialiseBackwardTo``1(MicrosoftResearch.Infer.Models.IModelExpression{``0})">
      <summary>
            Set the initialiseBackwardTo field if it is valid to do so
            </summary>
      <typeparam name="TDist">
      </typeparam>
      <param name="initialBackward">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.AllIndicesAreRanges">
      <summary>
            Returns true if this is not an array element or all indices are ranges
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.ForEach(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create multiple variables with the same definition.
            </summary>
      <param name="range">The desired range.</param>
      <returns>
        <c>this</c>, modified to range over the newly created items.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.ForEach(MicrosoftResearch.Infer.Models.Range[])">
      <summary>
            Create multiple variables with the same definition.
            </summary>
      <param name="ranges">The desired ranges.</param>
      <returns>
        <c>this</c>, modified to range over the newly created items.</returns>
      <remarks>
        <list type="bullet">
          <item>
            <c>Variable.Bernoulli(0.3).ForEach(r)</c> returns a VariableArray&lt;bool&gt;
            </item>
          <item>
            <c>Variable.Bernoulli(a[r1]).ForEach(r2)</c> returns a VariableArray2D&lt;bool&gt;
            or VariableArray&lt;VariableArray&lt;bool&gt;,bool[][]&gt; depending on whether the
            size of r2 depends on r1.
            </item>
          <item>
            <c>Variable.Bernoulli(a[r1][r2]).ForEach(r3)</c> returns a 
            VariableArray&lt;VariableArray2D&lt;bool&gt;,bool[][,]&gt; 
            or 3-deep jagged VariableArray depending on whether the size of r3 depends on r2.
            </item>
        </list>
      </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Array(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Create a 1D random variable array with a specified size.
            </summary>
      <param name="r">
            A <c>Range</c> object that specifies the array length. 
            </param>
      <returns>
            Returns a <c>VariableArray</c> object whose size is specified by <paramref name="r" />.
            </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Random``1(MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Creates a random variable with the specified prior distribution
            </summary>
      <typeparam name="TDist">The type of the distribution</typeparam>
      <param name="dist">The distribution to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor(MicrosoftResearch.Infer.Factors.FactorMethod{`0})">
      <summary>
            Creates a random variable from a factor method with no arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``1(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0},MicrosoftResearch.Infer.Models.Variable{``0})">
      <summary>
            Creates a random variable from a factor method with one argument.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``1(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0},``0)">
      <summary>
            Creates a random variable from a factor method with one argument.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``2(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Creates a random variable from a factor method with two arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">
      </param>
      <param name="arg2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``2(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1},``0,MicrosoftResearch.Infer.Models.Variable{``1})">
      <summary>
            Creates a random variable from a factor method with two arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Fixed first argument</param>
      <param name="arg2">Variable second argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``2(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1},MicrosoftResearch.Infer.Models.Variable{``0},``1)">
      <summary>
            Creates a random variable from a factor method with two arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Fixed second argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``2(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1},``0,``1)">
      <summary>
            Creates a random variable from a factor method with two arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Variable second argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1},MicrosoftResearch.Infer.Models.Variable{``2})">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Variable second argument</param>
      <param name="arg3">Variable third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},``0,MicrosoftResearch.Infer.Models.Variable{``1},MicrosoftResearch.Infer.Models.Variable{``2})">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Fixed first argument</param>
      <param name="arg2">Variable second argument</param>
      <param name="arg3">Variable third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},``0,``1,MicrosoftResearch.Infer.Models.Variable{``2})">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Fixed first argument</param>
      <param name="arg2">Fixed second argument</param>
      <param name="arg3">Variable third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},``0,MicrosoftResearch.Infer.Models.Variable{``1},``2)">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Fixed first argument</param>
      <param name="arg2">Variable second argument</param>
      <param name="arg3">Fixed third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},MicrosoftResearch.Infer.Models.Variable{``0},``1,MicrosoftResearch.Infer.Models.Variable{``2})">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Fixed second argument</param>
      <param name="arg3">Variable third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1},``2)">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Variable second argument</param>
      <param name="arg3">Fixed third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},MicrosoftResearch.Infer.Models.Variable{``0},``1,``2)">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Fixed second argument</param>
      <param name="arg3">Fixed third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``3(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2},``0,``1,``2)">
      <summary>
            Creates a random variable from a factor method with three arguments.
            </summary>
      <param name="factorDelegate">The method that represents the factor</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Fixed second argument</param>
      <param name="arg3">Fixed third argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.Factor``4(MicrosoftResearch.Infer.Factors.FactorMethod{`0,``0,``1,``2,``3},MicrosoftResearch.Infer.Models.Variable{``0},MicrosoftResearch.Infer.Models.Variable{``1},MicrosoftResearch.Infer.Models.Variable{``2},MicrosoftResearch.Infer.Models.Variable{``3})">
      <summary>
            Creates a random variable from a factor method with four arguments.
            </summary>
      <param name="factorDelegate">Factor delegate</param>
      <param name="arg1">Variable first argument</param>
      <param name="arg2">Variable second argument</param>
      <param name="arg3">Variable third argument</param>
      <param name="arg4">Variable fourth argument</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.FactorUntyped(System.Reflection.MethodInfo,MicrosoftResearch.Infer.Models.Variable[])">
      <summary>
            Creates a random variable from a factor
            </summary>
      <param name="methodInfo">The method</param>
      <param name="args">The arguments</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.OperatorUntyped(MicrosoftResearch.Infer.Models.Operator,System.Reflection.MethodInfo,MicrosoftResearch.Infer.Models.Variable[])">
      <summary>
            Creates a random variable from an operator
            </summary>
      <param name="op">The operator</param>
      <param name="methodInfo">The factor method corresponding to the operator</param>
      <param name="args">The method arguments</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Addition(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for addition
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Addition(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for addition
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Subtraction(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for subtraction
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Subtraction(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for subtraction
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Subtraction(`0,MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for subtraction
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Multiply(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for multiplication
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Multiply(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for multiplication
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Multiply(`0,MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for multiplication
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Division(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for division
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Division(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for division
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Division(`0,MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for division
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Modulus(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for modulus
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Modulus(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for modulus
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_GreaterThan(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for greater than
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_GreaterThan(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for greater than
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.GreaterThan(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
      </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.GreaterThanOrEqual(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
      </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for less than or equal
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for less than or equal
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_LessThan(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for less than
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_LessThan(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for less than
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for greater than or equal
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Operator overload for greater than or equal
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Equality(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Returns a new variable that is true when two variables are equal.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>A new variable that is true when a and b are equal.</returns>
      <remarks>
            If you want to test if a variable object points to null, or if two variable objects are the same object, 
            then cast to object first and use reference equality, like so:
            <list type="bullet"><item><c>if((object)var == null) ...</c></item><item><c>if((object)var1 == (object)var2) ...</c></item><item><c>if(object.ReferenceEquals(var1,var2)) ...</c></item></list></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Equality(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Returns a new variable that is true when a variable equals a given value.
            </summary>
      <param name="a">A variable</param>
      <param name="b">A value</param>
      <returns>A new variable that is true when a equals b.</returns>
      <remarks>
            If you want to test if a variable object points to null,
            then cast to object first and use reference equality, like so:
            <c>if((object)var == null) ...</c></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Inequality(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Returns a new variable that is true when two variables are not equal.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>A new variable that is true when a and b are not equal.</returns>
      <remarks>
            If you want to test if a variable object does not point to null, or if two variable objects are not the same object, 
            then cast to object first and use reference equality, like so:
            <list type="bullet"><item><c>if((object)var != null) ...</c></item><item><c>if((object)var1 != (object)var2) ...</c></item><item><c>if(!object.ReferenceEquals(var1,var2)) ...</c></item></list></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_Inequality(MicrosoftResearch.Infer.Models.Variable{`0},`0)">
      <summary>
            Returns a new variable that is true when a variable does not equal a given value.
            </summary>
      <param name="a">A variable</param>
      <param name="b">A value</param>
      <returns>A new variable that is true when a does not equal b.</returns>
      <remarks>
            If you want to test if a variable object does not point to null,
            then cast to object first and use reference equality, like so:
            <c>if((object)var != null) ...</c></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_LogicalNot(MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for NOT
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_BitwiseOr(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for OR
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_BitwiseAnd(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for AND
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_ExclusiveOr(MicrosoftResearch.Infer.Models.Variable{`0},MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for XOR
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_OnesComplement(MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for NOT
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.Variable`1.op_UnaryNegation(MicrosoftResearch.Infer.Models.Variable{`0})">
      <summary>
            Operator overload for unary negation
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable`1.IsReadOnly">
      <summary>
            Read only property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable`1.ObservedValue">
      <summary>
            Observed value property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.Variable`1.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.Operator">
      <summary>
            Enumeration over supported operators.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariableArray">
      <summary>
            Interface to a multidimensional array of variables.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.IVariableArray.ReplaceRanges(System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range},System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IModelExpression},System.Boolean)">
      <summary>
            Create a clone of this array with ranges and size expressions replaced
            </summary>
      <param name="rangeReplacements">Ranges to replace</param>
      <param name="expressionReplacements">Size expressions to replace</param>
      <param name="deepCopy">If true, clones all item prototypes, otherwise they are not cloned</param>
      <returns>A new array</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray.Ranges">
      <summary>
            List of ranges associated with the array
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariableArray`1">
      <summary>
            Interface to an array of variables.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray`1.Range">
      <summary>
            Range for variable array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray`1.Item(MicrosoftResearch.Infer.Models.IModelExpression)">
      <summary>
            Sets/Gets element in array given by index expression
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.HasItemVariables">
      <summary>
            Interface for an object having item variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.HasItemVariables.GetItemsUntyped">
      <summary>
            Gets the items
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariableJaggedArray">
      <summary>
            Interface to a jagged array of variables
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableJaggedArray.ItemPrototype">
      <summary>
            Item prototype
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArrayBase`2">
      <summary>
            Represents a jagged variable array of arbitrary rank
            </summary>
      <typeparam name="TItem">The item variable type.</typeparam>
      <typeparam name="TArray">The domain type of the array.</typeparam>
      <remarks>
            TItem is either a VariableArray&lt;T&gt; or another VariableArray&lt;,&gt;
            </remarks>
      <exclude />
    </member>
    <member name="F:MicrosoftResearch.Infer.Models.VariableArrayBase`2.items">
      <summary>
            All item variables referring to this array.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArrayBase`2.#ctor(MicrosoftResearch.Infer.Models.VariableArrayBase{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="array">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArrayBase`2.GetItem(MicrosoftResearch.Infer.Models.VariableArrayBase{`0,`1},`0,MicrosoftResearch.Infer.Models.IModelExpression[])">
      <summary>
            Get a random variable representing an item of an array.
            </summary>
      <param name="array">
      </param>
      <param name="itemPrototype">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArrayBase`2.SetTo(MicrosoftResearch.Infer.Models.VariableArrayBase{`0,`1})">
      <summary>
            Set the variable array to the given value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArrayBase`2.Ranges">
      <summary>
            List of ranges associated with the array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArrayBase`2.Item(MicrosoftResearch.Infer.Models.IModelExpression[])">
      <summary>
      </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArrayBase`2.Item(MicrosoftResearch.Infer.Models.Range[])">
      <summary>
      </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray`2">
      <summary>
            One-dimensional jagged variable array.
            </summary>
      <typeparam name="TItem">Item type</typeparam>
      <typeparam name="TArray">Array type</typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.#ctor(MicrosoftResearch.Infer.Models.VariableArray{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.Named(System.String)">
      <summary>
            Set the name of the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.Attrib(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.SetTo(MicrosoftResearch.Infer.Models.VariableArray{`0,`1})">
      <summary>
            Set the variable array to the given value.  Should only be invoked on arrays created using Variable.Array() 
            where the elements have not yet been filled in.
            </summary>
      <param name="that">A variable array whose definition will be consumed by <c>this</c> and no longer available for use</param>
      <remarks>
        <paramref name="that" /> must have exactly the same set of ranges as <c>this</c>.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`2.Clone">
      <summary>
            Clone the variable array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray`2.Range">
      <summary>
            Range for the array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray`2.Item(MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="range">The range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="range" />.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get a variable element of the array.
            </summary>
      <param name="index">A variable which selects the element.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="index" />.</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray`2.Item(System.Int32)">
      <summary>
            Get an element of the array.
            </summary>
      <param name="index">An integer in [0,array.Length-1]</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="index" />.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray`1">
      <summary>
            One-dimensional flat variable array.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.#ctor(MicrosoftResearch.Infer.Models.VariableArray{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.Named(System.String)">
      <summary>
            Set the name of the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.Attrib(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.SetTo(MicrosoftResearch.Infer.Models.VariableArray{`0})">
      <summary>
            Set the 1-D array to the given value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray`1.Clone">
      <summary>
            Clone the array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariableArray2D`1">
      <summary>
            Interface to a 2D array of variables.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray2D`1.Range0">
      <summary>
            Range for first index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray2D`1.Range1">
      <summary>
            Range for second index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray2D`1.Item(MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IModelExpression)">
      <summary>
            Sets/Gets element in array given by the index expressions
            </summary>
      <param name="index0">First index expression</param>
      <param name="index1">Second index expression</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray2D`2">
      <summary>
            Two-dimensional jagged variable array.
            </summary>
      <typeparam name="TItem">
      </typeparam>
      <typeparam name="TArray">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.#ctor(MicrosoftResearch.Infer.Models.VariableArray2D{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.Named(System.String)">
      <summary>
            Inline method to name the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.Attrib(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.SetTo(MicrosoftResearch.Infer.Models.VariableArray2D{`0,`1})">
      <summary>
            Set the 2-D jagged array to a specified value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`2.Clone">
      <summary>
            Clone the 2-D jagged array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Range0">
      <summary>
            Range for first index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Range1">
      <summary>
            Range for second index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="range0" />,<paramref name="range1" />.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="index0">The first range used to create the array.</param>
      <param name="index1">The second index.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="index0" />,<paramref name="index1" />.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="index0">The first index.</param>
      <param name="index1">The second range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="index0" />,<paramref name="index1" />.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray2D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="index0">The first index.</param>
      <param name="index1">The second index.</param>
      <returns>A derived variable that indexes <c>this</c> by <paramref name="index0" />,<paramref name="index1" />.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray2D`1">
      <summary>
            Two-dimensional flat variable array.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.#ctor(MicrosoftResearch.Infer.Models.VariableArray2D{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.Named(System.String)">
      <summary>
            Set the name of the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.Attrib(MicrosoftResearch.Infer.QueryType)">
      <summary>
            Helper to add a query type attribute to this variable.
            </summary>
      <param name="queryType">The query type to use to create the attribute</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.SetTo(MicrosoftResearch.Infer.Models.VariableArray2D{`0})">
      <summary>
            Set this 2-D array to a specified value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray2D`1.Clone">
      <summary>
            Clone this 2-D array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.IVariableArray3D`1">
      <summary>
            Interface to a 3D array of variables.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray3D`1.Range0">
      <summary>
            Range for first index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray3D`1.Range1">
      <summary>
            Range for second index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray3D`1.Range2">
      <summary>
            Range for third index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.IVariableArray3D`1.Item(MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IModelExpression,MicrosoftResearch.Infer.Models.IModelExpression)">
      <summary>
            Sets/Gets element in array given by the index expressions
            </summary>
      <param name="index0">First index expression</param>
      <param name="index1">Second index expression</param>
      <param name="index2">Second index expression</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray3D`2">
      <summary>
            Three-dimensional jagged variable array.
            </summary>
      <typeparam name="TItem">
      </typeparam>
      <typeparam name="TArray">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`2.#ctor(MicrosoftResearch.Infer.Models.VariableArray3D{`0,`1})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`2.Named(System.String)">
      <summary>
            Set the name of the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`2.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`2.SetTo(MicrosoftResearch.Infer.Models.VariableArray3D{`0,`1})">
      <summary>
            Set the 3-D jagged array to the specified value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`2.Clone">
      <summary>
            Clone the 3-D jagged array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Range0">
      <summary>
            Range for first index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Range1">
      <summary>
            Range for second index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Range2">
      <summary>
            Range for third index
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get or set elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Range)">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Models.VariableArray3D`2.Item(MicrosoftResearch.Infer.Models.Range,MicrosoftResearch.Infer.Models.Variable{System.Int32},MicrosoftResearch.Infer.Models.Variable{System.Int32})">
      <summary>
            Get elements of the array.
            </summary>
      <param name="range0">The first range used to create the array.</param>
      <param name="range1">The second range used to create the array.</param>
      <param name="range2">The third range used to create the array.</param>
      <returns>A derived variable that indexes <c>this</c> by the given ranges.</returns>
      <remarks>
            When setting the elements of an array, the right hand side must be a fresh variable with no other uses.
            The right-hand side must be an item variable indexed by exactly the ranges of the array, but possibly in a different order.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Models.VariableArray3D`1">
      <summary>
            Three-dimensional flat variable array.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`1.#ctor(MicrosoftResearch.Infer.Models.VariableArray3D{`0})">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`1.Named(System.String)">
      <summary>
            Set the name of the array.
            </summary>
      <param name="name">
      </param>
      <returns>
        <c>this</c>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`1.Attrib(MicrosoftResearch.TransformFramework.ICompilerAttribute)">
      <summary>
            Inline method for adding an attribute to a random variable.  This method
            returns the random variable object, so that is can be used in an inline expression.
            e.g. Variable.GaussianFromMeanAndVariance(0,1).Attrib(new MyAttribute());
            </summary>
      <param name="attr">The attribute to add</param>
      <returns>The random variable object</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`1.SetTo(MicrosoftResearch.Infer.Models.VariableArray3D{`0})">
      <summary>
            Set the 3-D array to a specified value
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Models.VariableArray3D`1.Clone">
      <summary>
            Clone the 3-D array
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DebuggingSupport">
      <summary>
            Helper class for providing debugging functionality.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DebuggingSupport.MessageEventName">
      <summary>
            Name of the generated event for message updates.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DebuggingSupport.GetExpressionTextExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Gets an expression for the string form of the supplied expression.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DebuggingSupport.TryAddRemoveEventListenerDynamic(MicrosoftResearch.Infer.IGeneratedAlgorithm,System.EventHandler{MicrosoftResearch.Infer.MessageUpdatedEventArgs},System.Boolean)">
      <summary>
            Tries to dynamically add or remove an event handler to a generated algorithm instance.
            </summary>
      <param name="ca">The generated algorithm instance</param>
      <param name="d">The event handler to add or remove</param>
      <param name="add">If true will add, otherwise will remove</param>
      <returns>True if the event handler was added or removed successfully</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyGraph2">
      <summary>
            For when the input statements have been ordered i.e. after scheduling
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph2.duplicates">
      <summary>
            Maps from a statement to the index of every position it occurs in the schedule (but only if it occurs more than once)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph2.backEdges">
      <summary>
            Maps from a source statement (which has not yet received an index) to the index of its targets
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph2.indexOfNode">
      <summary>
            Maps from a statement to the last position it occurs in the schedule
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter">
      <summary>
            Automatically generates XML documentation for message operators.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper">
      <summary>
            Wraps <see cref="T:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo" />, providing comparison based on factor method equality.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper.#ctor(MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper" /> class.
            </summary>
      <param name="factorInfo">The wrapped factor info.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper.Equals(System.Object)">
      <summary>
            Compares this object with a given one.
            </summary>
      <param name="obj">The object to compare with.</param>
      <returns>
        <see langword="true" /> if the objects are equal, <see langword="false" /> otherwise.</returns>
      <remarks>The two wrappers are considered equal, if they wrap factor info for the same factor method.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper.GetHashCode">
      <summary>
            Computes the hash code of this object.
            </summary>
      <returns>The computed hash code.</returns>
      <remarks>Only the factor method is used to compute the hash code.</remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper.FactorInfo">
      <summary>
            Gets the wrapped factor info.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper">
      <summary>
            Wraps <see cref="T:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo" />, providing comparison based on message operator method equality
            and augmenting message info with the info about a factor it is for.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper.#ctor(MicrosoftResearch.Infer.Transforms.MessageFcnInfo,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper" /> class.
            </summary>
      <param name="messageFunctionInfo">The wrapped message function info.</param>
      <param name="factorInfo">The factor info of a factor the message function is for.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper.Equals(System.Object)">
      <summary>
            Compares this object with a given one.
            </summary>
      <param name="obj">The object to compare with.</param>
      <returns>
        <see langword="true" /> if the objects are equal, <see langword="false" /> otherwise.</returns>
      <remarks>The two wrappers are considered equal, if they wrap message info for the same message function.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper.GetHashCode">
      <summary>
            Computes the hash code of this object.
            </summary>
      <returns>The computed hash code.</returns>
      <remarks>Only the message function method is used to compute the hash code.</remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper.MessageFunctionInfo">
      <summary>
            Gets the wrapped message function info.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper.FactorInfo">
      <summary>
            Gets the information about a factor the message function is for.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteFactorDocumentation(System.String)">
      <summary>
            Writes the XML documentation for all message operators in Infer.Runtime to a given file.
            </summary>
      <param name="fileName">The name of the file to write the documentation to.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteFactorDocumentation(System.Xml.XmlWriter)">
      <summary>
            Writes the XML documentation for all message operators in Infer.Runtime using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteTypeDocumentation(System.Xml.XmlWriter,System.Type,System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.FactorInfoWrapper},System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.MessageFunctionInfoWrapper})">
      <summary>
            Writes the XML documentation for a given type containing message operators using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="type">The type containing the message operators.</param>
      <param name="factors">The list of factor <paramref name="type" /> provides message operators for.</param>
      <param name="messageFunctions">The list of message operators provided by <paramref name="type" />.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMethodReference(System.Xml.XmlWriter,System.Reflection.MethodInfo)">
      <summary>
            Writes a method reference in XML documentation format.
            </summary>
      <param name="writer">The writer.</param>
      <param name="method">The method to reference.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageFunctionDocumentation(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Writes the XML documentation for a given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="factorInfo">The factor the message operator is for.</param>
      <param name="messageFunctionInfo">The message operator.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageOperatorExceptionSpec(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Writes the exception specification section of the XML documentation for a given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="factorInfo">The factor the message operator is for.</param>
      <param name="messageFunctionInfo">The message operator.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageOperatorRemarks(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Writes the remarks section of the XML documentation for a given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="factorInfo">The factor the message operator is for.</param>
      <param name="messageFunctionInfo">The message operator.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageOperatorReturns(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Writes the returns section of the XML documentation for a given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="factorInfo">The factor the message operator is for.</param>
      <param name="messageFunctionInfo">The message operator.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageOperatorParameterDescription(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo,System.Reflection.ParameterInfo)">
      <summary>
            Writes the XML documentation for a parameter of given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="factorInfo">The factor the message operator is for.</param>
      <param name="messageFunctionInfo">The message operator.</param>
      <param name="parameter">The parameter.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.WriteMessageOperatorSummary(System.Xml.XmlWriter,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Writes the summary section of the XML documentation for a given message operator using a given XML writer.
            </summary>
      <param name="writer">The XML writer.</param>
      <param name="messageFunctionInfo">The message operator.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorDocumentationWriter.QuoteCodeElementName(System.String)">
      <summary>
            Quotes a given type or method name so that it can be put in an XML file.
            </summary>
      <param name="name">The code element name to quote.</param>
      <returns>The quoted code element name.</returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.ICodeTransform">
      <summary>
            Code transform interface
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.ICodeTransform.Transform(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            Takes a type declaration and transforms it
            </summary>
      <param name="itd">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.ICodeTransform.Context">
      <summary>
            Context
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.ICodeTransform.Name">
      <summary>
            Name of the transform
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.IExpressionTransform">
      <summary>
            Expression transform interface
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.IExpressionTransform.ConvertExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Takes an expression and transforms it
            </summary>
      <param name="expr">Exression</param>
    </member>
    <member name="P:MicrosoftResearch.Transforms.IExpressionTransform.Context">
      <summary>
            Context
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CopyTransform.context">
      <summary>
            Holds contextual information about the state of the transform which may be used
            to affect the transform.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CopyTransform.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CopyTransform.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CopyTransform.ConvertType(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            Convert a type declaration
            </summary>
      <param name="itd">The type to convert</param>
      <returns>A new type declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CopyTransform.FinishConvertStatement">
      <summary>
            When using OpenOutputBlock, this must be called after converting each statement.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.ShallowCopyTransform">
      <summary>
            A transform which produces a copy where subtrees from the original are reused if they do not change
            and instead of mutating existing nodes, new nodes are created.  Any empty containers are removed.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.ShallowCopyTransform.ConvertBlockAlreadyOpen(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            Shallow copy of BlockStatement
            </summary>
      <param name="inputBlock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LocalTransform">
      <summary>
            Convert array index expressions into local variables where needed
            </summary>
      <remarks>
            The general pattern is that
            for(i) { ...a[i]... }
            is converted into
            for(i) {
              T local = a[i];
              ...local...
              a[i] = local;
            }
            This transformation is only valid when a[i] is the only element of the array accessed in the loop body.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform">
      <summary>
            Determines which array index expressions can be local variables
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.LocalInfo">
      <summary>
            Stores usage information for an array indexer expression
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.localInfoOfStmt">
      <summary>
            Maps an IForStatement to its LocalInfos
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.pendingWrites">
      <summary>
            Stores expressions that have been assigned to but not read yet
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.loopReadBeforeWrite">
      <summary>
            The set of variables read before being written (or not written at all) by the current convergence loop
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.loopWrite">
      <summary>
            The set of variables modified by the current convergence loop
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.GetContainer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            If all indices are loop vars of open containers, then returns any of the containers.  Otherwise returns null.
            </summary>
      <param name="iaie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.AnalyzeArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression,System.Object,System.Boolean,System.Boolean,System.Boolean@)">
      <summary>
            Update the LocalInfo and pendingWrites for an expression
            </summary>
      <param name="iaie">
      </param>
      <param name="target">
      </param>
      <param name="isLhs">
      </param>
      <param name="isPartOfLhs">
      </param>
      <param name="hasReadBeforeWrite">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LocalAnalysisTransform.ProcessPendingWrites(System.Object,System.Int32)">
      <summary>
            Set hasWrite=true for all pending writes whose depth exceeds the given depth
            </summary>
      <param name="target">A variable or parameter declaration</param>
      <param name="depth">The indexing depth of the expression (0 means not indexed)</param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform">
      <summary>
            Reorders and duplicates statements to provide better loop merging, without changing the dependency graph
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.Block">
      <summary>
            Used to number statements in the order that they must appear in the generated code.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.AddExtraBlock(System.Int32,MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.Block,System.Collections.Generic.List{MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.Block}[],System.Boolean,System.Boolean@)">
      <summary>
            Duplicate the node to also appear in the given block
            </summary>
      <param name="node">
      </param>
      <param name="block">
      </param>
      <param name="extraBlocks">
      </param>
      <param name="inSomeLoop">
      </param>
      <param name="changed">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.FindMismatchedLoopIndex(System.Int32,MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.Block,System.Boolean)">
      <summary>
            Find the first loop index where node's membership does not match block, or -1 if node's membership matches block.
            </summary>
      <param name="node">
      </param>
      <param name="block">
      </param>
      <param name="inSomeLoop">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.CheckBlock(MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.Block,System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.LoopInfo},System.Int32)">
      <summary>
            Check that the block has the correct container memberships for node.  Used for debugging.
            </summary>
      <param name="block">
      </param>
      <param name="loops">
      </param>
      <param name="node">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMerging2Transform.DoConvertStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Add the original statement to the output, without transforming.  All attributes of the statement are preserved.
            </summary>
      <param name="ist">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext">
      <summary>
            Represents a repeat context i.e. the set of repeat blocks that an expression occurs in.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.repeats">
      <summary>
            Repeat blocks that contain the expression, outermost first.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.repeatCounts">
      <summary>
            The repeat counts for all contained repeat blocks
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.#ctor(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Creates a repeat context, given the current transform context.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.#ctor(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement})">
      <summary>
            Creates a repeat context, given the current transform context.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.RepeatContext.GetReferenceRepeatContext(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Gets the reference loop context for a reference to a local variable.  A reference loop context
            is the set of loops that a variable reference occurs in, less any loops that the variable declaration
            occurred in.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.RefRepeatContext">
      <summary>
            Represents a reference loop context i.e. the set of loops that a variable reference 
            occurs in, less any loops that the variable declaration occurred in.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.PowerTransform">
      <summary>
            Handles repeat blocks by inserting the appropriate power plate constructs.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.PowerTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            Converts an array index expression to replicate variables referenced in a loop.
            </summary>
      <param name="iaie">The array indexer expression to convert</param>
      <returns>The new expression</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.EqualityPropagationTransform">
      <summary>
            Collapses variables which are statically known to be equal.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.EqualityPropagationTransform.lhs">
      <summary>
            The original lhs expression that we are currently converting, if any
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.EqualityAnalysisTransform">
      <summary>
            Analyses equality constraints.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.EqualityAnalysisTransform.GetNewExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Infer.CompilerAttributes.Containers@)">
      <summary>
            Given an expression appearing in a set of containers, return an equivalent expression and the containers that it is valid in.
            </summary>
      <param name="expr">
      </param>
      <param name="containers">
      </param>
      <param name="exprContainers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.EqualityAnalysisTransform.PropagateDeterministicValues">
      <summary>
            Propagate the expressions attached to observedNodes to all nodes they can reach.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.EqualityAnalysisTransform.ConvertMethodInvoke(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression)">
      <summary>
            Analyse equality constraints, which appear as static method calls to Constrain.Equal
            </summary>
      <param name="imie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.EqualityAnalysisTransform.CreateNodeAndEdges(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates the node (if needed) and adds directed edges to the graph.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ScopedDictionary`3">
      <summary>
            Dictionary where the key-value pairs are contained in a particular scope.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ScopedDictionary`3.TryGetExact(`0,`2,`1@)">
      <summary>
            Tries to get a value in exactly the specifed scope, without inheritance.
            </summary>
      <param name="key">The key for the required value</param>
      <param name="scope">The specified scope</param>
      <param name="value">The value, if any is found or default(TValue)</param>
      <returns>True if a value was found, false otherwise</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ScopedDictionary`3.Add(`0,`1,`2)">
      <summary>
            Adds a key-value pair in the specified scope.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="scope">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ScopedDictionary`3.GetAll(`0)">
      <summary>
            Gets all values associated with the key, in any scope.
            In combination with a Linq Where() clause can be used to filter values by scope.
            </summary>
      <param name="key">The key to retrieve values for</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.NodeInfo">
      <summary>
            Describes an instance of a factor in the program
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.factorExprs">
      <summary>
            Collects all factors (method invokes) in the program
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.factoryVars">
      <summary>
            The variable for each type factory
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.factoryInitExprs">
      <summary>
            Gives the expression used to initialize a factory
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.fwdMessageVars">
      <summary>
            The forward message for a given channel
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.bckMessageVars">
      <summary>
            The backward message for a given channel
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageAnalysisTransform.messageInitExprs">
      <summary>
            Gives the expression used to initialize a message
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.SchedulingTransform">
      <summary>
            Reorders statements within while loops.  Some statements may be copied inside the loop to meet trigger annotations.  
            Some statements may be copied outside the loop to meet requirement (SkipIfUniform) annotations.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.SchedulingTransform.debug">
      <summary>
            Enables debug messages to be generated
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.SchedulingTransform.DoConvertStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Except for while loops, add the original statement to the output, without transforming.  All attributes of the statement are preserved.
            </summary>
      <param name="ist">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.SchedulingTransform.ConvertWhile(MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement)">
      <summary>
            Call Schedule() to reorder the body.
            </summary>
      <param name="iws">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.SchedulingTransform.Schedule(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Boolean,System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Reorder statements within a while loop.
            </summary>
      <param name="outputInit">Statements to place before the loop.</param>
      <param name="outputLoop">Statements to place inside the loop.</param>
      <param name="inputStmts">The input statements in the loop.  If doNotSchedule=false, they must have strongly connected dependencies.</param>
      <param name="doNotSchedule">If true, the statements are added to outputLoop in their original order</param>
      <param name="offsetVarsToDelete">Offset edges on these variables will be deleted prior to scheduling</param>
      <returns>True if the schedule is cyclic, i.e. it needs to be iterated</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.Channel2Transform">
      <summary>
            Transforms variable references into channels, by duplicating variables into uses arrays.  
            A channel is a variable which is assigned once and referenced only once.  
            It corresponds to an edge in a factor graph.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.Channel2Transform.VariableToChannelInformation">
      <summary>
            Records information about the variable to channel transformation.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Channel2Transform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Only converts the contained statements in a for loop, leaving the initializer,
            condition and increment statements unchanged.
            </summary>
      <remarks>This method includes a number of checks to ensure the loop is valid e.g. that the initializer, condition and increment 
            are all of the appropriate form.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Channel2Transform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Converts a variable reference.
            </summary>
      <param name="ivre">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelAnalysisTransform.UsageInfo.ApplyBindings(System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.ConditionBinding},System.Predicate{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Determine if the set of conditions is consistent, i.e. there exists a satisfying assignment
            </summary>
      <param name="bindings">A set of conditions</param>
      <param name="predicate">A heuristic test to use in the search</param>
      <returns>null if inconsistent, an empty list if consistent</returns>
      <remakrs>
            This routine does not search over all assignments.  Rather, it applies substitutions and looks for obvious contradictions.
            If none are found, it declares the conditions to be consistent.
            </remakrs>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ChannelAnalysisTransform.UsageInfo.NumberOfUsesOld">
      <summary>
            Only for backward compatibility with GibbsSampling
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelAnalysisTransform.loopVars">
      <summary>
            The set of all loop variables discovered so far
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelAnalysisTransform.conditionContext">
      <summary>
            The list of bindings made by all conditional statements in the input stack
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelAnalysisTransform.ConvertCondition(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            Analyse the condition body using an augmented conditionContext
            </summary>
      <param name="ics">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ChannelTransform">
      <summary>
            Transforms variable references into channels, by duplicating variables.  
            A channel is a variable which is assigned once and referenced only once.  
            It corresponds to an edge in a factor graph.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ChannelTransform.VariableToChannelInformation">
      <summary>
            Records information about the variable to channel transformation.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Only converts the contained statements in a for loop, leaving the initializer,
            condition and increment statements unchanged.
            </summary>
      <remarks>This method includes a number of checks to ensure the loop is valid e.g. that the initializer, condition and increment 
            are all of the appropriate form.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertVariableDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Converts a variable declaration by creating definition, marginal and uses channel variables.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertArrayCreate(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression)">
      <summary>
            When array creations are assigned to stochastic arrays, this creates corresponding arrays for the marginal and uses channels.
            </summary>
      <param name="iace">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertInfer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression)">
      <summary>
            Modify the argument of Infer to be the marginal channel variable i.e. Infer(a) transforms to Infer(a_marginal).  
            </summary>
      <param name="imie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            Converts an array indexed expression.
            </summary>
      <param name="iaie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelTransform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Converts a variable reference.
            </summary>
      <param name="ivre">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ChannelInfo">
      <summary>
            Describes a channel, i.e. an edge in a factor graph.
            </summary>
      <remarks>
        <para>
            A channel connects a model variable to a factor.
            A channel is either a definition, a use, or a replicated use of a model variable.
            </para>
        <para>
            A definition channel connects a model variable to its unique defining factor.
            A definition channel appears in the inference program as a program variable having the same type as the model variable.
            </para>
        <para>
            A use channel connects a model variable to a child factor.
            A use channel appears in the inference program as an array of the variable type.
            It is indexed via [usage indices][variable indices] where the variable indices are only needed
            if the variable is an array.
            </para>
        <para>
            All uses of a model variable are given the same ChannelInfo and packed into an array in the inference program.
            For example, if a model variable x has type <c>double</c>  and 2 uses, its usage channels will be declared together as <c>double[] x_uses = new double[3];</c> and referred to as x_uses[0] and x_uses[1].
            </para>
        <para>
            The model variable type can be an array, in which case each channel is an array.
            For example, if a model variable x has type <c>double[]</c> and 2 uses, its usage channels will be declared together
            as <c>double[][] x_uses = new double[2][];</c>  and referred to as x_uses[0] and x_uses[1].
            </para>
        <para>
            If the model variable is inside of a plate, then all instances of the channel share the same ChannelInfo and are
            packed into a nested array in the inference program.
            For example, if a model variable x is in a plate of size 3 and has 2 uses, its usage channels will be
            declared together as  <c>double[][] x_uses = new double[2][];</c> and x_uses[0] refers to the first use of x in the plate.
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelInfo.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelInfo.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelInfo.isUsage">
      <summary>
            Flag to distinguish def/use channels.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelInfo.IsMarginal">
      <summary>
            Marks a channel as a marginal 
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelInfo.#ctor(MicrosoftResearch.Infer.CompilerAttributes.VariableInformation)">
      <summary>
            Creates information about a normal uses or defs channel.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelInfo.#ctor(MicrosoftResearch.Infer.CompilerAttributes.VariableInformation,System.Boolean)">
      <summary>
            Creates information about a simple channel.
            There is no outer array.
            The inner array has size given by the varinfo.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ChannelInfo.channelType">
      <summary>
            The type of the channel
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ChannelInfo.IsDef">
      <summary>
            True if the channel is a definition channel.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ChannelInfo.IsUse">
      <summary>
            True if the channel is a usage channel.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IsVariableFactor">
      <summary>
            Attribute used to mark pseudo-factors corresponding to variables in the factor graph
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.HoistingTransform">
      <summary>
            Optimises computation by moving operations computed inside a loop to outside of the loop where possible. 
            PREREQUISITE: 
            Variable declarations must have 'Containers' attributes indicating the containers they belong to.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.HoistingTransform.hoistVarOfInitializer">
      <summary>
            For each variable whose initializer has been hoisted, stores a reference expression for the hoist variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.HoistingTransform.containers">
      <summary>
            Collects containers of expressions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.HoistingTransform.ConvertAssign(MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression)">
      <summary>
            Looks for method invocations where the arguments have fewer indices
            than the LHS of the assignment.
            If the method is pure and not stochastic, then saves computation
            by doing it only once, outside the loops corresponding to the excess indices.
            </summary>
      <param name="iae">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.HoistingTransform.CollapseComputation(MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Infer.CompilerAttributes.Containers,System.Boolean)">
      <summary>
            Define a hoist variable for the rhs and return an assignment of iae.Target to SimpleCopy(hoist)
            </summary>
      <param name="iae">
      </param>
      <param name="rhs">
      </param>
      <param name="loopsToKeep">Always a subset of allLoops</param>
      <param name="allLoops">
      </param>
      <param name="isResultParam">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.HoistingTransform.ConvertVariableDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Record the containers that a variable is declared in.  Must be done in this transform because a loop variable may have many declarations, each in a different container.
            </summary>
      <param name="ivde">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DoesNotHaveInitializer">
      <summary>
            When attached to a message declaration, indicates that the message has no initializer statement, only update statements.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.BrokenLoop">
      <summary>
            When attached to a loop statement, indicates that the loop contains a break or continue statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.Containers.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.Containers.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.Containers.inputs">
      <summary>
            Outermost container is first.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.#ctor(MicrosoftResearch.Transforms.BasicTransformContext,System.Boolean)">
      <summary>
            The containers of the current transform context.
            </summary>
      <param name="context">
      </param>
      <param name="loopVarsHaveOneContainer">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.FindContainers(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Returns a list of the open containers, outermost first.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetMatchingAncestorIndex(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Returns the outermost container in the context that is not in this.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.#ctor">
      <summary>
            An empty container list
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.Contains(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            True if <c>this</c> includes the given container
            </summary>
      <param name="container">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.Contains(MicrosoftResearch.Infer.CompilerAttributes.Containers)">
      <summary>
            True if <c>this</c> includes all of the given containers
            </summary>
      <param name="containers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.Equals(System.Object)">
      <summary>
            Override equality to mean set equality.
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetHashCode">
      <summary>
            Override of hash code to make it match overload of Equals()
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetAncestorIndex(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            The first index in the input stack matching the given container, or -1 if not found.
            </summary>
      <param name="context">
      </param>
      <param name="ancestor">A container</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.ContainersAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            True if the containers match, ignoring the statements in their bodies.
            </summary>
      <param name="st1">
      </param>
      <param name="st2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetContainersNotInContext(MicrosoftResearch.Transforms.BasicTransformContext,System.Int32)">
      <summary>
            Collect all containers that are not in the context at the given index.
            </summary>
      <param name="context">
      </param>
      <param name="ancestorIndex">If 0, all containers are returned.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetLoopsNeededForExpression(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Int32,System.Boolean)">
      <summary>
            Collect all loops in the context whose index is referenced by expr or by the size expression of another collected loop.
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <param name="excludeAncestorIndex">Only loops whose ancestor index is greater than excludeAncestorIndex will be collected.</param>
      <param name="includeConditionals">Include condition statements</param>
      <returns>A list of IForStatements, starting with outermost.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.AddToContainedExpressions(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Adds the expression and any dependent expressions to the supplied list of contained expressions.
            </summary>
      <param name="containedExpressions">
      </param>
      <param name="expr">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.OrderByContext(MicrosoftResearch.Transforms.BasicTransformContext,System.Int32)">
      <summary>
            Reorder containers to follow their order in the input stack.  Also removes duplicates.
            </summary>
      <param name="context">
      </param>
      <param name="start">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetContainersNeededForExpression(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get the minimal set of containers needed for all variables in an expression to be declared.
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.GetContainersNeededForExpression(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Int32@)">
      <summary>
            Get the minimal set of containers needed to evaluate an expression, along with the first index in the context stack at which the expression's variables are all declared.
            </summary>
      <param name="context">The transform context</param>
      <param name="expr">Any expression</param>
      <param name="ancIndex">On exit, the first index in the context stack at which the expression's variables are all declared.</param>
      <returns>The minimal set of containers needed to evaluate expr</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.RemoveUnusedLoops(MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Remove loops (and their dependent containers) that are not needed to evaluate the expression.
            </summary>
      <param name="containers">
      </param>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.RemoveUnusedLoops(MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Infer.CompilerAttributes.Containers)">
      <summary>
            Remove loops (and their dependent containers) that are not needed to evaluate the expression.
            </summary>
      <param name="containers">
      </param>
      <param name="context">
      </param>
      <param name="needed">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.ContainsExpression(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if expr can be evaluated in the given containers, i.e. all local variables are declared.
            </summary>
      <param name="containers">
      </param>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.AddStatementWithContainers(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
      </summary>
      <param name="statementsDest">
      </param>
      <param name="statementsSource">
      </param>
      <param name="containers">Outermost container is first.  The bodies of the containers are ignored.</param>
      <param name="action">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.CreateContainer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Create a clone of prototype with an empty body.
            </summary>
      <param name="prototype">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.Containers.Intersect(MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Infer.CompilerAttributes.Containers)">
      <summary>
            Returns the containers common to both, preserving the order in the first argument.
            </summary>
      <param name="containers">
      </param>
      <param name="containers2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.Containers.Count">
      <summary>
            The number of containers
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.Containers.LoopCount">
      <summary>
            The number of loops
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.Containers.ConditionCount">
      <summary>
            The number of conditionals
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DeadCodeTransform">
      <summary>
            Remove statements whose result is never used.  Attach InitializerSet attribute to while loops.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DeadCodeTransform.DoConvertMethodBody(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
      </summary>
      <param name="outputs">
      </param>
      <param name="inputs">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DeadCodeTransform.DoConvertStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Add the original statement to the output, without transforming.  All attributes of the statement are preserved.
            </summary>
      <param name="ist">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DeadCodeTransform.CollectUses(MicrosoftResearch.Infer.Graphs.IndexedGraph,System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Returns all nodes in the schedule whose target appears prior to the node.
            </summary>
      <param name="g">
      </param>
      <param name="schedule">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DeadCodeTransform.PruneDeadNodesCyclic(MicrosoftResearch.Infer.Transforms.DependencyGraph2,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.ICollection{System.Int32},System.Collections.Generic.ICollection{System.Int32},System.Collections.Generic.List{System.Int32}@)">
      <summary>
            Remove nodes from the cyclic schedule whose result does not reach usedNodes.
            </summary>
      <param name="g">
      </param>
      <param name="schedule">
      </param>
      <param name="usedNodes">On entry, the set of nodes whose value is needed at the end of the schedule.
            On exit, the set of nodes whose value is needed at the beginning of the schedule.</param>
      <param name="usedBySelf">On entry, the set of nodes whose value is used only by itself (due to a cyclic dependency).
            On exit, the set of nodes whose value is used only by itself.</param>
      <param name="tailSchedule">On exit, a special schedule to use for the final iteration.  Empty if the final schedule is the same as the regular schedule.</param>
      <returns>A new schedule.</returns>
      <remarks>
            We cannot simply do a graph search because we want to compute reachability with respect to the nodes 
            that are actually on the schedule.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DeadCodeTransform.PruneDeadNodes(MicrosoftResearch.Infer.Transforms.DependencyGraph2,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.ICollection{System.Int32},System.Collections.Generic.ICollection{System.Int32})">
      <summary>
            Remove nodes from the schedule whose result does not reach usedNodes.
            </summary>
      <param name="g">
      </param>
      <param name="schedule">An ordered list of nodes.</param>
      <param name="usedNodes">On entry, the set of nodes whose value is needed at the end of the schedule.
            On exit, the set of nodes whose value is needed at the beginning of the schedule.</param>
      <param name="usedBySelf">On entry, the set of nodes whose value is used only by itself (due to a cyclic dependency).
            On exit, the set of nodes whose value is used only by itself.</param>
      <returns>A subset of the schedule, in the same order.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.InitializerSet">
      <summary>
            An attribute attached to while loops.  Holds the set of message updates whose outputs are used before being updated by the loop.
            These messages represent the state of the loop from one iteration to the next.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.InitializerSet.initializers">
      <summary>
            Message updates whose outputs are used before being updated by the loop.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform">
      <summary>
            Attaches DependencyInformation attributes to all statements in the input program.
            </summary>
      <remarks>
            Dependency analysis operates in two passes:
            
            1. Each statement is analysed to determine if it declares or mutates a variable or array element.  All
            such declaring/mutating statements are cached against the variable or array declaration element. The mutation
            can be quite complex for jagged arrays. Any previous statement which mutates the same variable as the current
            statement is considered as and marked as an 'allocation' (for example there may be many allocation statements
            defining a jagged array). These previous statements are added as dependencies of the current statement.
            
            Dependencies are marked using a DependencyInformation attribute stored against each statement.  Dependencies
            are represented as either statements or as reference expressions.
            
            2. Using the statement cache prepared above, any expression dependencies are converted into statement
            dependencies by finding all statements which mutate the expression and are not marked as 'allocations'.
            Declaration dependencies are added on statements marked as allocations.
            After this process, all DependencyInformation attributes contain only dependencies on statements.
            </remarks>
      <summary>
            Analyses expressions to determine their dependencies.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation">
      <summary>
            Keeps track of all the times a particular variable is mutated (used for dependency tracking).
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation.RegisterMutationStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Boolean)">
      <summary>
            Registers a statement which mutates the specified expression.
            The statement may be null.
            </summary>
      <param name="expr">
      </param>
      <param name="stmt">
      </param>
      <param name="isAllocation">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation.GetStatementsThatMutate(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean,System.Boolean,System.Collections.Generic.IDictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeRecognizer.Bounds},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Infer.CompilerAttributes.OffsetInfo},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration}})">
      <summary>
            Get all statements that change the value of an expression
            </summary>
      <param name="context">
      </param>
      <param name="exclude">A statement to exclude from the result</param>
      <param name="expr">The expression being changed.  Can contain a call to AllExcept.</param>
      <param name="allocationsOnly">If true, only allocation statements are returned</param>
      <param name="mustMutate">If true, all returned statements are known to mutate.  Otherwise, returned statements are not guaranteed to mutate</param>
      <param name="boundsInExpr">Modified on exit</param>
      <param name="offsetInfos">Modified on exit</param>
      <param name="extraIndicesOfStmt">Modified on exit</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.LoopCounterAttribute">
      <summary>
             Marks variables which are loop counters (since mutation information is not tracked for such variables)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.sequentialOffset">
      <summary>
            Special offset to indicate a sequential increment dependency
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.dependencyInformation">
      <summary>
            The dependency information for the statement being transformed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.dependencyType">
      <summary>
            The dependency type for the expression being transformed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.topLevelParameters">
      <summary>
            The set of parameter declarations for the top-level method being transformed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.mutInfos">
      <summary>
            Records all times that a variable is declared or assigned to
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.CreateDummyStatements(System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Find expressions that have overlapping mutations, and replace these mutations with a dummy statement that depends on all of them.
            </summary>
      <param name="newStatement">Invoked on each new statement</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.CreateDummyStatement(System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation.Mutation},System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Action{MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation.Mutation})">
      <summary>
            Create a new statement that represents all of the given mutations
            </summary>
      <param name="mutations">
      </param>
      <param name="newStatement">
      </param>
      <param name="newMutation">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.GetCommonParent(System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MutationInformation.Mutation})">
      <summary>
            Get an expression whose assignment would change the value of all the given expressions
            </summary>
      <param name="mutations">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.PostProcessDependencies(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Post-process dependencies replacing message expressions with the operator
            blocks that compute them.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Shallow copy of 'for' statement
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.RegisterMutation(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeRecognizer.Bounds})">
      <summary>
            Register the mutation represented by expression expr - this expression might be a
            target of an assignment or of a non-static method, or it might be a variable declaration
            expression. The expression and its top level statement are added to the registry of
            mutating expressions for the associated variable declaration.
            In addition, previous mutations are marked as 'allocations'
            </summary>
      <param name="topLevelStatement">
      </param>
      <param name="expr">An lvalue or assignment (in the case of initialization).</param>
      <param name="bounds">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.ConvertIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Infer.CompilerAttributes.DependencyType)">
      <summary>
            Converts the indices in all brackets of expr, but not the innermost target.
            </summary>
      <param name="expr">An array indexer expression, otherwise does nothing</param>
      <param name="type">the DependencyType to apply</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.MakeAnyStatements(System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Groups statements with the same conditions into AnyStatements (ignoring conditions on loop variables).
            </summary>
      <param name="stmts">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.GetConditions(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Collect all 'if' conditions inside the statement, ignoring loop variable conditions.
            </summary>
      <param name="st">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyAnalysisTransform.GetStatementsThatMutate(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean,System.Boolean,System.Collections.Generic.IDictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeRecognizer.Bounds},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Infer.CompilerAttributes.OffsetInfo},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration}})">
      <summary>
            Get all statements that change the value of an expression
            </summary>
      <param name="exclude">A statement to exclude from the result</param>
      <param name="expr">The expression being changed</param>
      <param name="allocationsOnly">If true, only allocation statements are returned</param>
      <param name="mustMutate">If true, all returned statements are known to mutate.  Otherwise, returned statements are not guaranteed to mutate</param>
      <param name="boundsInExpr">Modified on exit</param>
      <param name="offsetInfos">Modified on exit</param>
      <param name="extraIndicesOfStmt">Modified on exit</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement">
      <summary>
            All statements derive from this
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XStatement">
      <summary>
            Base calss for all statements
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XStatement.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XStatement.ToString">
      <summary>
            ToString() override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpressionStatement">
      <summary>
            Expression statement (for example for 'for statement'
            initializer and incrementer
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpressionStatement.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XExpressionStatement">
      <summary>
            An expression statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XExpressionStatement.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement">
      <summary>
            Block statement - i.e. a statement which is a collection of statements
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement.Statements">
      <summary>
            Collection of statements in the block
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XBlockStatement">
      <summary>
            A block of statements
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XBlockStatement.Statements">
      <summary>
            The statements in the block
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyGraph">
      <summary>
            For when the input statements have no ordering i.e. before scheduling
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependencyGraph.TargetIndex">
      <summary>
            Used to index unique lhs expressions
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph.getTargetIndex">
      <summary>
            Get an index for the lhs expression of a node.  Used for de-duplication.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph.requiredBits">
      <summary>
            Has a 1 in each bit position that is required.  bitsProvided defines what bit is provided by each statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph.isEssential">
      <summary>
            isEssential[node] == true if a node must run even if isUniform[node] == true.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DependencyGraph.isUniform">
      <summary>
            isUniform[node] == true if a node is known to always be uniform.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.DeleteAllOffsetIndexEdges(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration},System.Boolean@)">
      <summary>
            Mark offset edges (on the given loop variables) as deleted
            </summary>
      <param name="offsetVarsToDelete">If null, all offset edges are deleted.</param>
      <param name="isCyclic">True if the offset edges form a cycle</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.PropagateUniformNodes">
      <summary>
            Set the isUniform property by determining which nodes will always be uniform.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.PruneDeadNodes(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Remove nodes from the schedule whose result does not reach usedNodes.
            </summary>
      <param name="schedule">An ordered list of nodes.</param>
      <param name="usedNodes">On entry, the set of nodes whose value is needed at the end of the schedule.
            On exit, the set of nodes whose value is needed at the beginning of the schedule.</param>
      <returns>A subset of the schedule, in the same order.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.RepairSchedule2(System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Infer.Transforms.DependencyGraph.TargetIndex},System.Collections.Generic.ICollection{System.Int32})">
      <summary>
            Add copies of nodes to satisfy fresh/trigger constraints
            </summary>
      <param name="schedule">
      </param>
      <param name="fresh">On entry, the set of fresh targets at the start of the schedule (including initialized nodes).  On exit, the set of fresh targets at the end of the schedule.</param>
      <param name="initialized">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.CollectFreshNodes(System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Infer.Transforms.DependencyGraph.TargetIndex})">
      <summary>
            Collect the set of fresh nodes at the end of the schedule
            </summary>
      <param name="schedule">
      </param>
      <param name="fresh">On entry, the set of fresh targets at the start of the schedule (including initialized nodes).  On exit, the set of fresh targets at the end of the schedule.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.CheckSchedule(System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Check that the schedule meets the constraints given by trigger/fresh annotations, throwing an exception if not
            </summary>
      <param name="schedule">
      </param>
      <param name="initialized">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.CollectRequirements(System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32},System.Boolean)">
      <summary>
            Returns all the nodes which are required before starting the schedule.
            </summary>
      <param name="schedule">
      </param>
      <param name="available">On entry, the set of nodes whose value is available at the start of the schedule.
            On exit, the set of nodes whose value is available at the end of the schedule.</param>
      <param name="initialize">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.PruneNodesMissingRequirements(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.ICollection{System.Int32},System.Boolean)">
      <summary>
            Returns a new schedule where nodes without their requirements satisfied are pruned.
            </summary>
      <param name="schedule">
      </param>
      <param name="available">On entry, the set of nodes whose value is available at the start of the schedule.
            On exit, the set of nodes whose value is available at the end of the schedule.</param>
      <param name="initialize">If true, initialized nodes are assumed to have all requirements met.</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.TriggeesOf(System.Int32)">
      <summary>
            Return the set of nodes that this node triggers.
            </summary>
      <param name="node">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependencyGraph.FreshTargetsOf(System.Int32)">
      <summary>
            Return the set of nodes that would become stale when this node executes.
            </summary>
      <param name="node">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation">
      <summary>
            Stores information about how a statement depends on other statements.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.dependencyTypeOf">
      <summary>
            Stores the dependency type of all dependent statements.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.offsetIndexOf">
      <summary>
            Stores the offsets of all dependent statements that have an offset.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.IsOutput">
      <summary>
            True if this statement assigns to an output variable of the inference.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.IsUniform">
      <summary>
            True if this statement always returns a uniform distribution or zero evidence value.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.IsFresh">
      <summary>
            True if this statement must be updated whenever any dependency changes.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.ParameterDependencies">
      <summary>
            List of method arguments that the statement depends on.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.Dependencies">
      <summary>
            Statements that modify variables used in this statement.  Excludes initializers and allocations.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.DeclDependencies">
      <summary>
            Statements that allocate (or in some cases initialize) variables used in this statement.
            </summary>
      <remarks>
            DeclDependencies and Dependencies must be disjoint.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.ContainerDependencies">
      <summary>
            Statements which determine whether or not this statement executes, or what its target is.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.FreshDependencies">
      <summary>
            Statements which must be up-to-date before executing this statement.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.Requirements">
      <summary>
            Statements that must be executed before this statement.
            </summary>
      <remarks>
            AnyStatements can be used to create disjunctive requirements, e.g. "either A or B must execute before this statement".
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.SkipIfUniform">
      <summary>
            Statements that must be executed before this statement, and must return a non-uniform result.
            </summary>
      <remarks>
            AnyStatements can be used to create disjunctive requirements, e.g. "either A or B must execute before this statement".
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.Initializers">
      <summary>
            Initialization statements of the variable that this statement mutates.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DependencyInformation.Triggers">
      <summary>
            Statements whose execution invalidates the result of this statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Dependency">
      <summary>
            Statements that modify variables used in this statement.  Excludes initializers and allocations.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Requirement">
      <summary>
            Statements that must be executed before this statement.
            </summary>
      <remarks>
            AnyStatements can be used to create disjunctive requirements, e.g. "either A or B must execute before this statement".
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.SkipIfUniform">
      <summary>
            Statements that must be executed before this statement, and must return a non-uniform result.
            </summary>
      <remarks>
            AnyStatements can be used to create disjunctive requirements, e.g. "either A or B must execute before this statement".
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Trigger">
      <summary>
            Statements whose execution invalidates the result of this statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Fresh">
      <summary>
            Statements which must be up-to-date before executing this statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Declaration">
      <summary>
            Statements that allocate (or in some cases initialize) variables used in this statement.
            </summary>
      <remarks>
            DeclDependencies and Dependencies must be disjoint.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Container">
      <summary>
            Statements that modify variables used in the containers of this statement.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.DependencyType.Initializer">
      <summary>
            Initialization statements of the variable that this statement mutates.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DepthCloningTransform">
      <summary>
            Clones variables to ensure that each is used at a fixed depth
            </summary>
      <remarks>
            More documentation can be found on the sharepoint.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DerivedVariableTransform">
      <summary>
            This transform clones variables that are derived in some contexts and non-derived in others.  This is needed for VMP to function correctly with deterministic gates.	
            PREREQUISITE: 
            A variable with at least one derived definition must have DerivedVariable attribute set.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.DerivedVariableTransform.Count">
      <summary>
            Counter used to generate variable names.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.#ctor">
      <summary>
            Create an empty FactorInfo structure.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.OutputIsDeterministic(System.Collections.Generic.IDictionary{System.String,System.Type})">
      <summary>
            True if the factor is deterministic and all arguments to the factor are deterministic types.
            </summary>
      <param name="parameterTypes">A mapping from factor arguments to message types.  Missing entries imply no constraint.  Can be null.</param>
      <returns>
      </returns>
      <remarks>
            If the result is true, then GetMessageFcnInfo will generally fail.  Thus it is good to
            call this function as a check before calling GetMessageFcnInfo.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetMessageFcnInfo(MicrosoftResearch.Infer.Transforms.FactorManager,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,System.Boolean})">
      <summary>
            Get metadata for an operator method.
            </summary>
      <param name="factorManager">Factor manager reference</param>
      <param name="methodSuffix">Cannot be null.</param>
      <param name="targetParameter">Can be null, to mean all parameters.</param>
      <param name="parameterTypes">A mapping from factor arguments to message types.  Missing entries imply no constraint.  Can be null.</param>
      <param name="isStochastic">A mapping from factor arguments to bool.  Missing entries imply no constraint.  Can be null.</param>
      <returns>A MessageFcnInfo</returns>
      <remarks>
            This routine caches its results so it tends to be faster than GetMessageFcnInfos.
            Besides the factor arguments, <paramref name="parameterTypes" /> should include an entry for the return type ("result").
            For composite array arguments, <paramref name="parameterTypes" /> should include an entry for the result index ("resultIndex"). 
            </remarks>
      <exception cref="T:System.ArgumentException">The best matching type parameters did not satisfy the constraints of the generic method.</exception>
      <exception cref="T:System.MissingMethodException">No match was found.</exception>
      <exception cref="T:System.NotSupportedException">The message function is not supported (as opposed to simply missing).</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the given constraints.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetMessageFcnInfos">
      <summary>
            Get metadata for all operator methods.
            </summary>
      <returns>A stream of MessageFcnInfos.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetMessageFcnInfos(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Type})">
      <summary>
            Get metadata for multiple operator methods.
            </summary>
      <param name="methodSuffix">Can be null, to mean all suffixes.</param>
      <param name="targetParameter">Can be null, to mean all edges.</param>
      <param name="parameterTypes">A mapping from factor arguments to message types.  
            Missing entries imply no constraint.  
            If parameterTypes is null, the result may contain open type parameters.  
            Otherwise the result will not have open type parameters.</param>
      <returns>A non-empty stream of MessageFcnInfos that match the given constraints.</returns>
      <remarks>
            If targetKey is null and parameterTypes is empty, then all operator methods with the given suffix are returned.
            The results are not cached.  For fast retrieval of a single message function, use GetMessageFcnInfo instead.
            If no message functions match the constraints, one of the below exceptions is thrown.
            </remarks>
      <exception cref="T:System.ArgumentException">The best matching type parameters did not satisfy the constraints of the generic method.</exception>
      <exception cref="T:System.MissingMethodException">No match was found.</exception>
      <exception cref="T:System.NotSupportedException">The message function is not supported (as opposed to simply missing).</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetMessageOperators">
      <summary>
            Gets the list of the message operators of the method.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.FindMessageFunctions(System.Collections.Generic.IEnumerable{System.Type},System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,System.Boolean},System.Collections.Generic.IList{System.Exception})">
      <summary>
            A stream of MessageFcnInfos matching given constraints.
            </summary>
      <param name="operators">The types to scan for methods.</param>
      <param name="methodSuffix">Can be null, to mean all suffixes.</param>
      <param name="targetParameter">Can be null, to mean all parameters.</param>
      <param name="typeArguments">A mapping from factor type argument names to types. Missing entries imply no constraint.</param>
      <param name="parameterTypes">A mapping from factor parameter names to types.  
            Missing entries imply no constraint.  
            If parameterTypes is null, the result may contain type parameters of the message function.
            Otherwise the result will not have type parameters.</param>
      <param name="isStochastic">
      </param>
      <param name="errors">A list that collects matching errors.</param>
      <returns>A stream of MessageFcnInfos that match the given constraints.</returns>
      <remarks>
            If targetKey is null, methodSuffix is null, typeArguments is empty, and parameterTypes is empty, then all methods of
            the given operators are returned.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetFieldIndices(System.Reflection.ParameterInfo[],System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Compute the canonical index of each parameter, in case the parameters are permuted.
            </summary>
      <param name="parameters">
      </param>
      <param name="originalNames">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetTypeArguments(System.Reflection.MethodInfo)">
      <summary>
            Get a mapping from type parameter names to type arguments.
            </summary>
      <param name="method">
      </param>
      <returns>empty if the method is a generic method definition.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetTypeArguments(System.Type)">
      <summary>
            Get a mapping from type parameter names to type arguments.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.MakeGenericType(System.Type,System.Collections.Generic.IDictionary{System.String,System.Type})">
      <summary>
            Same as <see cref="M:System.Type.MakeGenericType(System.Type[])" /> except the typeArguments are taken by name from a dictionary.
            </summary>
      <param name="type">
      </param>
      <param name="typeArguments">
      </param>
      <returns>The instantiated Type.</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="type" /> is not a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">A type argument does not satisfy the constraints of the generic type.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.MakeGenericMethod(System.Reflection.MethodInfo,System.Collections.Generic.IDictionary{System.String,System.Type})">
      <summary>
            Same as <see cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" /> except the typeArguments are taken by name from a dictionary.
            </summary>
      <param name="method">The method info</param>
      <param name="typeArguments">The type arguments</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetDesiredParameterTypes(System.Reflection.ParameterInfo[],System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,MicrosoftResearch.Infer.Transforms.FactorEdge})">
      <summary>
            Map parameter names to types according to a dictionary.
            </summary>
      <param name="parameters">
      </param>
      <param name="parameterTypes">Mapping from original factor parameters to Types.  If null, assumed to be exactly the parameter types.</param>
      <param name="factorEdgeOfParameter">Mapping from new parameter names to original factor parameter names.</param>
      <returns>An array of types, in the same order as the parameters.</returns>
      <remarks>
            The result array will always have the same length as <paramref name="parameters" />.
            It will contain null when the desired parameter type is unknown.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetNameMapping(System.Type)">
      <summary>
            Get a mapping from the new parameter names used in the operator to the original parameter names of the factor.
            </summary>
      <param name="op">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetDependencyInfo(System.Reflection.MethodInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Get a list of parameter expressions required by this method.
            </summary>
      <param name="method">An operator method.</param>
      <param name="fcnInfo">
      </param>
      <returns>A DependencyInformation where only (Dependencies,Requirements,Triggers) fields are filled in.</returns>
      <remarks>
            Each dependency expression has one of the following forms:
            <list type="bullet"><item>parameter</item><item>parameter[resultIndex]</item><item>AllExcept(parameter,resultIndex)</item><item>AnyItem(parameter)</item><item>AnyItem(AllExcept(parameter,resultIndex))</item><item>Any(expr,expr,...)</item></list></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.GetDependencies(System.Collections.Generic.IDictionary{System.String,MicrosoftResearch.Infer.Transforms.FactorEdge},System.Reflection.MethodInfo,System.Collections.Generic.IList{MicrosoftResearch.Infer.Transforms.FactorEdge}@,System.Boolean@,System.Collections.Generic.IList{MicrosoftResearch.Infer.Transforms.FactorEdge}@,System.Boolean@)">
      <summary>
            Collect the FactorEdges that this message function depends on.
            </summary>
      <param name="factorEdgeOfParameter">A mapping from message function parameter names to factor parameter names.</param>
      <param name="method">The message function.</param>
      <param name="requirements">On return, a list of FactorEdges that must be non-uniform.</param>
      <param name="skipIfAllUniform">
      </param>
      <param name="triggers">
      </param>
      <param name="noTriggers">
      </param>
      <returns>FactorEdges listed in the order of the parameters to the method.</returns>
      <remarks>
            Factor parameter dependencies are detected via the parameter names of the method.
            Array index dependencies are specified via parameter attributes.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo.IsVoid">
      <summary>
            True if the factor is a constraint, i.e. has a void return type.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorManager.InfoOfFactor">
      <summary>
            Cache of FactorInfo for each factor method.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorManager.OperatorsOfFactor">
      <summary>
            Cache of loaded operator types for each factor method.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorManager.PriorityList">
      <summary>
            A list of types, namespaces, modules, and assemblies.  Used to resolve ambiguous matches for message operators.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GivePriorityTo(System.Object)">
      <summary>
            Resolve ambiguous matches for message operators in favor of the given container.  Accumulates with all previous calls.
            </summary>
      <param name="container">A Type, namespace string, Module, or Assembly.</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GetPriority(System.Type)">
      <summary>
            Get the priority of the first matching position in the PriorityList, or 0 if no match.
            </summary>
      <param name="type">
      </param>
      <returns>PriorityList.Count if the type matches the first entry, PriorityList.Count-1 if the type matches the second entry, and so on down to 0 if no match.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GetFactorInfo(System.Delegate)">
      <summary>
            Get metadata for a factor method.
            </summary>
      <param name="factor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GetFactorInfo(System.Reflection.MethodInfo)">
      <summary>
            Get metadata for a factor method.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GetFactorInfos">
      <summary>
            Get metadata for all factor methods with loaded message functions.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.BuildCache">
      <summary>
            Scan all loaded assemblies for message functions.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.GetDependencyInfo(System.Reflection.MethodBase,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Get a list of parameter expressions required by this method.
            </summary>
      <param name="method">An operator method.</param>
      <param name="factorInfo">
      </param>
      <param name="fcnInfo">
      </param>
      <returns>A DependencyInformation where only (Dependencies,Requirements,Triggers) fields are filled in.</returns>
      <remarks>
            Each dependency expression has one of the following forms:
            <list type="bullet"><item>parameter</item><item>parameter[resultIndex]</item><item>AllExcept(parameter,resultIndex)</item><item>AnyItem(parameter)</item><item>AnyItem(AllExcept(parameter,resultIndex))</item><item>Any(expr,expr,...)</item></list></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.FlipCapitalization(System.String)">
      <summary>
            Flip the case of the first letter of a string.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorManager.Uncapitalize(System.String)">
      <summary>
            Lowercase the first letter of a string.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.FactorEdge">
      <summary>
            Represents a range of arguments to a factor.
            </summary>
      <remarks>
        <para>
            Depending on which fields are non-null, this class represents a variety of different types of factor edge.
            The simplest type is the name of a parameter.  For an array parameter, this implies all elements of the array.
            The second type is "Param[i]", a specific element of an array parameter.
            The third type is "Param-[i]", which represents all elements of an array except one.
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorEdge.ParameterName">
      <summary>
            The name of a parameter to the factor function, or its return value.  Note that the message "to_x" has ParameterName="x" and IsOutgoingMessage=true.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorEdge.IsOutgoingMessage">
      <summary>
            True if the argument is of type "to_parameter".
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorEdge.containsOthers">
      <summary>
            True if the range definitely includes items other than Index.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorEdge.containsIndex">
      <summary>
            True if the range definitely includes the item at Index.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.FactorEdge.MinCount">
      <summary>
            The minimum number of items in the range.
            </summary>
      <remarks>
            MinCount must be &gt;= ContainsIndex + ContainsOthers.
            If ContainsOthers == false, MinCount can only be 0 or 1.
            MinCount can be 1 even if ContainsOthers == false and ContainsIndex == false.
            If ContainsOthers == true, MinCount == int.MaxValue means that all items other than Index are in the range.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorEdge.#ctor(System.String)">
      <summary>
            Create a range over all items of the parameter.
            </summary>
      <param name="parameterName">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.FactorEdge.#ctor(MicrosoftResearch.Infer.Transforms.FactorEdge)">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorEdge.ContainsAllOthers">
      <summary>
            True if the range definitely includes all items other than Index.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorEdge.ContainsOthers">
      <summary>
            True if the range definitely includes items other than Index.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.FactorEdge.ContainsIndex">
      <summary>
            True if the range definitely includes the item at Index.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageFcnInfo">
      <summary>
            Records information about the operator method 
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.TargetParameter">
      <summary>
            The name of the factor edge being computed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.IsStochastic">
      <summary>
            True if the message function performs sampling.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.factorEdgeOfParameter">
      <summary>
            Includes all parameters, including buffers, result, and resultIndex.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.SkipIfAllUniform">
      <summary>
            Indicates whether to skip the message if all arguments are uniform.
            </summary>
      <remarks>
            Only meaningful if Requirements.Count == 0.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.AllTriggers">
      <summary>
            Indicates whether the method has AllTriggersAttribute.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.NoTriggers">
      <summary>
            Indicates whether the method has NoTriggersAttribute.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.NotSupportedMessage">
      <summary>
            If the message is not supported, provides the explanation.
            </summary>
      <remarks>
            Will be null if the message is supported.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.IsMultiplyAll">
      <summary>
            True if the function returns the product of all arguments.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.ReturnedParameterIndex">
      <summary>
            Index of the IsReturned parameter, or -1 if none.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.ReturnedInAllElementsParameterIndex">
      <summary>
            Index of the IsReturnedInAllElements parameter, or -1 if none.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.ResultParameterIndex">
      <summary>
            Index of the result parameter, or -1 if none.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.ResultIndexParameterIndex">
      <summary>
            Index of the resultIndex parameter, or -1 if none.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.IsIndexedParameter">
      <summary>
            True if the parameter has MatchingIndexAttribute.  Array may be null if no parameters have the attribute.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.#ctor(MicrosoftResearch.Infer.Transforms.MessageFcnInfo)">
      <summary>
            Copy constructor.
            </summary>
      <param name="that">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.GetParameterTypes">
      <summary>
            Get the field names and types of message function parameters.
            </summary>
      <returns>A list of (field name, parameter type) in the same order as the parameters of the function.</returns>
      <remarks>
            The field names are not necessarily the same as the parameter names of the method.
            The field names are a subset of the entries in the FactorInfo of the factor.
            Additionally, a parameter may have the special field name "result" or "resultIndex".
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.PassResult">
      <summary>
            True if the method has a result parameter
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessageFcnInfo.PassResultIndex">
      <summary>
            True if the method has a resultIndex parameter
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform">
      <summary>
            Creates statement groups corresponding to forward/backward iterations when there are offset indices
            </summary>
      <remarks>
        <para>
            Purpose of the ForwardBackwardTransform is to put statements into groups.  
            Groups are either "forward", "backward", or "neutral" wrt a loop index.
            Groups are denoted by "while(true)" statements, except for the neutral group which has no container.  
            If a statement appears in multiple groups, it is cloned. 
            The statements in a backward group have their loop bounds reversed, so that they iterate backwards.
            </para>
        <para>
            The transform assumes that loop cutting has been performed so that each statement has its own set of containers.  
            Each statement must be annotated with DependencyInformation, where each dependency is annotated with a set of offsets.  
            An offset is described by an integer and a loop index, e.g. "i-1".  
            A single dependency edge can have multiple offsets on the same loop index, e.g. "i-1" and "i+1".
            </para>
        <para>
            Chain case:  There is only one loop index with offsets, so there will be 3 groups: forward, backward, and neutral.
            A node is in the forward group iff it lies on a dependency cycle where:
            1. at least one edge has a forward offset, and
            2. all edges have either a forward or neutral offset.
            The backward group is defined the same way, but with "forward" replaced by "backward".  
            The neutral group consists of all other nodes.
            Note that a node may end up in both the forward and backward group.  But it cannot be in both the forward and neutral group.
            </para>
        <para>
            Grid case: There are multiple loop indices with offsets.  This case is handled recursively.  
            The loop indices are put into an arbitrary order.  For the first loop index, we create 3 groups as above.  
            Then we recurse on each group, splitting along the second loop index, and so on.  This produces a hierarchy of groups.
            </para>
        <para>
            Variable declarations must have 'Containers' attributes indicating the containers they belong to.  (Should be attached by DependencyAnalysisTransform)
            </para>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.transformedStmtsInContext">
      <summary>
            For each context, store a map from original statement to transformed statement
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.CollectTransformedStmts(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.Dictionary{System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}})">
      <summary>
            Fill in the replacements dictionary for this block and collect replacements from descendant blocks
            </summary>
      <param name="outputBlock">
      </param>
      <param name="replacementsInContext">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.DistributeTransformedStmts(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.Dictionary{System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.Dictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement}})">
      <summary>
            Distribute the replacements dictionary for this block to its descendant blocks that lack the replacements
            </summary>
      <param name="outputBlock">
      </param>
      <param name="replacementsInContext">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Reverse the direction of 'for' loops according to loopVarsToReverse
            </summary>
      <param name="ifs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.ConvertWhile(MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement)">
      <summary>
            Create forward/backward composites in the body of while(true) loops
            </summary>
      <param name="iws">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.Schedule(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Boolean)">
      <summary>
            Convert inputStmts into forward/backward composites, placing result in outputStmts
            </summary>
      <param name="outputStmts">
      </param>
      <param name="inputStmts">
      </param>
      <param name="doNotSchedule">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.SplitForwardBackward(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Infer.Transforms.DependencyGraph,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.List{MicrosoftResearch.Infer.Transforms.SerialLoopInfo},System.Int32)">
      <summary>
            Create forward/backward composites for all loop variables &gt;= loopIndex
            </summary>
      <param name="inputStmts">
      </param>
      <param name="outputStmts">
      </param>
      <param name="g">
      </param>
      <param name="nodes">
      </param>
      <param name="infos">
      </param>
      <param name="loopIndex">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ForwardBackwardTransform.GetBlockDependencies(System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Construct DependencyInformation for a block of transformed statements, excluding dependencies on statements in the same block
            </summary>
      <param name="newStmts">Transformed statements</param>
      <param name="originalStmts">The same statements, before transformation</param>
      <returns>All external dependencies of the transformed statements</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform">
      <summary>
            Attaches GateBlock attributes to ConditionStatements.  Does not make any changes to the code.
            A GateBlock attribute describes all external variables used or defined inside the block.  
            For arrays, we need to group uses of an array into disjoint sets of indices, so that each use is covered by one of the sets.  
            Each use is described by an indexing pattern and a set of bindings (assignments to condition variables).
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.conditionContext">
      <summary>
            The list of bindings made by all conditional statements in the input stack
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.gateBlockContext">
      <summary>
            The list of open gate blocks.  gateBlockContext.Count &lt;= conditionContext.Count.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.gateBlocks">
      <summary>
            A dictionary mapping condition left-hand sides to GateBlocks.  Used to associate multiple conditional statements with the same GateBlock.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.declarationBindings">
      <summary>
            A dictionary storing the set of conditions in which a variable is declared.  Used for checking that a variable is defined in all conditions.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.definitionBindings">
      <summary>
            A dictionary storing the set of conditions in which a variable is defined.  Used for checking that a variable is defined in all conditions.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.ProcessUse(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean)">
      <summary>
            Add expr to currentBlock.variablesDefined or currentBlock.variablesUsed
            </summary>
      <param name="expr">
      </param>
      <param name="isDef">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.ReplaceLocalIndices(MicrosoftResearch.Infer.Transforms.GateBlock,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Use wildcards to replace any indices in expr which involve local variables of the gateBlock
            </summary>
      <param name="gateBlock">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.CouldBeEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the expressions could have the same value.
            </summary>
      <param name="expr1">
      </param>
      <param name="expr2">
      </param>
      <returns>
      </returns>
      <remarks>
            Examples:
            (0,i) = true for any variable i
            (0,1) = false
            (i,j) = true for any variables i and j
            (i,i-1) = false
            (i-1,i-2) = false
            (i,j-1) = true
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.Unify(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IEnumerable{System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.ConditionBinding}},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IEnumerable{System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.ConditionBinding}},System.Boolean@)">
      <summary>
            Returns an expression equal to expr1 and expr2 under their respective bindings, or null if the expressions are not equal.  
            </summary>
      <param name="expr1">
      </param>
      <param name="bindings1">
      </param>
      <param name="expr2">
      </param>
      <param name="bindings2">
      </param>
      <param name="couldBeEqual">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.AnyIndex">
      <summary>
            Used only in ArrayIndexerExpressions, to represent a wildcard.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateAnalysisTransform.GetCommonParent(MicrosoftResearch.Infer.Transforms.ExpressionWithBindings,MicrosoftResearch.Infer.Transforms.ExpressionWithBindings,System.Boolean@)">
      <summary>
            Return the common parent of the two expressions, and indicate if the expressions overlap
            </summary>
      <param name="eb1">
      </param>
      <param name="eb2">
      </param>
      <param name="overlap">
      </param>
      <returns>
      </returns>
      <remarks>
            When finding the common parent, we want to preserve any array slicing.  Indexing brackets are not removed if present in both expressions.
            Mismatching indices are replaced by AnyIndex.
            Examples:
            i = loop index inside the gate block
            j = loop index outside the gate block, or a method parameter
            (a,a[i]) =&gt; (a,true)
            (a,a[j]) =&gt; (a,true)
            (a[i],a[0]) =&gt; (a[*],true)
            (a[i],a[j]) =&gt; (a[*],true)
            (a[j],a[0]) =&gt; (a[*],assumeMatch)
            (a[0],a[1]) =&gt; (a[*],false)
            (a[0][0],a[1][0]) =&gt; (a[*][0],false)
            (a[0][0],a[1][1]) =&gt; (a[*][*],false)
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.GateBlock">
      <summary>
            Describes all external variables used or defined inside the block.  
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateBlock.variablesDefined">
      <summary>
            Variables defined inside the block, along with their (unique) indexing pattern.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateBlock.variablesUsed">
      <summary>
            Variables used inside the block, paired with a set of disjoint indexing patterns.  Does not keep track of which branch the variable was used in.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateBlock.conditionContext">
      <summary>
            Current condition context inside the block (deterministic conditions only)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateBlock.caseValues">
      <summary>
            The set of all case values encountered
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateBlock.hasLoopCaseValue">
      <summary>
            True if one of the case values is a loop counter
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ExpressionWithBindings">
      <summary>
            Stores a unified expression along with the set of conditions where the expression appears.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ExpressionWithBindings.Bindings">
      <summary>
            A set of condition contexts.  An empty set means the expression has an empty condition context.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.GateTransform">
      <summary>
            Handles gates in the MSL, as represented by if statements and switch statements.
            </summary>
      <remarks>
            This transform affects:
             - references to variables declared outside of an if/switch statement
               The transform replaces the variable with different clones on each branch.
               A Gate.Enter factor is added at the start relating the clones to the original.
            
             - variables defined in all branches of an if/switch statement
               The transform replaces the variable with different clones in each branch. 
               A Gate.Exit factor is added at the end relating the clones to the original.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateTransform.bindings">
      <summary>
            The list of bindings made by all conditional statements in the input stack (including deterministic conditions)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateTransform.conditionContext">
      <summary>
            The list of open conditional statements with stochastic conditions.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateTransform.condDict">
      <summary>
            A cache of the ConditionalInformation for each conditionLhs in each condition context.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateTransform.casesNames">
      <summary>
            A cache of the names used for 'cases' variables, to avoid collisions
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GateTransform.inefficientReplacements">
      <summary>
            A null list indicates that at least one replacement was efficient.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.ConvertCondition(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            Converts an if statement with a stochastic condition of the form 'b' or '!b' for boolean random
            variable b or 'i==value' for boolean or integer random variable i. The 'value' can be a literal or
            a loop index.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.GetMissingLoopVar(MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Infer.Transforms.ConditionBinding},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get a loop variable in the current context that is not referenced by expr or conditionCaseContext.
            </summary>
      <param name="conditionCaseContext">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            Converts indexed variable references inside if/switch statements by cloning them and adding
            Enter/Exit factors as necessary.
            </summary>
      <param name="iaie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.ConvertIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Converts the indices in all brackets of expr, but not the innermost target.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Converts variable references inside if/switch statements by cloning them and adding
            Enter/Exit factors as necessary.
            </summary>
      <param name="ivre">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.ReplaceWithClone(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,System.Int32,System.Int32)">
      <summary>
            Replace expr with a reference to the clone array, substituting any indices that match wildcards.
            </summary>
      <param name="expr">
      </param>
      <param name="isDef">
      </param>
      <param name="ivd">
      </param>
      <param name="start">
      </param>
      <param name="conditionContextIndex">
      </param>
      <returns>
      </returns>
      <remarks>
            For example, if expr = a[0,j][1,k] and the gateBlock has a pattern a[*,j][*,k] then this function
            returns clone[0][1][caseNumber].
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GateTransform.GetMatchingPrefix(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.List{System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}}@)">
      <summary>
            Returns a prefix of expr1 that matches expr2, where anything matches AnyItem.  The indices that matched AnyItem are returned.
            </summary>
      <param name="expr1">
      </param>
      <param name="expr2">
      </param>
      <param name="indices">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ConditionInformation">
      <summary>
            For an if or switch statement, keeps tracks of variables that are cloned and other information.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ConditionInformation.ActionOut2`3">
      <summary>
            Generic delegate with 2 out parameters
            </summary>
      <typeparam name="T1">Type of first argument</typeparam>
      <typeparam name="T2">Type of second argument</typeparam>
      <typeparam name="T3">Type of third argument</typeparam>
      <param name="arg1">First argument</param>
      <param name="arg2">Second argument</param>
      <param name="arg3">Third argument</param>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.caseNumber">
      <summary>
            The zero-based index of this case in the gate block
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.caseValue">
      <summary>
            The value that the conditionLhs must equal in this case of the gate block.  Only used for ToString.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.casesArray">
      <summary>
            A bool[] used for collecting evidence and Gate.Exit
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.cloneMap">
      <summary>
            Map from an input expression to its clone information.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ConditionInformation.switchLoop">
      <summary>
            If isSwitch=true, the loop defining the loop variable in the conditionLhs.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.#ctor(MicrosoftResearch.Infer.IAlgorithm,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Constructor.
            </summary>
      <param name="algorithm">
      </param>
      <param name="conditionLhs">
      </param>
      <param name="numberOfCases">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.GetClone(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Infer.Transforms.ExpressionWithBindings,MicrosoftResearch.Infer.Transforms.GateTransform,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Returns the appropriate clone of a variable to use inside the current gate.  The clone
            will be created if necessary.
            </summary>
      <param name="context">
      </param>
      <param name="eb">
      </param>
      <param name="transform">
      </param>
      <param name="start">
      </param>
      <param name="conditionContextIndex">
      </param>
      <param name="isDef">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.ReplaceAnyItem(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.List{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}})">
      <summary>
            Replace wildcards in an expression with loop indices and return the corresponding loops
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <param name="indices">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.CreateCloneArray(MicrosoftResearch.Infer.Transforms.ClonedVarInfo,MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Infer.Transforms.GateTransform,System.Int32,System.Int32,MicrosoftResearch.Infer.Collections.Set{System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.ConditionBinding}})">
      <summary>
            Creates a clone of a variable which is entering or exiting a Gate.
            </summary>
      <param name="cvi">Cloned variable information</param>
      <param name="context">
      </param>
      <param name="transform">
      </param>
      <param name="start">
      </param>
      <param name="bindingSet">
      </param>
      <param name="conditionContextIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.GetConditionExpression(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Get a fully substituted expression for the condition of this condInfo.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.WrapBlockWithConditionals(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            Wrap each statement with multiple 'if' statements, as given by condInfo.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ConditionInformation.WrapStatementsWithConditionals(MicrosoftResearch.Transforms.BasicTransformContext,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Wrap each statement with multiple 'if' statements, as given by condInfo.
            </summary>
      <param name="context">the transform context.</param>
      <param name="statements">the statements to wrap.</param>
      <param name="action">action to take for each wrapped statement.</param>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ConditionInformation.isSwitch">
      <summary>
            True if the condition rhs is a loop variable.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.ConditionInformation.isFixedSize">
      <summary>
            True if the number of cases is known at compile time.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ClonedVarInfo">
      <summary>
            Describes a variable cloned across different branches of a condition.
            </summary>
      <remarks>
            Any variable declared outside a condition is cloned into an array of variables;
            one for each branch of the condition in which the variable is used.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.expr">
      <summary>
            The expression being cloned.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.exprType">
      <summary>
            Type of expr.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.wildcardVars">
      <summary>
            Loop indices corresponding to the wildcards in expr.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.IsExitVar">
      <summary>
            True if the variable is defined inside the gate.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.arrayDecl">
      <summary>
            Declaration of the array of clones.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.arrayRef">
      <summary>
            Cached variable reference to the array of clones.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.caseVars">
      <summary>
            A map from case numbers to clone variables.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.caseNumbers">
      <summary>
            An array of integers, listing the condition branches in which the variable is used.
            </summary>
      <remarks>
            For example, if x is used in branches 0 and 2, the expression will be <c>new int[] { 0, 2 }</c>.
            indices is non-null only if Gate.EnterPartial or Gate.Exit is being used.  If enterOne is true, caseNumbers is null.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.caseCount">
      <summary>
            The length of caseNumbers.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.definitionCount">
      <summary>
            The number of distinct cases in which this variable is defined.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.containers">
      <summary>
            Containers in which the clone array (and elements thereof) are declared.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.GetCloneForCase(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Infer.Transforms.ConditionInformation,System.Boolean,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get a clone variable for the given case number.
            </summary>
      <param name="context">
      </param>
      <param name="condInfo">
      </param>
      <param name="isDef">
      </param>
      <param name="caseNumber">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ClonedVarInfo.AddCase(System.Boolean,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Given a case number, get an index into the clones array.
            </summary>
      <param name="isDef">True if the expression to be cloned is on the lhs of an assignment.</param>
      <param name="caseNumber">
      </param>
      <returns>
        <c>indices.IndexOf(caseNumber)</c>, adding a new entry if necessary.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.SuppressVariableFactor">
      <summary>
            When attached to a variable declaration, indicates that no variable factor should be generated.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.GroupTransform">
      <summary>
             The group transform deals with all aspects of group handling
             It creates groups as necessary for deterministic factors and constraints
             and changes the group annotations into MessagePath annotations on factor expressions.
             It also creates related annotations (ChannelPath attributes) on variable declarations
             so that the message transform knows what type of variables to create.
             </summary>
      <remarks>
             The group transform has the following steps:
             
             1. Builds a bipartite factor graph of factors and variables. This is done using the
                transform framework. This will also create groups for deterministic factors and
                constraints
            
             2. For each existing group (i.e. manually specified group) consisting of more than one
                variable expression, picks a variable, and finds the shortest path from that variable
                to all other variables in the group. Add all nodes in the path to the group.
                
             3a. For any deterministic factor which is not a variable factor, creates a group
                 for each input argument, and add the output argument (unless such a pair exists)
             3b. Similarly for constraints, where the first argument to the constraint acts as
                 the output argument.
                 
             4. For each variable factor, if any argument is in a group, ensures that all other arguments
                 are in the group.
                 
             5. Finds the root of each group. With the current architecture, the root variable cannot
                be on the 'uses' side of any other variable in the group. This is because 'uses' are
                currently treated as a whole in terms of type, and if one of the uses (or anything downstream)
                were picked as the root, then one of the uses would need to be a different type.
                The exception to this is GateExitRandom which is used for variables defined within
                a gate - in this case, the root must be the exit side. 
                
            	   NOTE: In future, it would be nice to have a factor which allowed one of the uses to be
            	   treated differently from all the other uses. This factor could then be inserted in situations
            	   where roots were manually specified the uses side of any variable in the group. This would
            	   require that the Group transform should go before the Channel transform so that we can
            	   insert the correct type of variable factor
                
             6. Calculates distances from the root for each group
                
             7. Loops through the factor expressions, and call the algorithm to set the paths.
                for the MessagePath attributes. This is done whether or not the expression
                participates in a group.
            
             8. Traverses the factor graph to create the ChannelPath attributes
             </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GroupTransform.groupCount">
      <summary>
            Used for assigning unique names to groups
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GroupTransform.#ctor(MicrosoftResearch.Infer.IAlgorithm)">
      <summary>
            Constucts a Group transform
            </summary>
      <param name="algorithm">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GroupTransform.MarkDistanceFromRoot(MicrosoftResearch.Infer.Graphs.Edge{MicrosoftResearch.Infer.Transforms.GroupNode})">
      <summary>
            Mark distance from current root
            </summary>
      <param name="edge">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GroupTransform.AttachDistances(MicrosoftResearch.Infer.Transforms.GroupNode)">
      <summary>
            Attach distances for current group
            </summary>
      <param name="gn">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GroupTransform.PostProcessDependencies">
      <summary>
            Post-process dependencies. Converts GroupMember attributes to MessagePath attributes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.GroupTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Shallow copy of for statement
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GroupNode.variableDeclaration">
      <summary>
            For a factor node, this is always null.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GroupNode.conditionVar">
      <summary>
            For a node inside a gate, stores the conditionVar.  Otherwise null.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GroupNode.groupMembers">
      <summary>
            Stores distance info for each group that this variable is a member of.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.GroupNode.factorExpression">
      <summary>
            For a variable node, this is always null.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.InheritParentGrouping">
      <summary>
            Inherit parent grouping
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.InheritParentGrouping.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute">
      <summary>
            Channel path attribute. Marks all paths that will exist on the channel
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.Path">
      <summary>
             The message path
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.Direction">
      <summary>
            Message direction
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.FromDefault">
      <summary>
            Path attribute comes from a default message attribute
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.Equals(System.Object)">
      <summary>
            Equals override
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ChannelPathAttribute.GetHashCode">
      <summary>
            GetHashCode override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessagePathAttribute">
      <summary>
            Attribute which is attached to the method invoke expression associated with an
            operator call. The attribute specifies a context-specific ('from' to 'to') string
            representation (in general a path) of the message expression (for example, the field
            name 'Sample' in a DistAndSample message type) 
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.#ctor(System.String)">
      <summary>
            Create a default message path attribute
            </summary>
      <param name="path">The message path - this is a property name in the message type</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.#ctor(System.String,System.String,System.Int32,System.Int32)">
      <summary>
            Create a default message path attribute associated with a variable group
            </summary>
      <param name="from">The 'from' argument name</param>
      <param name="to">The 'to' argument name</param>
      <param name="fromDistance">Distance of from argument to root</param>
      <param name="toDistance">Distance of to argument to root</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Create a message path attribute with a specified path
            </summary>
      <param name="from">The 'from' argument name</param>
      <param name="to">The 'to' argument name</param>
      <param name="path">path</param>
      <param name="isDefault">Whether this MPA is a default MPA</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.AppliesTo(System.String,System.String)">
      <summary>
            Whether this attribute is applicable to specified from/to argument names
            </summary>
      <param name="from">
      </param>
      <param name="to">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.Path">
      <summary>
            The path of the 'from' message
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.From">
      <summary>
            The 'from' argument for the message
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.To">
      <summary>
            The 'to' argument for the message
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.FromDistance">
      <summary>
            The distance of the 'from' argument from the root of the group
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.ToDistance">
      <summary>
            The distance of the 'to' argument from the root of the group
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Transforms.MessagePathAttribute.IsDefault">
      <summary>
            Indicates that the message attribute is a default attribute
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IfCuttingTransform">
      <summary>
            Cuts if statements containing multiple child statements, so that each child statement is in its own if statement.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IfCuttingTransform.ConvertCondition(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            Converts an if statement by deleting the outer statement and wrapping the inner statements.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IfCuttingTransform.IsStochasticVariableReference(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the supplied expression is stochastic.  
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.IndexAnalysisTransform.indexInfoOf">
      <summary>
            Stores information about every stochastic array indexer expression where the indices are not all loop variables
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IndexAnalysisTransform.CheckIndicesAreNotStochastic(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Raise an error if any expression is stochastic.
            </summary>
      <param name="exprs">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IterationTransform">
      <summary>
            Find statements with cyclic dependencies and place them in while loops.  Statements not in loops, and the loops themselves, are
            topologically sorted.  DependencyInformation.IsUniform is updated based on this ordering.  Statements within while loops have arbitrary order.  
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IterationStatement">
      <summary>
            Attached to a dummy statement used to put all DependsOnIteration statements in the same loop
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DoNotSchedule">
      <summary>
            Attached to a while loop to tell the scheduler to preserve the order of statements (and preserve the loop itself)
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.OutputSource">
      <summary>
            Attached to source statements of output statements
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform">
      <summary>
            Turns a method into a class which implements IExecutableProcess.
            This involves:
             - moving statements into methods which represent pieces of the schedule (these are called subroutines)
             - creating an Execute method which invokes all of the subroutines
             - converting local variables and method parameters into fields.
             - adding methods to get marginals and outputs
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.persistentVars">
      <summary>
            Variables that must become fields of the generated class.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.numberOfIterationsDone">
      <summary>
            Reference to the numberOfIterationsDone field.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.DoConvertMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            Methods with the OperatorMethod attribute are converted and discarded.
            </summary>
      <param name="md">
      </param>
      <param name="imd">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.ConvertMethodParameter(MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration,System.Int32)">
      <summary>
            Convert method parameter into a class field.
            </summary>
      <param name="ipd">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.ForEachDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Apply action to every variable declaration in the statement
            </summary>
      <param name="ist">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.InheritMembers``1(MicrosoftResearch.Infer.Graphs.IndexedProperty{System.Int32,MicrosoftResearch.Infer.Collections.Set{``0}},System.Int32,System.Int32,MicrosoftResearch.Infer.Collections.Set{``0})">
      <summary>
            Returns true of target deps have changed
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="setOf">
      </param>
      <param name="target">
      </param>
      <param name="source">
      </param>
      <param name="excludeFromTarget">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.GetDistributionArrayWrapper(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns an expression of type DistributionArray from an indexed expression whose target has type Distribution[]
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IterativeProcessTransform.CreateOutputMethodWithPath(System.String,System.String,System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean)">
      <summary>
            Create output method
            </summary>
      <param name="varName">
      </param>
      <param name="query">
      </param>
      <param name="expr">
      </param>
      <param name="path">
      </param>
      <param name="isMarginal">
      </param>
      <remarks>Marginal is returned as an array over distributions. Output is returned
            as a distribution array</remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ObservedValueChangedBehaviour">
      <summary>
            Let's you control how the model compiler detects
            whether an observed value has changed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ObservedValueChangedBehaviour.WhenSetAndNotEqual">
            Assumes observed value has changed whenever the ObservedValue property is set.
        </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IndexingTransform">
      <summary>
            Handles any replication made necessary by constant indexing.
            PREREQUISITE: 
            Variable declarations must have 'Containers' attributes indicating the containers they belong to.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.IndexingTransform.UseJaggedSubarray">
      <summary>
            If true, convert Subarray calls into JaggedSubarray whenever possible
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.IndexingTransform.UseGetItems">
      <summary>
            If true, convert array indexing into GetItems whenever possible
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IndexingTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            This method does all the work of converting literal indexing expressions.
            </summary>
      <param name="iaie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IndexingTransform.ConvertAssign(MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression)">
      <summary>
            Attach DerivedVariable attributes to newly created variables
            </summary>
      <param name="iae">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.IndexingTransform.GetBindingSetContainer(MicrosoftResearch.Infer.Collections.Set{System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Transforms.ConditionBinding}},System.Predicate{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Make a condition statement whose condition is the disjunction of all bindings that satisfy a predicate.
            </summary>
      <param name="bindingSet">
      </param>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.LoopContext">
      <summary>
            Represents a loop context i.e. the set of loops that an expression occurs in.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.loops">
      <summary>
            Loops that contain the expression, outermost first.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.loopVariables">
      <summary>
            The loop variables for all contained loops
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.#ctor(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Creates a loop context, given the current transform context.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.#ctor(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement})">
      <summary>
            Creates a loop context, given the current transform context.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.LoopContext.GetReferenceLoopContext(MicrosoftResearch.Transforms.BasicTransformContext)">
      <summary>
            Gets the reference loop context for a reference to a local variable.  A reference loop context
            is the set of loops that a variable reference occurs in, less any loops that the variable declaration
            occurred in.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.RefLoopContext">
      <summary>
            Represents a reference loop context i.e. the set of loops that a variable reference 
            occurs in, less any loops that the variable declaration occurred in.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LoopCuttingTransform">
      <summary>
            Cuts 'for' loops, so that each statement in the loop ends up in a loop by itself.
            Also converts declarations inside loops into top-level declarations.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopCuttingTransform.ConvertVariableDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Converts variable declarations inside loops into array declarations at the top level.
            </summary>
      <param name="ivde">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopCuttingTransform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Converts references to variables which were declared inside loops, by adding indexing as appropriate.
            </summary>
      <param name="ivre">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LoopMergingTransform">
      <summary>
            Fuses consecutive 'for' loops over the same range, when it is safe to do so.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMergingTransform.ConvertStatements(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Converts each statement, analyses their containers, then merges them
            </summary>
      <param name="outputs">
      </param>
      <param name="inputs">
      </param>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LoopMergingInfo.indexOf">
      <summary>
            Maps statements into graph node numbers
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LoopMergingInfo.graph">
      <summary>
            A graph where nodes are statements and edges indicate that loop merging is prohibited between them.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LoopMergingInfo.prohibitedLoopVars">
      <summary>
            For each graph edge, stores the loop variables on which merging is prohibited.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.LoopMergingInfo.offsetInfos">
      <summary>
            For each graph edge, stores a pairing of loop variables and their offsets.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.LoopMergingInfo.GetConflictingStmt(MicrosoftResearch.Infer.Collections.Set{System.Int32},System.Int32,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,System.Boolean)">
      <summary>
            Get the index of the statement that prevents loop merging, or -1 if none
            </summary>
      <param name="stmts">
      </param>
      <param name="stmtIndex">
      </param>
      <param name="loopVar">
      </param>
      <param name="isForwardLoop">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.LoopOrderingTransform">
      <summary>
            Order loops with literal sizes by variable name.  Push conditionals inside of sequential loops.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform">
      <summary>
            Optimises message passing by removing redundant messages and operations.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.CopyAnalysisTransform">
      <summary>
            Analyses known copy expressions and attached CopyOfAttribute where appropriate.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.CopyOfAttribute">
      <summary>
            Attribute used to mark variables which are just copies of other variables.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.Transform(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            Run analysis on the supplied model and then transform it to
            remove redundant messages.
            </summary>
      <param name="itd">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.ConvertVariableDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Record the containers that a variable is created in, for use by HoistingTransform.
            </summary>
      <param name="ivde">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.ConvertAssign(MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression)">
      <summary>
            Remove assignments to variables which are copies of other variables.
            </summary>
      <param name="iae">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            Modify array index expressions which are copies of other variables.
            </summary>
      <param name="iaie">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Modify variable references that can be replaced by other variables.
            </summary>
      <param name="ivre">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CopyPropagationTransform.GetCopyExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Determines if the value of the supplied expression will always be equal
            to another expression, and if so returns the other expression.
            Otherwise returns null.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageTransform">
      <summary>
            Transforms a model specified in terms of channels into the set of message passing
            operations required to perform inference in that model.
            </summary>
      <remarks>
            The message passing transform does the following operations:
             - converts channel declarations into pairs of variables for forwards and backwards 
               messages along that channel.
             - initalises message arrays using the appropriate message prototypes
               - message prototypes may be different for backward and forward directions
               - the algorithm determines the message prototypes in a call to GetMessagePrototypes
               - default message prototype is the marginal prototype
             - converts method calls into sets of operator method calls
             - keeps track of all inter-operator dependencies, as these are needed by the scheduler
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageTransform.MessageInfo">
      <summary>
            Describes a message in a message-passing program.
            </summary>
      <remarks>
            A message is a channel paired with a direction (either forwards or backwards).
            A message can be labelled as an "output" to mean it is the result of inference.
            When a random variable has multiple uses, all uses are labelled with the same MessageInfo.
            		
            If the channel is in a plate, we need to distinguish between the case of one message per each
            plate instance versus one message for the entire plate.
            
            If the channel is an array type, then there are three possible message types:
            1. If the channel is in a plate, then so is the message.
            2. If the channel is not in a plate, but individual messages are desired for each array element.
            If the channel is inside a plate, in which case it stores for an array of distributions.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageTransform.UseArrayHelperFill">
      <summary>
            If true, initialize arrays using ArrayHelper.Fill (makes the generated code more compact, but prevents moving some allocations into the Reset() method)
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageTransform.UseCopyOperators">
      <summary>
            If true, operators that return their argument are replaced by copy expressions.  Note this is required for certain tests to pass.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageTransform.hasNonUnitDerivative">
      <summary>
            The set of variables that have at least one definition with a non-unit derivative
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageTransform.onUpdate">
      <summary>
            Maps from variable/field declaration to increment statement, or null if loop ended before variable was updated.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageTransform.messageDirection">
      <summary>
            The current direction to use when converting variable references.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.AddMarginalStatements(System.Object,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Adds statements to declare and set the marginal of an inferred constant variable or method parameter.
            </summary>
      <param name="decl">
      </param>
      <param name="varRef">
      </param>
      <param name="outputs">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Only converts the contained statements in a for loop, leaving the initializer,
            condition and increment statements unchanged.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertCondition(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            Flatten out and remove if statements.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertMethodInvoke(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression)">
      <summary>
            This does the work of constructing all the operator calls for the given factor call
            </summary>
      <param name="imie">The method invoke expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ForEachOperatorStatement(System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Infer.IAlgorithm,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,System.Collections.Generic.IDictionary{System.String,MicrosoftResearch.Infer.Transforms.MessageTransform.MessageInfo},System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,System.Boolean},System.Boolean,System.Boolean,System.String)">
      <summary>
            Create an operator statement which computes the message to the specified argument, and invoke an action.
            </summary>
      <param name="action">Receives the generated statements</param>
      <param name="alg">The algorithm</param>
      <param name="info">Factor information</param>
      <param name="msgInfo">Dictionary of message information</param>
      <param name="methodSuffix">Suffix for the operator method</param>
      <param name="targetParameter">target argument name</param>
      <param name="argumentTypes">Argument types for the operator method</param>
      <param name="isStochastic">
      </param>
      <param name="isVariableFactor">Whether this is a variable factor</param>
      <param name="isInit">Whether the statement is an initializer</param>
      <param name="alternateSuffix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.CheckForCopyOperators(MicrosoftResearch.Infer.Transforms.MessageFcnInfo,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Checks to see if this operator is just copying one of its parameters and hence can be
            optimised away.
            </summary>
      <param name="fninfo">The operator function info</param>
      <param name="args">The operator arguments</param>
      <param name="msg">The expression for the LHS which will store the result of the operator</param>
      <returns>The new expression to compute the result of the operation, or null if the operator is not a copy</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.GetOperatorArguments(MicrosoftResearch.Infer.IAlgorithm,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,MicrosoftResearch.Infer.Transforms.MessageFcnInfo,MicrosoftResearch.Infer.Transforms.MessageTransform.MessageInfo,System.Collections.Generic.IDictionary{System.String,MicrosoftResearch.Infer.Transforms.MessageTransform.MessageInfo},System.Collections.Generic.IDictionary{System.String,System.Type},System.Collections.Generic.IDictionary{System.String,System.Boolean},System.Boolean)">
      <summary>
            Get the operator arguments for a specified operator method
            </summary>
      <param name="alg">The algorithm</param>
      <param name="info">Factor information</param>
      <param name="fcninfo">Operator method information</param>
      <param name="miTgt">The message info for the target argument</param>
      <param name="msgInfo">Message information for each field</param>
      <param name="argumentTypes">Argument types for the operator method</param>
      <param name="isStochastic">
      </param>
      <param name="isVariableFactor">Whether this is a variable factor</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.IsStochasticVariableReference(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the supplied expression is stochastic.  
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertVariableDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Convert a variable declaration expression. Each channel declaration expression
            is converted to a forward and a backward message declaration expression. Message
            array information for both directions is recorded
            </summary>
      <param name="ivde">The channel variable declaration expression</param>
      <returns>null</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.MakeDeclStatement(MicrosoftResearch.Infer.Transforms.ChannelInfo,MicrosoftResearch.Infer.Transforms.MessageArrayInformation)">
      <summary>
            Make the declaration statement for a message array variable
            </summary>
      <param name="channelInfo">The channel information</param>
      <param name="mai">The information for the message array variable</param>
      <returns>An assign expression or a declaration expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.DoConvertArray(MicrosoftResearch.Infer.Transforms.MessageDirection,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression,System.Int32,MicrosoftResearch.Infer.Transforms.ChannelInfo,MicrosoftResearch.Infer.Transforms.MessageTransform.ChannelToMessageInfo)">
      <summary>
            Construct an array creation expression and insert initialization statements
            </summary>
      <param name="direction">The message direction</param>
      <param name="inputTarget">Declaration of the variable on the LHS</param>
      <param name="outputLhs">Expression on the LHS</param>
      <param name="iace">Expression on the RHS</param>
      <param name="depth">Number of indices on the LHS</param>
      <param name="ci">
      </param>
      <param name="ctmi">Attribute of ivd</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertInitialiser(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Convert a raw initialiser expression (which may not be valid code) into a well-typed expression, possibly with "new PlaceHolder" on the outside.
            </summary>
      <param name="initialiser">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertInitialiser(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,MicrosoftResearch.Infer.CompilerAttributes.VariableInformation,System.Int32,System.Boolean)">
      <summary>
            Convert an initialiser expression (which may have "new PlaceHolder" on the outside) into a valid expression of the desired type.
            </summary>
      <param name="initialiser">
      </param>
      <param name="desiredType">
      </param>
      <param name="varInfo">
      </param>
      <param name="depth">
      </param>
      <param name="makeCopy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.FillArray(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Infer.CompilerAttributes.VariableInformation,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns a loop that explicitly initializes a flat array.
            </summary>
      <param name="outputLhs">The array to be initialized.</param>
      <param name="varInfo">variable info for the array.</param>
      <param name="dimensions">The dimensions of the array.</param>
      <param name="elementInit">An expression for the array elements.  May contain references to the array's index variables, as stored in ci.</param>
      <returns>
      </returns>
      <remarks>
            Because elementInit may refer to the array's index variables, the generated loop will use these variables, if they are available in ci.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.ConvertVariableRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Converts a variable reference into a message, by replacing it with a reference to
            the forward or backward message arrays.  Also retrieves information about the message array.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.GetDistributionType(System.Type,System.Type,System.Type,System.Boolean)">
      <summary>
            Convert an array type into a distribution type.
            </summary>
      <param name="arrayType">A scalar, array, multidimensional array, or IList type.</param>
      <param name="innermostElementType">Type of innermost array element (may be itself an array, if the array is compound).</param>
      <param name="newInnermostElementType">Distribution type to use for the innermost array elements.</param>
      <param name="useDistributionArrays">Convert outer arrays to DistributionArrays.</param>
      <returns>A distribution type with the same structure as <paramref name="arrayType" /> but whose element type is <paramref name="newInnermostElementType" />.</returns>
      <remarks>
            Similar to <see cref="M:MicrosoftResearch.Infer.Utils.Util.ChangeElementType(System.Type,System.Type)" /> but converts arrays to DistributionArrays.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.GetDistributionType(System.Type,System.Type,System.Type,System.Int32,System.Int32,System.Predicate{System.Int32})">
      <summary>
            Convert an array type into a distribution type, converting a specified number of inner arrays to DistributionArrays.
            </summary>
      <param name="arrayType">
      </param>
      <param name="innermostElementType">
      </param>
      <param name="newInnermostElementType">
      </param>
      <param name="depth">The current depth from the declaration type.</param>
      <param name="useDistributionArraysDepth">The number of inner arrays to convert to DistributionArrays</param>
      <param name="useFileArrayAtDepth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MessageTransform.FindChannelInfo(MicrosoftResearch.Infer.Transforms.MessageTransform.MessageInfo,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Set the channelDecl field via the attributes applied to channelRef.
            </summary>
      <param name="mi">
      </param>
      <param name="channelRef">
      </param>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageArrayInformation">
      <summary>
            Information about either the forwards or backwards message array
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.MessageArrayInformation.useCount">
      <summary>
            Number of times this variable is used as an argument to a message operator.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MessageDirection">
      <summary>
            Enumeration for labelling forward and backward messages.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.OperatorStatement">
      <summary>
            Attached to a statement to indicate that it may appear in a while loop, i.e. it updates a message.  A statement without this attribute cannot appear in a while loop.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IncrementStatement">
      <summary>
            Attached to a statement to indicate that it is an increment to a message, and attached to a variable to indicate that it has an increment statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.OperatorMethod">
      <summary>
            Attribute used to mark methods which contain operator statements (i.e. statements which are to be processed by the scheduler).
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.Initializer">
      <summary>
            Attached to statements to indicate that they will be overwritten by later statements, i.e. this is not the final value of the variable.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Initializer.UserInitialized">
      <summary>
            If true, this statement is initialized by the user.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.IsInferred">
      <summary>
            Attribute used to mark variables that appear as arguments to Infer()
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.DependsOnIteration">
      <summary>
            When applied to a method invoke expression, indicates that the execution of this
            expression depends on the iteration counter
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.DependsOnIteration.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.PlaceHolder">
      <summary>
            A type which can be used as a placeholder in a generic method reference.  It will be replaced
            by the dynamically specified type argument provided separately.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.MethodReference">
      <summary>
            Used to look up a method by its declaring type, its name, and its type parameters (if any).
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MethodReference.#ctor(System.Type,System.String,System.Type[])">
      <summary>
            Construct a method reference from a name and optional types.
            </summary>
      <param name="type">The type providing the method.</param>
      <param name="methodName">The name must specify the number of generic type parameters via the syntax <c>&lt;&gt;</c> or <c>&lt;,&gt;</c> etc.</param>
      <param name="parameterTypes">An array of types, which may contain null as a wildcard.</param>
      <remarks>
            If the method is generic with <c>n</c> type parameters, then the first <c>n</c> parameterTypes are interpreted
            as type arguments.  These can be null to allow arbitrary type arguments.
            Examples:
            <list type="bullet"><item><term><c>new MethodReference(typeof(Array),"Copy",typeof(Array),typeof(Array),typeof(Int32))</c></term><description>
            This selects the first overload of the non-generic method <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />.
            </description></item><item><term><c>new MethodReference(typeof(Array),"Copy",null,null,typeof(Int32))</c></term><description>
            This selects the same method as above, since the number of parameters and the type of the third parameter disambiguate the overload.
            </description></item><item><term><c>new MethodReference(typeof(Array),"Find")</c></term><description>
            This throws an exception since <see cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" /> is a generic method only.
            </description></item><item><term><c>new MethodReference(typeof(Array),"Find&lt;&gt;")</c></term><description>
            This selects the generic method <see cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />, without specifying any type arguments
            or parameter types.  This method is not overloaded so no disambiguation via parameter types is needed.
            </description></item><item><term><c>new MethodReference(typeof(Array),"Find&lt;&gt;",null)</c></term><description>
            This is equivalent to the above.  Adding two more nulls (corresponding to the two parameters of Find) would also be equivalent.
            </description></item><item><term><c>new MethodReference(typeof(Array),"Find&lt;&gt;",typeof(int))</c></term><description>
            This selects the generic method <see cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />, with type argument set to <c>int</c>.
            No parameter types are specified.  This method is not overloaded so no disambiguation via parameter types is needed.
            </description></item><item><term><c>new MethodReference(typeof(Array),"FindIndex&lt;&gt;",typeof(int),typeof(int[]),typeof(Predicate&lt;int&gt;))</c></term><description>
            This selects the first overload of the generic method <see cref="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />, with type argument set to <c>int</c>.
            </description></item><item><term><c>new MethodReference(typeof(Array),"FindIndex&lt;&gt;",typeof(int),null,null)</c></term><description>
            This selects the same method as above, since the number of parameters (two) disambiguates the overload.
            </description></item><item><term><c>new MethodReference(typeof(Array),"FindIndex&lt;&gt;",null,null,null)</c></term><description>
            This selects the first overload of the generic method <see cref="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />, without specializing on a type argument.
            </description></item></list></remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MethodReference.GetMethodInfo">
      <summary>
            Convert the MethodReference into a concrete MethodInfo.
            </summary>
      <returns>
      </returns>
      <exception cref="T:System.MissingMethodException">No methods of <c>this.Type</c> match the specification.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches (due to wildcards in the MethodReference).</exception>
      <exception cref="T:System.ArgumentException">A type argument does not satisfy the constraints of the generic method definition.</exception>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MethodReference.MatchesMethod(System.Reflection.MethodInfo)">
      <summary>
            Test if a MethodInfo satisfies the constraints of a MethodReference.
            </summary>
      <param name="method">A method to test.</param>
      <returns>True if the method satisfies the constraints.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MethodReference.MakeGenericMethod(System.Reflection.MethodInfo,System.Type[])">
      <summary>
            Same as <see cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />, but allows <c>null</c> as a wildcard.
            </summary>
      <param name="method">A generic method.</param>
      <param name="typeArguments">An array of types, some of which may be null.</param>
      <returns>A method with the non-null type arguments filled in.</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.MethodReference.ParseGenericMethodName(System.String,System.Int32@)">
      <summary>
            Parse a method name of the form <c>fun</c> or <c>fun&lt;&gt;</c> or <c>fun&lt;,&gt;</c>, etc.
            </summary>
      <param name="methodName">
      </param>
      <param name="typeParameterCount">
      </param>
      <returns>The raw method name with generic suffix removed.</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ModelAnalysisTransform">
      <summary>
            Transform which:
              Removes all methods other than the one containing the model.
              Calls to InferNet.PreserveWhenCompiled are stripped out.
              Switch cases with value less than zero are stripped out.
              Evaluate some expressions that contain literals.
              Processes and removes any Attrib static calls, replacing them with attributes on the appropriate code elements.
              Replace variables in condition blocks with their conditioned values.
              Determine and attach information about array variables.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ModelAnalysisTransform.compiledClassNames">
      <summary>
            Used to generate unique class names
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.ModelAnalysisTransform.inferCount">
      <summary>
            Number of variables marked for inference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ModelAnalysisTransform.ConvertMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            Analyses the method specified in MethodToTransform, if any.  Otherwise analyses all methods.
            </summary>
      <param name="imd">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ParallelForTransform">
      <summary>
            Converts for loops into Parallel.For() calls.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ParallelForTransform.ConvertFor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Converts for loops into parallel for loops.
            </summary>
      <param name="ifs">The for loop to convert</param>
      <returns>The converted statement</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.HasOffsetIndices">
      <summary>
            Attached to loops to indicate that some sub-statement has an offset on this loop index
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ParameterInsertionTransform">
      <summary>
            Replaces references to the parameters of a method with actual literal values.
            The parameters of the method are then removed.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.AccumulationTransform">
      <summary>
            Optimises message passing by removing redundant messages and operations.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.AccumulationTransform.tempVarCount">
      <summary>
            The number of temporary variables created.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.AccumulationInfo">
      <summary>
            Attached to methods.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.AccumulationInfo.containers">
      <summary>
            Containers of the original statement.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.PruningTransform">
      <summary>
            Remove statements whose result is never used by an output.  Also remove updates whose result is uniform.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.ReplicationTransform">
      <summary>
            Handles any replication made necessary by loops.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ReplicationTransform.ConvertArrayIndexer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
            Converts an array index expression to replicate variables referenced in a loop.
            </summary>
      <param name="iaie">The array indexer expression to convert</param>
      <returns>The new expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ReplicationTransform.GetOutermostLoopIndex(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get the index of the outermost loop in loops where expr can be evaluated.
            </summary>
      <param name="loops">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ReplicationTransform.NeedsContainer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if expr must be evaluated inside the given container.
            </summary>
      <param name="container">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ReplicationTransform.AddUnreplicatedIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.List{System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@)">
      <summary>
            Split expr into a target and extra indices, where target will be replicated and extra indices will be added later.
            </summary>
      <param name="loop">The loop we are replicating over</param>
      <param name="expr">Expression being replicated</param>
      <param name="indices">Modified to contain the extra indices</param>
      <param name="target">Prefix of expr to replicate</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.ReplicationTransform.IsConstantWrtLoops(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Returns true if ivd is constant for a given value of the loop variables in lc
            </summary>
      <param name="ivd">
      </param>
      <param name="constantLoopVars">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.cycles">
      <summary>
            Used for debugging
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.originalNode">
      <summary>
            Maps a node in g to a node in dg
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.newNode">
      <summary>
            Maps a node in dg to a node in g
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.originalEdge">
      <summary>
            Maps an edge in g to an edge in dg
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.directionsChanged">
      <summary>
            Indicates that the schedule needs to be recomputed.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.CheckGroups(System.Collections.Generic.IEnumerable{System.Int32},System.Int32[])">
      <summary>
            Check that the schedule satisfies the group constraints
            </summary>
      <param name="schedule">
      </param>
      <param name="groupOf">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.ForEachFinalizer(MicrosoftResearch.Infer.Transforms.DependencyGraph,System.Collections.Generic.IEnumerable{System.Int32},System.Action{System.Int32})">
      <summary>
            Invokes action on the statements that need to be executed at the end of the convergence loop.
            </summary>
      <param name="dg">
      </param>
      <param name="outputs">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.InitSchedule(System.Collections.Generic.List{System.Int32},System.Boolean,System.Boolean)">
      <summary>
            Select a subset of nodes from the dependency graph to execute prior to the iterSchedule.  IterationSchedule must have been called previously to set up the graph.
            </summary>
      <param name="iterSchedule">The iteration schedule</param>
      <param name="mustInitBackwardEdges">If true, will reconstruct all backward messages (for UseSpecialFirst)</param>
      <param name="ignoreInitializedNodes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.LabelInitializedEdges(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Label unknown edges to make the most use of user-provided initializations
            </summary>
      <param name="initializedNodes">
      </param>
      <param name="initializerChildren">Children of user-initialized nodes</param>
      <param name="initializerDescendants">Modified to contain sink nodes reachable from user-inits via forward edges</param>
      <remarks>
            Algorithm: Find a path from any user-initialized node to any backwardInSchedule edge, where the path
            contains no backward edges and at least one unlabeled edge.  Label these edges forward, and repeat until no more paths
            can be found.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.FindUnlabeledEdges(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Label unknown edges on a path from a user-initialized node to a backwardInSchedule edge
            </summary>
      <param name="initializedNodes">
      </param>
      <param name="initializerChildren">Children of user-initialized nodes</param>
      <param name="initializerDescendants">Modified to contain sink nodes reachable from user-inits via forward edges</param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.AssignLabelsByMinCut(MicrosoftResearch.Infer.Collections.Set{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32},MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Rotate the back edges around each cycle to minimize the number of back edges with Required annotations
            </summary>
      <remarks>
            Algorithm: Construct a flow graph representing all possible rotations and find a min cut.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.GetEdgeCost(System.Int32)">
      <summary>
            Get the heuristic cost of making an edge backward in the iteration schedule
            </summary>
      <param name="edge">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.GetEdgeCosts3">
      <summary>
            Compute the cost of reversing each edge, before any edges have been labeled.  For each cycle that the edge is on, we add 1/(length of cycle).
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.FindNewBackEdge(System.Single[],MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Find the cycle whose cheapest unlabeled edge has the highest cost among all cycles, and return that edge.
            </summary>
      <param name="edgeCost">
      </param>
      <param name="forcedForwardEdges">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.UpdateCostsInit(System.Single[],System.Int32,System.Boolean)">
      <summary>
            Compute the reversal cost, i.e. to be labeled backward, for every edge into target
            </summary>
      <param name="edgeCost">
      </param>
      <param name="target">
      </param>
      <param name="inSteadyState">true if we are scoring edges in the steady-state schedule</param>
      <remarks>
            A required edge has infinite cost.
            An edge in an Any group whose alternatives are all backward has infinite cost.
            If an alternative is unlabeled, the cost is 1/(group size).
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.UpdateCostsInit(System.Single[])">
      <summary>
            Update all costs affected by the edges in newBackEdges and newForwardEdges
            </summary>
      <param name="edgeCost">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.PropagateConstraints(System.Boolean)">
      <summary>
            Set the direction of edges whose label is forced by existing labels.  todo contains all newly labeled edges.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.IsRequired(System.Int32,System.Boolean)">
      <summary>
            Check if an edge in g is required in dg.dependencyGraph
            </summary>
      <param name="edge">
      </param>
      <param name="includeAny">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.GetLargestGroupExcluding(System.Int32,MicrosoftResearch.Infer.Collections.Set{System.Int32})">
      <summary>
            Get the largest group of node (including node itself) that is not in the set.
            </summary>
      <param name="node">
      </param>
      <param name="set">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.GetSmallestGroup(System.Int32,System.Predicate{System.Int32})">
      <summary>
            Get the smallest group of node (including node itself) that satisfies the predicate, or -1 if none 
            </summary>
      <param name="node">
      </param>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.Scheduling2Transform.DoubleToString(System.Double)">
      <summary>
            Represents a double to (at least) one digit of precision, using the minimum number of characters
            </summary>
      <param name="x">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.CycleFinder2`2.SearchFrom(`0,`0)">
      <summary>
            Find cycles containing root 
            </summary>
      <param name="node">
      </param>
      <param name="root">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform">
      <summary>
            Sets VariableInformation.isStochastic, converts constants in random contexts into distributions, and attaches MarginalPrototype attributes.
            </summary>
      <remarks>
            DistributionAnalysis must be part of this transform in order to correctly convert constants.  
            Otherwise, you would have to execute multiple rounds of StocAnalysis and DistributionAnalysis.
            This is because converting a constant may use knowledge about the MarginalPrototype (if it exists) 
            and it may influence the choice of MarginalPrototype (if it is not known yet).
            Ideally, we would not need to convert constants, but that would require significant changes to later transforms.
            </remarks>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.MarginalPrototypeVariable">
      <summary>
            Attached to generated variables that store marginal prototypes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.InferMarginalPrototype(MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression,System.Boolean)">
      <summary>
            Sets the MarginalPrototype attribute of the target variable of an assign expression.
            </summary>
      <param name="iae">
      </param>
      <param name="targetHasLiteralIndices">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.GetMarginalPrototype(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Object)">
      <summary>
            Get the marginal prototype of an expression, with all indices substituted.
            </summary>
      <param name="source">A variable reference or array indexer expression</param>
      <param name="targetDecl">A variable or parameter declaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.ReplaceIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Object)">
      <summary>
            If expr has indices which are not indexVars of the target, replace them with zeros.
            </summary>
      <param name="expr">
      </param>
      <param name="targetDecl">The target</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.ReplaceIndices(MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            If expr has indices which reference variables not in loopVars, replace the indices with zeros. 
            </summary>
      <param name="containers">
      </param>
      <param name="keepVars">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.ReplaceVarsNotContained(MicrosoftResearch.Infer.CompilerAttributes.Containers,MicrosoftResearch.Infer.Collections.Set{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            If expr has references to variables not in containers, replace them with zeros.
            </summary>
      <param name="containers">Containers of variables to keep</param>
      <param name="keepVars">
      </param>
      <param name="expr">Input expression</param>
      <returns>expr or a new expression with variables replaced.</returns>
      <remarks>Only direct variable references or indices are replaced.</remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.StocAnalysisTransform.GetIntCardinalityExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Object)">
      <summary>
            Given an integer expression, returns an expression for the maximum value plus 1.
            </summary>
      <param name="source">
      </param>
      <param name="targetDecl">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation">
      <summary>
            Describes a variable in MSL (random, constant, or loop variable)
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.sizes">
      <summary>
            Stores the lengths that were used to define an array in MSL.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.indexVars">
      <summary>
            For jagged arrays, the index variables used in the loops corresponding to the above sizes.
            </summary>
      <remarks>
            May contain null elements for indices that are not variables.
            </remarks>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.IsStochastic">
      <summary>
            True if this is a stochastic variable.  False for constants and loop variables.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.LiteralIndexingOnly">
      <summary>
            If true, this variable is an array that always appears indexed by literals at the top level
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.SetIndexVariablesAtDepth(System.Int32,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration[],System.Boolean)">
      <summary>
            Provide missing index variables.
            </summary>
      <param name="depth">Bracket depth (0 is first bracket)</param>
      <param name="vars">May contain null entries for indices that are not variables.</param>
      <param name="allowMismatch">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.GetVariableInformation(MicrosoftResearch.Transforms.BasicTransformContext,System.Object)">
      <summary>
            Gets the VariableInformation attribute of ivd, or creates one if it doesn't already exist
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.SetMarginalPrototypeFromAttribute(MicrosoftResearch.Infer.MarginalPrototype,System.Boolean)">
      <summary>
            Sets the marginal prototype from a supplied MarginalPrototype attribute.
            If this is null, attempts to set the marginal prototype automatically.
            </summary>
      <param name="mpa">
      </param>
      <param name="throwIfMissing">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.DeriveArrayVariable(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Transforms.BasicTransformContext,System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,System.Collections.Generic.IList{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}},System.Collections.Generic.IList{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}})">
      <summary>
            Create an array of this variable type, optionally after slicing it.
            </summary>
      <param name="addTo">
      </param>
      <param name="context">
      </param>
      <param name="name">Name of the new variable.</param>
      <param name="arraySize">Length of the array.  May be null.</param>
      <param name="newIndexVar">Name of a new integer variable used to index the array.  May be null if arraySize is null.</param>
      <param name="indices">Indices applied to this, before creating the array.  May be null.  May contain wildcards.</param>
      <param name="wildcardVars">Loop variables to use for wildcards.  May be null if there are no wildcards.</param>
      <remarks>
            The new array is indexed by wildcards first, then newIndexVar, then the indices remaining from the original array.
            For example, if original array is indexed [i,j][k,l][m,n] and indices = [*,*][3,*] then 
            the new array is indexed [wildcard0,wildcard1][wildcard2][newIndexVar][m,n] where sizes and marginalPrototype have expressions replaced according
            to (i=wildcard0, j=wildcard1, k=3, l=wildcard2).
            </remarks>
      <returns>A new array of depth <c>(arraySize != null) + ArrayDepth - indices.Count + wildcardVars.Count</c></returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.DeriveIndexedVariable(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Transforms.BasicTransformContext,System.String,System.Collections.Generic.List{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}})">
      <summary>
            Create a slice of this variable array, where all indices up to a certain depth are given.
            </summary>
      <param name="addTo">
      </param>
      <param name="context">
      </param>
      <param name="name">Name of the new variable array</param>
      <param name="indices">Expressions used to index the variable array.</param>
      <returns>The declaration of the new variable.</returns>
      <remarks>
            For example, suppose we want to slice a[i][2][j][k] into b[j][k].
            Then <paramref name="name" />="b", <paramref name="indices" />=<c>[i][2]</c>.
            </remarks>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.ReplaceIndexVars(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IList{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}},System.Collections.Generic.IList{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}},System.Int32@)">
      <summary>
            Replace all indexVars which appear in expr with the given indices.
            </summary>
      <param name="context">
      </param>
      <param name="expr">Any expression</param>
      <param name="indices">A list of lists of index expressions (one list for each indexing bracket).</param>
      <param name="wildcardIndices">Expressions used to replace wildcards.  May be null if there are no wildcards.</param>
      <param name="replaceCount">Incremented for each replacement.</param>
      <returns>A new expression.</returns>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.VariableInformation.ArrayDepth">
      <summary>
            Returns the array depth of this variable.  This is the number of pairs of square brackets needed
            to fully index the variable i.e. 0 for a non-array, 1 for x[] or x[,], 2 for x[][] or x[,][] or x[,][,] etc. 
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Transforms.VariableTransform">
      <summary>
            Inserts a variable factor at every place that a variable is assigned to, cloning the variable into a definition, use, and marginal.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Transforms.VariableTransform.ConvertInfer(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression)">
      <summary>
            Modify the argument of Infer to be the marginal channel variable i.e. Infer(a) transforms to Infer(a_marginal)
            </summary>
      <param name="imie">
      </param>
      <returns>The modified expression</returns>
    </member>
    <member name="T:MicrosoftResearch.Infer.Views.ExamplesViewer">
      <summary>
            A view of a set of examples or tutorials which shows both source code and program output.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Views.ExamplesViewer.exampleType">
      <summary>
            Field for ExampleType property
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.#ctor(MicrosoftResearch.Infer.IAlgorithm[])">
      <summary>
            Creates an examples viewer.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.#ctor(System.Type,MicrosoftResearch.Infer.IAlgorithm[])">
      <summary>
            Creates a view of the examples in the same assembly as the supplied type.
            </summary>
      <param name="exampleType">The type to use to find example classes</param>
      <param name="algs">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.OnSelectionChanged">
      <summary>
            Selection changed handler
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.PrintWithSyntaxHighlighting(MicrosoftResearch.Infer.Views.EfficientTextBox,System.String)">
      <summary>
            Very simple syntax highlighting
            </summary>
      <param name="targetTextBox">
      </param>
      <param name="s">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.OnExampleTypeChanged">
      <summary>
            Called when the example type changes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.Compare(System.Windows.Forms.TreeNode,System.Windows.Forms.TreeNode)">
      <summary>
            Compare two tree nodes
            </summary>
      <param name="x">First node</param>
      <param name="y">Second node</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.AppendOutputText(System.String)">
      <summary>
            Append output text
            </summary>
      <param name="s">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ExamplesViewer.Run">
      <summary>
            Run the browser
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Views.ExamplesViewer.SelectedExample">
      <summary>
            The currently selected example.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Infer.Views.ExamplesViewer.ExampleType">
      <summary>
            The type to use to find examples - the assembly containing this type will be searched.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Views.GUITextWriter">
      <summary>
            Used to redirect console output to a text box
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Views.FactorManagerView">
      <summary>
            Provides a view of the factors available to Infer.NET and their level of support
            for different inference algorithms.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern">
      <summary>
            Represents a pattern of stochasticity in the arguments and return value
            of a function.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern.IsStochasticFactorOnly">
      <summary>
            Is the pattern (D D D) -&gt; S?
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern.IsAssignableFrom(Microsoft.Dynamic.GenericParameterFactory.Constraints,Microsoft.Dynamic.GenericParameterFactory.Constraints)">
      <summary>
            True if c2 is more constrained than c1.
            </summary>
      <param name="c1">
      </param>
      <param name="c2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern.Intersect(MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern)">
      <summary>
            Create a new pattern whose opTypes are the intersection of corresponding opTypes
            </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern.IntersectTypes(System.Type,System.Type)">
      <summary>
            Get a type which is the most specific of the input types.
            </summary>
      <param name="t1">
      </param>
      <param name="t2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.GetAlgorithmPatterns(MicrosoftResearch.Infer.IAlgorithm,MicrosoftResearch.Infer.Transforms.FactorManager.FactorInfo,System.Boolean,MicrosoftResearch.Infer.QualityBand@,MicrosoftResearch.Infer.QualityBand@,MicrosoftResearch.Infer.QualityBand@)">
      <summary>
            Returns a collection of possible type patterns for the fields of info.  Patterns may be incomplete.
            </summary>
      <param name="alg">
      </param>
      <param name="info">
      </param>
      <param name="ShowMissingEvidences">
      </param>
      <param name="minQB">The minimum quality band attached to an operator for this factor</param>
      <param name="modeQB">The most common quality band attached to operators for this factor</param>
      <param name="maxQB">The maximum quality band attached to operators for this factor</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.IntersectPatterns(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern})">
      <summary>
            Create a new set of patterns containing the closure of all pairwise intersections of patterns.
            </summary>
      <param name="patterns">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.AddIntersections(System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern})">
      <summary>
            Modify the collection by adding all pairwise intersections of patterns.
            </summary>
      <param name="patterns">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.FactorManagerView.AddDeterministicPatterns(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Views.FactorManagerView.StochasticityPattern})">
      <summary>
            Expand the list of patterns by substituting each stochastic type with a deterministic type.
            </summary>
      <param name="patterns">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Infer.Views.ModelView.WriteDgml(System.String)">
      <summary>
            Write the graph to a file in DGML format
            </summary>
      <param name="path">
      </param>
    </member>
    <member name="P:MicrosoftResearch.Infer.Views.ModelView.Model">
      <summary>
            The model being shown in the view
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.Views.TaskGraphView">
      <summary>
            A view of a task graph, which is a schedule when the tasks are message computations.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Infer.Views.TaskGraphView.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.AttributeRegistry`2">
      <summary>
            An attribute registry allows attributes to be associated with objects.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.AttributeRegistry`2.registry">
      <summary>
            The attribute registry - dictionary from objects to attributes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.#ctor(System.Boolean)">
      <summary>
            Attribute registry constructor
            </summary>
      <param name="useIdentityEquality">Attributes are consider equal if they reference the same instance</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.GetAll``1(`0)">
      <summary>
            Returns the attributes of type T associated with the specified object. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.HasAttributes(`0)">
      <summary>
            Whether a given object has attributes
            </summary>
      <param name="obj">The object</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.CopyObjectAttributesTo(`0,MicrosoftResearch.Transforms.AttributeRegistry{`0,`1},`0)">
      <summary>
            Copies object attributes associated with source object
            to target object in a target registry
            </summary>
      <param name="sourceObject">Source object</param>
      <param name="targetRegistry">Target registry</param>
      <param name="targetObject">Target object</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.CopyObjectAttributesTo``1(`0,MicrosoftResearch.Transforms.AttributeRegistry{`0,`1},`0)">
      <summary>
            Copies object attributes of type T associated with source object
            to target object in a target registry
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="sourceObject">Source object</param>
      <param name="targetRegistry">Target registry</param>
      <param name="targetObject">Target object</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.Remove``1(`0)">
      <summary>
            Removes all attributes of the specified object assignable to class T.
            </summary>
      <typeparam name="T">Specified type</typeparam>
      <param name="obj">Specified object</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.RemoveOfType(`0,System.Type)">
      <summary>
            Removes all attributes of the specified object assignable to class T.
            </summary>
      <param name="obj">Specified object</param>
      <param name="t">Specified type</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.Has``1(`0)">
      <summary>
            Whether an object has an attribute of a particular type
            </summary>
      <typeparam name="T">The type</typeparam>
      <param name="obj">The object</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.Get``1(`0)">
      <summary>
            Gets the first attribute of a given type or returns null if none.
            </summary>
      <typeparam name="T">The type</typeparam>
      <param name="obj">The object</param>
      <returns>The attribute or null</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.GetOrCreate``1(`0,System.Func{``0})">
      <summary>
            Gets an attribute of a given type, or creates one if it doesn't already exist
            </summary>
      <typeparam name="T">The type</typeparam>
      <param name="obj">The object</param>
      <param name="generator">
      </param>
      <returns>The attribute</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.Set(`0,`1)">
      <summary>
            Registers an attribute against the specified object.
            </summary>
      <param name="obj">The object to associate the attribute with</param>
      <param name="attr">The attribute to associate</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.GetEnumerator">
      <summary>
            Gets an enumerator that iterates through the attribute registry
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.WriteTo(System.IO.TextWriter)">
      <summary>
            Write out the resgistry and the keyed registry to a text writer
            </summary>
      <param name="writer">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.WriteObjectAttributesTo(`0,System.IO.TextWriter)">
      <summary>
            Write out the attributes of a specified object to a text writer
            </summary>
      <param name="obj">
      </param>
      <param name="writer">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.AttributeRegistry`2.Clone">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.AttributeRegistry`2.IsIdentityEquality">
      <summary>
      </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.StackContext">
      <summary>
            A transformation context whose state at a point in the transformation is given by a stack.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.StackContext.InputStack">
      <summary>
            Stack holding transformation info for elements on the path down the input tree to the 
            input cursor (the location currently being transformed).
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestor``1">
      <summary>
            Finds the closest ancestor of the specified type (or assignable to that type) in the input path.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestorNotSelf``1">
      <summary>
            Finds the closest ancestor of the specified type (or assignable to that type) in the input path, excluding the current item.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestorIndex``1">
      <summary>
            Finds the index of the closest ancestor of the specified type (or assignable to that type) in the input path, or -1 if none.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestorNotSelfIndex``1">
      <summary>
            Finds the index of the closest ancestor of the specified type (or assignable to that type) in the input path.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindTopAncestorIndex``1">
      <summary>
            Finds the index of the highest ancestor of the specified type (or assignable to that type) in the input path.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.GetAncestor(System.Int32)">
      <summary>
            Returns the ancestor object at the specified index in the transformation stack.
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.GetAncestorIndex(System.Object)">
      <summary>
            Returns the index in the transformation stack of the specified ancestor object,
            or -1 if the object is not an ancestor.
            </summary>
      <param name="ancestor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestors``1">
      <summary>
            Finds all ancestors assignable to type T, in high-to-low order.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestors``1(System.Int32)">
      <summary>
            Finds all ancestors assignable to type T, in high-to-low order, up to and *excluding* the specified ancestor index.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindAncestorsBelow``1(System.Int32)">
      <summary>
            Finds all ancestors assignable to type T, in high-to-low order, whose index is greater than the specified ancestor index.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindTopAncestor``1">
      <summary>
            Finds the highest ancestor of the specified type (or assignable to that type) in the input path.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.FindOutputForAncestor``2">
      <summary>
            Returns the transformed output for the closest ancestor of the specified type.
            </summary>
      <typeparam name="TAnc">
      </typeparam>
      <typeparam name="TTransformed">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.GetOutputForAncestorIndex``1(System.Int32)">
      <summary>
            Returns the transformed output for the ancestor at the specified index.
            </summary>
      <typeparam name="TTransformed">
      </typeparam>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementBeforeAncestorIndex(System.Int32,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Boolean)">
      <summary>
            Adds a statement immediately before the output element for the ancestor index given.
            </summary>
      <param name="ancInd">
      </param>
      <param name="stmt">
      </param>
      <param name="convertBeforeAdding">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementsBeforeAncestorIndex(System.Int32,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Boolean)">
      <summary>
            Adds statements immediately before the output element for the ancestor index given.
            </summary>
      <param name="ancInd">
      </param>
      <param name="stmts">
      </param>
      <param name="convertBeforeAdding">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementBeforeCurrent(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Adds a statement immediately before the statement currently being processed.
            </summary>
      <param name="statementToAdd">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementAfterCurrent(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Adds a statement which will be inserted after the current statement has been transformed.
            </summary>
      <param name="statementToAdd">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementAfter(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Adds a statement after the statement which is currently being processed.
            </summary>
      <param name="ancestorStatement">
      </param>
      <param name="statementToAdd">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementsAfter(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Adds a collection of statements after the statement which is currently being processed. 
            </summary>
      <param name="ancestorStatement">
      </param>
      <param name="statementsToAdd">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementAfterAncestorIndex(System.Int32,MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Boolean)">
      <summary>
            Adds a statement after the ancestor statement at the specified index index, optionally converting
            the statement before it is added.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.AddStatementsAfterAncestorIndex(System.Int32,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},System.Boolean)">
      <summary>
            Adds mulitple statements after the ancestor statement at the specified index index, optionally converting
            the statement before it is added.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.StackContext.SetPrimaryOutput(System.Object)">
      <summary>
            Sets the primary output of the last opened input object.  
            </summary>
      <param name="outputItem">
      </param>
      <remarks>
            This should be called when converting objects that contain other statements, before converting those statements.  
            For objects that do not contain statements, it is unnecessary.
            </remarks>
    </member>
    <member name="P:MicrosoftResearch.Transforms.StackContext.Depth">
      <summary>
            The depth of the current point in the transformation
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.BasicTransformContext.trackTransform">
      <summary>
            Indicates if the association between input and output elements should be stored.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.BasicTransformContext.outputOfElement">
      <summary>
            The output of each input element.  Collected only if trackTransform=true.  Used by DeclarationView.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.BasicTransformContext.OutputStack">
      <summary>
            The output of each input element on the InputStack.  Updated only if trackTransform=true.  Used by DeclarationView.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.BasicTransformContext.Open(System.Object)">
      <summary>
            Opens the input object for transforming.
            </summary>
      <param name="inputItem">Input code element</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.BasicTransformContext.Close(System.Object)">
      <summary>
            Closes the current input object, indicating that its transformation has been completed.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.TransformInfo">
      <summary>
            Class which maintains the transformation state of a code element
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.TransformInfo.primaryOutput">
      <summary>
            Used by child statements to access the output of a container.  The full set of outputs is stored in a TransformOutput object on the OutputStack.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.TransformOutput">
      <summary>
            Holds the output elements of a transformed code element.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeBuilder">
      <summary>
            Singleton class to help build class declarations.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeBuilder.Recognizer">
      <summary>
            Helps recognize code patterns
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeBuilder.replacement">
      <summary>
            Character replacements to make valid strings.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeBuilder.illegalChars">
      <summary>
            Array of illegal characters
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeBuilder.defaultTypeDecl">
      <summary>
            Default type declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ToType(MicrosoftResearch.Transforms.IDotNetType)">
      <summary>
            Converts a code model type into a System.Reflection Type.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ToTypeName(MicrosoftResearch.Transforms.IDotNetType)">
      <summary>
            Get assembly qualified dotNET type name
            </summary>
      <param name="it">Code mode type</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ToMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Converts a code model method reference to a MethodBase
            </summary>
      <param name="imr">Method reference</param>
      <returns>Returns MethodBase if conversion is successful, null otherwise</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ToMethodThrows(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Converts a code model method reference to a MethodBase
            </summary>
      <param name="imr">Method reference</param>
      <returns>Returns MethodBase if conversion is successful, throws an exception otherwise</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ToMethodInternal(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Convert a reflector type reference to a MethodInfo
            </summary>
      <param name="imr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FindNonGenericMethod(System.Type,System.String,System.Type[],System.Type,System.Reflection.BindingFlags)">
      <summary>
            Find non-generic method
            </summary>
      <param name="tp">Declaring type</param>
      <param name="methodName">Method name</param>
      <param name="parameterTypes">Parameter types</param>
      <param name="returnType">Return type - needed for some internal signatures</param>
      <param name="bf">Binding flags</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FindGenericMethod(System.Type,System.String,System.Type[],System.Type[],System.Type,System.Reflection.BindingFlags)">
      <summary>
            Find a method from its type method name, type arguments and parameter types
            </summary>
      <param name="type">The declaring type of the method</param>
      <param name="methodName">The name of the method</param>
      <param name="typeArguments">The type arguments</param>
      <param name="parameterTypes">The parameter types</param>
      <param name="returnType">The return type</param>
      <param name="bf">The binding flags</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldDecl(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a new field declaration
            </summary>
      <param name="name">Name of the field</param>
      <param name="type">Code model type</param>
      <param name="declaringType">Declaring type</param>
      <returns>Field declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a new field declaration
            </summary>
      <param name="name">Name of the field</param>
      <param name="type">Code model type</param>
      <param name="declaringType">Declaring type</param>
      <returns>Field declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a new field declaration
            </summary>
      <param name="name">Name of the field</param>
      <param name="type">Code model type</param>
      <param name="declaringType">Declaring type</param>
      <param name="initializer">Initializer expression</param>
      <returns>Field declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration)">
      <summary>
            Creates a field reference expression
            </summary>
      <param name="fd">Field declaration</param>
      <returns>Field reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,System.String)">
      <summary>
            Creates a field reference expression
            </summary>
      <param name="target">Expression for type instance</param>
      <param name="declaringType">Declaring type</param>
      <param name="name">Field name</param>
      <returns>Field reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,System.String)">
      <summary>
            Creates a field reference expression
            </summary>
      <param name="target">Expression for type instance</param>
      <param name="declaringType">Declaring type</param>
      <param name="fieldType">Type of field</param>
      <param name="name">Field name</param>
      <returns>Field reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CanCastExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type)">
      <summary>
            Creates an 'is' expression
            </summary>
      <param name="expr">Expression</param>
      <param name="t">Type to test against</param>
      <returns>'is' expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CanCastExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates an 'is' expression
            </summary>
      <param name="expr">Expression</param>
      <param name="t">Type to test against</param>
      <returns>'is' expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CastExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type)">
      <summary>
            Creates a cast expression
            </summary>
      <param name="expr">Expression</param>
      <param name="t">Type to cast it to</param>
      <returns>Cast expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CastExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a cast expression
            </summary>
      <param name="expr">Expression</param>
      <param name="t">Type to cast it to</param>
      <returns>Cast expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ExprStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates an expression statement
            </summary>
      <param name="expr">The expression</param>
      <returns>Expression statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRef(System.Type)">
      <summary>
            Creates a type reference
            </summary>
      <param name="t">The dotNET type</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRef(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType[])">
      <summary>
            Create a type reference
            </summary>
      <param name="name">Name of the type</param>
      <param name="typeArguments">Type arguments</param>
      <returns>Type reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRef(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType[])">
      <summary>
            Creates a type reference
            </summary>
      <param name="name">Name of the reference</param>
      <param name="t">Type</param>
      <param name="outerClass">The owner type if this is a generic parameter type</param>
      <param name="typeArguments">Type arguments</param>
      <returns>Type reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRef(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a type reference
            </summary>
      <param name="name">Name of the reference</param>
      <param name="t">Type</param>
      <param name="outerClass">The owner type if this is a generic parameter type</param>
      <returns>Type reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Create a type reference expression
            </summary>
      <param name="type">A type reference</param>
      <returns>Type reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRefExpr(System.Type)">
      <summary>
            Create a type reference expression
            </summary>
      <param name="type">A type</param>
      <returns>Type reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static method
            </summary>
      <param name="imr">Method reference</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticMethod(System.Delegate,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static method
            </summary>
      <param name="d">Delegate for the method</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticMethod(System.Reflection.MethodInfo,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static method
            </summary>
      <param name="mi">MethodInfo instance</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Method(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Reflection.MethodInfo,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a method
            </summary>
      <param name="target">Instance for method call</param>
      <param name="mi">Method info</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Method(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a method
            </summary>
      <param name="target">Instance for method call</param>
      <param name="imd">Method declaration</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Method(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a method
            </summary>
      <param name="target">Instance for method call</param>
      <param name="imr">Method reference</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticGenericMethod(System.Delegate,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static generic method
            </summary>
      <param name="d">The delegate</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticGenericMethod(System.Reflection.MethodInfo,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static generic method
            </summary>
      <param name="mi">The MethodInfo</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticGenericMethod(System.Delegate,System.Type[],MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static generic method by replacing the type arguments in the method referred to by the delegate
            with the specified arguments.  This allows the method to be referred to statically even when the generic arguments
            are not known at compile-time.  By convention, the type arguments of the delegate method should be object or the highest
            level class which satisifies the type constraints.
            </summary>
      <param name="d">Delegate</param>
      <param name="replacementGenericArgs">Replacement generic arguments</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StaticGenericMethod(System.Delegate,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType[],MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates a call to a static generic method by replacing the type arguments in the method referred to by the delegate
            with the specified arguments.  This allows the method to be referred to statically even when the generic arguments
            are not known at compile-time.  By convention, the type arguments of the delegate method should be object or the highest
            level class which satisifies the type constraints.
            </summary>
      <param name="d">Delegate</param>
      <param name="replacementGenericArgs">Replacement generic arguments</param>
      <param name="args">Argument expressions</param>
      <returns>The method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRefArray(System.Collections.Generic.IList{System.Type})">
      <summary>
            Creates an array of type references
            </summary>
      <param name="types">List of types</param>
      <returns>The array of types</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodRef(System.Reflection.MethodInfo)">
      <summary>
            Creates a method reference
            </summary>
      <param name="mi">MethodInfo</param>
      <returns>Method reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.GenericMethodRef(System.Reflection.MethodInfo)">
      <summary>
            Creates a generic method reference
            </summary>
      <param name="mi">MethodInfo</param>
      <returns>Method reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ConstructorDecl(MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration[])">
      <summary>
            Creates a constructor declaration
            </summary>
      <param name="vis">Visibility of the constructor</param>
      <param name="declaringType">Type being constructed</param>
      <param name="pars">Parameters of the constructor</param>
      <returns>The constructor declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ConstructorRef(System.Type,System.Type[])">
      <summary>
            Creates a constructor reference
            </summary>
      <param name="t">Type</param>
      <param name="types">Parameter types for the constructor</param>
      <returns>The constructor reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodDecl(MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration[])">
      <summary>
            Create a method declaration
            </summary>
      <param name="vis">Method visibility</param>
      <param name="name">Method name</param>
      <param name="returnType">Method's return type</param>
      <param name="declaringType">Method's declaring type</param>
      <param name="pars">Method parameters</param>
      <returns>The method declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodDecl(MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration[])">
      <summary>
            Create a method declaration
            </summary>
      <param name="vis">Method visibility</param>
      <param name="name">Method name</param>
      <param name="returnType">Method's return code model type</param>
      <param name="declaringType">Method's declaring code model type</param>
      <param name="pars">Method parameters</param>
      <returns>The method declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.GenericMethodDecl(MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericParameter},MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration[])">
      <summary>
            Create a generic method declaration
            </summary>
      <param name="vis">Method visibility</param>
      <param name="name">Method name</param>
      <param name="returnType">Method's return code model type</param>
      <param name="declaringType">Method's declaring code model type</param>
      <param name="genericParams">Type parameters in order</param>
      <param name="pars">Method parameters</param>
      <returns>The method declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Return(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a return statement
            </summary>
      <param name="expr">Expression for return statement</param>
      <returns>The method return statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Return">
      <summary>
            Creates a return statement with no arguments
            </summary>
      <returns>The method return statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.LiteralExpr(System.Object)">
      <summary>
            Creates a literal expression
            </summary>
      <param name="value">The value of the literal expression</param>
      <returns>The literal expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BinaryExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a binary expression
            </summary>
      <param name="left">The expression to the left of the binary operator</param>
      <param name="op">The binary operator</param>
      <param name="right">The expression to the right of the binary operator</param>
      <returns>The binary expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.UnaryExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a unary expression
            </summary>
      <param name="op">The unary operator</param>
      <param name="expr">The input expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Add(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates an expression which is the sum of the given expressions
            </summary>
      <param name="exprs">Input expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BinaryExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates an expression consisting of combining several expressions using
            a given binary operator
            </summary>
      <param name="op">The binary operator</param>
      <param name="exprs">The expressions</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NotExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a boolean NOT expression
            </summary>
      <param name="expr">The expression to the right of the operator</param>
      <returns>The unary expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AnonMethodExpr(System.Type)">
      <summary>
            Creates an anonymous method expression
            </summary>
      <param name="delegateType">The delegate type</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayType(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates an array type (of dimenion 1)
            </summary>
      <param name="type">Element type</param>
      <returns>Array type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayType(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,System.Int32)">
      <summary>
            Creates an array type
            </summary>
      <param name="type">Element type</param>
      <param name="rank">Rank of array</param>
      <returns>Array type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayCreateExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates an array expression
            </summary>
      <param name="type">Element type of array</param>
      <param name="sizes">Sizes of each dimension</param>
      <returns>Array expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayCreateExpr(System.Type,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Creates an array expression
            </summary>
      <param name="type">Element type of array</param>
      <param name="sizes">Sizes of each dimension</param>
      <returns>Array expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayCreateExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Creates an array expression
            </summary>
      <param name="type">Element type of array</param>
      <param name="sizes">Sizes of each dimension</param>
      <returns>Array expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayCreateExpr(System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates an array expression
            </summary>
      <param name="type">Element type of array</param>
      <param name="sizes">Sizes of each dimension</param>
      <returns>Array expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayIndex(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates an array index expression
            </summary>
      <param name="array">The array expression</param>
      <param name="indices">The indices</param>
      <returns>Array index expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayIndex(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Creates an array index expression
            </summary>
      <param name="array">The array expression</param>
      <param name="indices">The indices</param>
      <returns>Array index expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeOf(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a typeof expression
            </summary>
      <param name="t">Type</param>
      <returns>Typeof expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NewObject(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates object creation expression
            </summary>
      <param name="t">Type to create</param>
      <param name="pars">Expressions for constructor parameters</param>
      <returns>Object create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NewObject(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Creates object creation expression
            </summary>
      <param name="t">Type to create</param>
      <param name="iec">Exprssions for constructor parameters</param>
      <returns>Object create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NewObject(System.Type,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Creates object creation expression
            </summary>
      <param name="t">Type to create</param>
      <param name="iec">Exprssions for constructor parameters</param>
      <returns>Object create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NewObject(System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[])">
      <summary>
            Creates object creation expression
            </summary>
      <param name="t">Type to create</param>
      <param name="args">Expressions for constructor parameters</param>
      <returns>Object create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReference)">
      <summary>
            Creates a variable reference expression
            </summary>
      <param name="ivr">Variable reference</param>
      <returns>Variable reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarRefExprArray(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Creates an array of variable reference expressions
            </summary>
      <param name="ivr">A list of variable declarations</param>
      <returns>Array of variable reference expressions</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AssignExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates an assignment expression
            </summary>
      <param name="target">The target of the assignment</param>
      <param name="expr">The expression to assign</param>
      <returns>Assignment expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AssignStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates an assignment statement
            </summary>
      <param name="target">The target of the assignment</param>
      <param name="expr">The expression to assign</param>
      <returns>Assignment statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDecl(System.String,System.Type)">
      <summary>
            Creates a variable declaration
            </summary>
      <param name="name">Name of variable</param>
      <param name="tp">Type of variable</param>
      <returns>Variable declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a variable declaration
            </summary>
      <param name="name">Name of variable</param>
      <param name="tp">Type of variable</param>
      <returns>Variable declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDeclExpr(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a variable declaration expression
            </summary>
      <param name="name">Name of variable</param>
      <param name="tp">Type of variable</param>
      <returns>Variable declaration expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDeclExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Creates a variable declaration expression
            </summary>
      <param name="ivd">Variable declaration</param>
      <returns>Variable declaration expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CommentStmt(System.String)">
      <summary>
            Creates a comment statement
            </summary>
      <param name="text">Text for the comment statement</param>
      <returns>Comment statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MakeValid(System.String)">
      <summary>
            Replace characters to make a valid identifier.
            </summary>
      <param name="name">Identifier</param>
      <returns>An alphanumeric string, starting with a letter.</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Param(System.String,System.Type)">
      <summary>
            Creates a parameter declaration
            </summary>
      <param name="name">Name of parameter</param>
      <param name="type">Type of parameter</param>
      <returns>Parameter declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Param(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a parameter declaration
            </summary>
      <param name="name">Name of parameter</param>
      <param name="type">Type of parameter</param>
      <returns>Parameter declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ParamRef(MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterReference)">
      <summary>
            Creates a parameter reference expression
            </summary>
      <param name="pr">Parameter reference</param>
      <returns>arameter reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Capitalise(System.String)">
      <summary>
            Capitalise a string
            </summary>
      <param name="s">String to capitalise</param>
      <returns>Capitalised string</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ReplaceVariable(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Replaces references to 'ivdFind' with 'ivdReplace' in the supplied expression.
            </summary>
      <param name="expr">The expression</param>
      <param name="ivdFind">Variable declaration to find</param>
      <param name="ivdReplace">Replacement variable declaration</param>
      <returns>The resulting expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ReplaceVariable(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Int32@)">
      <summary>
            Replaces references to 'ivdFind' with specified expression in the supplied expression.
            </summary>
      <param name="expr">The expression</param>
      <param name="ivdFind">Variable declaration to find</param>
      <param name="exprReplace">Replacement expression</param>
      <param name="replaceCount">Replacement count - passed by reference</param>
      <returns>The resulting expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ContainsExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the first expression contains the second one.
            </summary>
      <param name="expr">The expression to search</param>
      <param name="exprFind">The expression to look for</param>
      <returns>True if the expression was found</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ReplaceExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Finds and replaces one expression with another expression in a given expression
            </summary>
      <param name="expr">The expression</param>
      <param name="exprFind">The expression to be found</param>
      <param name="exprReplace">Replacement expression</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ReplaceExpression(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Int32@)">
      <summary>
            Finds and replaces one expression with another expression in a given expression
            </summary>
      <param name="expr">The expression</param>
      <param name="exprFind">The expression to be found</param>
      <param name="exprReplace">Replacement expression</param>
      <param name="replaceCount">Replacement count - passed by reference</param>
      <returns>The resulting expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NestedForStmt(System.String,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration}@,MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement@)">
      <summary>
            Creates a nested for loop statement
            </summary>
      <param name="indexBaseName">Base name for the index variables</param>
      <param name="sizes">Size expressions for each dimension</param>
      <param name="indexVars">List of variable declarations for index variables (output)</param>
      <param name="innerForStatement">Inner for loop statement (output)</param>
      <returns>Nested for loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NestedForStmt(System.String[],System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration}@,MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement@)">
      <summary>
            Creates a nested for loop statement
            </summary>
      <param name="indexNames">Names for the index variables</param>
      <param name="sizes">Size expressions for each dimension</param>
      <param name="indexVars">List of variable declarations for index variables (output)</param>
      <param name="innerForStatement">Inner for loop statement (output)</param>
      <returns>Nested for loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NestedForStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration[],MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[],MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement@)">
      <summary>
            Creates a nested for loop statement
            </summary>
      <param name="indexVars">Index variable declarations</param>
      <param name="sizes">Size expressions for each dimension</param>
      <param name="innerForStatement">Inner for loop statement (output)</param>
      <returns>Nested for loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NestedForStmt(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement},MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement@)">
      <summary>
            Creates a nested for loop statement
            </summary>
      <param name="loops">List of for loop statements</param>
      <param name="innerForStatement">Inner for loop statement (output)</param>
      <returns>Nested for loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForStmt(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration@)">
      <summary>
            Creates a for loop statement
            </summary>
      <param name="indexName">Index variable name</param>
      <param name="size">Loop size</param>
      <param name="indexVar">Index variable (output)</param>
      <returns>For loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForStmt(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration@)">
      <summary>
            Creates a for loop statement
            </summary>
      <param name="indexName">Index variable name</param>
      <param name="start">Start index</param>
      <param name="size">Loop size</param>
      <param name="indexVar">Index variable (output)</param>
      <returns>For loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a for loop statement
            </summary>
      <param name="vd">Index variable declaration</param>
      <param name="size">Loop size</param>
      <returns>For loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a for loop statement
            </summary>
      <param name="vd">Index variable declaration</param>
      <param name="size">Loop size</param>
      <param name="start">Start index</param>
      <returns>For loop statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.RepeatStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Creates a repeat statement
            </summary>
      <param name="count">Count i.e. number of repeats</param>
      <returns>Repeat statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CondStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            Creates a condition statement.
            </summary>
      <param name="condition">
      </param>
      <param name="thenBlock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CondStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            Creates a condition statement.
            </summary>
      <param name="condition">
      </param>
      <param name="thenBlock">
      </param>
      <param name="elseBlock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference)">
      <summary>
            Creates a property reference expression
            </summary>
      <param name="target">Instance expression</param>
      <param name="pr">Declaration of the property</param>
      <returns>Property reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,System.String,System.Type)">
      <summary>
            Creates a property reference expression
            </summary>
      <param name="expr">Instance expression</param>
      <param name="declaringType">Declaring type</param>
      <param name="propName">Property name</param>
      <param name="propType">Property type</param>
      <returns>Property reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,System.String)">
      <summary>
            Creates a property reference expression
            </summary>
      <param name="expr">Instance expression</param>
      <param name="declaringType">Declaring type</param>
      <param name="propName">Property name</param>
      <returns>Property reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates a property declaration with no get or set methods
            </summary>
      <param name="name">Name of the property</param>
      <param name="propertyType">Type of the property</param>
      <param name="declaringType">Type containing the property</param>
      <returns>A property declaration with no get or set methods</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility)">
      <summary>
            Creates a property declaration with an empty get method and no set method
            </summary>
      <param name="name">Name of the property</param>
      <param name="propertyType">Type of the property</param>
      <param name="declaringType">Type containing the property</param>
      <param name="getMethodVisibility">Visibility of the get method</param>
      <returns>The property declaration with an empty get method and no set method</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility)">
      <summary>
            Creates a property declaration with an empty get method and no set method
            </summary>
      <param name="name">Name of the property</param>
      <param name="propertyType">Type of the property</param>
      <param name="declaringType">Type containing the property</param>
      <param name="getMethodVisibility">Visibility of the get method</param>
      <returns>The property declaration with an empty get method and no set method</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@)">
      <summary>
            Creates a property declaration with an empty get method and set method
            </summary>
      <param name="name">Name of the property</param>
      <param name="propertyType">Type of the property</param>
      <param name="declaringType">Type containing the property</param>
      <param name="getMethodVisibility">Visibility of the get method</param>
      <param name="setMethodVisibility">Visibility of the set method</param>
      <param name="value">The value passed to the set method</param>
      <returns>The property declaration with an empty get method and set method</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@)">
      <summary>
            Creates a property declaration with an empty get method and set method
            </summary>
      <param name="name">Name of the property</param>
      <param name="propertyType">Type of the property</param>
      <param name="declaringType">Type containing the property</param>
      <param name="getMethodVisibility">Visibility of the get method</param>
      <param name="setMethodVisibility">Visibility of the set method</param>
      <param name="value">The value passed to the set method</param>
      <returns>The property declaration with an empty get method and set method</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventDecl(System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Creates an event declaration
            </summary>
      <param name="name">Name of the property</param>
      <param name="eventType">Type of the event</param>
      <param name="declaringType">Declaring type</param>
      <returns>An event declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventDecl(System.String,System.Type,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Creates an event declaration
            </summary>
      <param name="name">Name of the property</param>
      <param name="declaringType">Type containing the event</param>
      <param name="invokeMethod">Method for clients to invoke the event</param>
      <returns>An event declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FireEventDecl(MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility,System.String,MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            Create a method declaration for a method which allows clients to fire the event
            This is required because events can only be fired from the defining class 
            </summary>
      <param name="vis">Method visibility</param>
      <param name="name">Method name</param>
      <param name="eventDecl">The event declaration</param>
      <returns>The method declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            Creates an event reference expression
            </summary>
      <param name="ed">Event declaration</param>
      <returns>Event reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventRefExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            Creates an event reference expression
            </summary>
      <param name="ed">Event declaration</param>
      <param name="target">Target</param>
      <returns>Event reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ThrowStmt(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Throw statement
            </summary>
      <param name="expr">The expression to throw</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.DefaultExpr(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            default(T) expression
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.DefaultExpr(System.Type)">
      <summary>
            default(T) expression
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MakeArrayType(System.Type,System.Int32)">
      <summary>
            Creates an array type
            </summary>
      <param name="tp">Element type</param>
      <param name="rank">Rank of array</param>
      <returns>Array type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MakeJaggedArrayType(System.Type,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[]})">
      <summary>
            Creates a jagged array type
            </summary>
      <param name="elementType">Element type</param>
      <param name="sizes">Expressions for sizes of the sub-arrays</param>
      <returns>Jagged array type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NewJaggedArray(System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement},MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration[]},System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression[]})">
      <summary>
            Creates a new jagged array, consisting of a declaration and a nested loop allocating the sub-arrays.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.JaggedArrayIndex(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}})">
      <summary>
            Creates an expression for a jagged array index
            </summary>
      <param name="expr">Unindexed expression</param>
      <param name="indices">Loop variable declarations</param>
      <returns>Indexed expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldDecl">
      <summary>
            Default constructor for field declaration
            </summary>
      <returns>A new field declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldRef">
      <summary>
            Default constructor for field reference
            </summary>
      <returns>A new field reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.FieldRefExpr">
      <summary>
            Default constructor for field reference expression
            </summary>
      <returns>A new field reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CastExpr">
      <summary>
            Default constructor for cast expression
            </summary>
      <returns>A new cast expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ExprStatement">
      <summary>
            Default constructor for expression statement
            </summary>
      <returns>A new expression statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.RefType">
      <summary>
            Default constructor for a reference type
            </summary>
      <returns>A new reference type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRef">
      <summary>
            Default constructor for a type reference
            </summary>
      <returns>A new type reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeInstRef">
      <summary>
            Default constructor for type instance reference
            </summary>
      <returns>A new type instance reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeRefExpr">
      <summary>
            Default constructor for an assembly reference
            </summary>
      <returns>A new type reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeDecl">
      <summary>
            Default constructor for type declaration
            </summary>
      <returns>A new type declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.IsTypeInstRef(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference)">
      <summary>
            Check if ITypeReference is TypeInstanceReference
            </summary>
      <returns>true if it is a TypeInstanceReference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AssemblyRef">
      <summary>
            Default constructor for an assembly reference
            </summary>
      <returns>A new assembly reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AddrOutExpr">
      <summary>
            Default constructor for address out expression
            </summary>
      <returns>A new address out expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AddrRefExpr">
      <summary>
            Default constructor for address ref expression
            </summary>
      <returns>A new address ref expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AddrDerefExpr">
      <summary>
            Default constructor for an address dereference expression
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodRef">
      <summary>
            Default constructor for method reference
            </summary>
      <returns>A new method reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodInstRef">
      <summary>
            Default constructor for method instance reference
            </summary>
      <returns>A new method reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodInstRef(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType[])">
      <summary>
            Constructor for method instance reference
            </summary>
      <returns>A new method reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.IsMethodInstRef(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Check if IMethodReference is MethodInstanceReference
            </summary>
      <returns>true if MathodInstanceReference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodReturnType(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Default constructor for method return type
            </summary>
      <returns>A new method return type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodDecl">
      <summary>
            Default constructor for method declaration
            </summary>
      <returns>A new method declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodRtrnStmt">
      <summary>
            Default constructor for method return statement
            </summary>
      <returns>A new method return statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodInvkExpr">
      <summary>
            Default constructor for method invoke expression
            </summary>
      <returns>A new method invoke expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.MethodRefExpr">
      <summary>
            Default constructor for method reference expression
            </summary>
      <returns>A new method reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BlockStmt">
      <summary>
            Default constructor for block statement
            </summary>
      <returns>A new block statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BlockExpr">
      <summary>
            Default constructor for block expression
            </summary>
      <returns>A new block expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.LiteralExpr">
      <summary>
            Default constructor for literal expression
            </summary>
      <returns>A new literal expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BinaryExpr">
      <summary>
            Default constructor for binary expression
            </summary>
      <returns>A new binary expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.TypeOfExpr">
      <summary>
            Default constructor for typeof expression
            </summary>
      <returns>A new typeof expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ObjCreateExpr">
      <summary>
            Default constructor for object create expression
            </summary>
      <returns>A new object create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarRefExpr">
      <summary>
            Default constructor for variable reference expression
            </summary>
      <returns>A new variable reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarRefExprArray(System.Int32)">
      <summary>
            Constructor for variable reference expression array
            </summary>
      <param name="count">Number of variable reference expressions in the array</param>
      <returns>A new variable reference expression array </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDecl">
      <summary>
            Default constructor for variable declaration
            </summary>
      <returns>A new variable declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarDeclExpr">
      <summary>
            Default constructor for variable declaration expression
            </summary>
      <returns>A new variable declaration expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.VarRef(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Constructor for variable reference
            </summary>
      <param name="ivd">Variable declaration interface instance</param>
      <returns>new variable reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AssignExpr">
      <summary>
            Default constructor for assign expression
            </summary>
      <returns>A new assign expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CommentStmt">
      <summary>
            Default constructor for comment statement
            </summary>
      <returns>A new comment statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.Comment">
      <summary>
            Default constructor for comment
            </summary>
      <returns>A new comment</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ParamRef">
      <summary>
            Default constructor for argument reference expression
            </summary>
      <returns>A new argument reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ParamDecl">
      <summary>
            Default constructor for parameter declaration
            </summary>
      <returns>A new parameter declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropDecl">
      <summary>
            Default constructor for property declaration
            </summary>
      <returns>A new property declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropRef">
      <summary>
            Default constructor for property reference
            </summary>
      <returns>A new property reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropRefExpr">
      <summary>
            Default constructor for property reference expression
            </summary>
      <returns>A new property reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.PropIndxrExpr">
      <summary>
            Default constructor for property indexer expression
            </summary>
      <returns>A new property indexer expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventDecl">
      <summary>
            Default constructor for event declaration
            </summary>
      <returns>A new event declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.EventRefExpr">
      <summary>
            Default constructor for event reference expression
            </summary>
      <returns>A new event reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.DelegateInvokeExpr">
      <summary>
            Default constructor for a delegate invoke expression
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForStmt">
      <summary>
            Default constructor for a for statement
            </summary>
      <returns>A new for statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.RepeatStmt">
      <summary>
            Default constructor for a repeat statement
            </summary>
      <returns>A new repeat statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ForEachStmt">
      <summary>
            Default constructor for foreach statement
            </summary>
      <returns>A new foreach statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.UnaryExpr">
      <summary>
            Default constructor for unary expression
            </summary>
      <returns>A new unary expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CondStmt">
      <summary>
            Default constructor for condition statement
            </summary>
      <returns>A new condition statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.SwitchStmt">
      <summary>
            Default constructor for switch statement
            </summary>
      <returns>A new switch statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BreakStmt">
      <summary>
            Default constructor for break statement
            </summary>
      <returns>A new break statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.WhileStmt">
      <summary>
            Default constructor for while statement
            </summary>
      <returns>A new while statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.UsingStmt">
      <summary>
            Default constructor for using statement
            </summary>
      <returns>A new statement</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ThisRefExpr">
      <summary>
            Default constructor for 'this' refrence expression
            </summary>
      <returns>A new this reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.StmtCollection">
      <summary>
            Default constructor for statement collection
            </summary>
      <returns>A new statement collection</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ExprCollection">
      <summary>
            Default constructor for expression collection
            </summary>
      <returns>A new expression collection</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.NameSpace">
      <summary>
            Default constructor for namespace
            </summary>
      <returns>A new namespace</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.BaseRefExpr">
      <summary>
            Default constructor for base reference expression
            </summary>
      <returns>A new base reference expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CondExpr">
      <summary>
            Default constructor for condition expression
            </summary>
      <returns>A new condition expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ConstructorDecl">
      <summary>
            Default constructor for constructor declaration
            </summary>
      <returns>A new constructor declaration</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.CondCase">
      <summary>
            Default constructor for condition case
            </summary>
      <returns>A new condition case</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.DefCase">
      <summary>
            Default constructor for default case
            </summary>
      <returns>A new default case</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayType">
      <summary>
            Default constructor for array type
            </summary>
      <returns>A new array type</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayCreateExpr">
      <summary>
            Default constructor for array create expression
            </summary>
      <returns>A new array create expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ArrayIndxrExpr">
      <summary>
            Default constructor for array indexer expression
            </summary>
      <returns>A new array indexer expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.AnonMethodExpr">
      <summary>
            Default constructor for anonymous method expression
            </summary>
      <returns>A new anonymous method expression</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.ThrowStmt">
      <summary>
            Throw exception statement
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.DefaultExpr">
      <summary>
            Default(T) expression
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeBuilder.GenericTypeParam(System.String)">
      <summary>
            Creates a generic type parameter
            </summary>
      <param name="name">Type parameter name</param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeBuilder.INSTANCE">
      <summary>
            Singleton instance
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeBuilder.DefaultTypeDeclaration">
      <summary>
            Default type declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression">
      <summary>
            All expressions derive from this
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression.GetExpressionType">
      <summary>
            Returns the static type of this expression.
            </summary>
      <returns>The type of the expression</returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XExpression">
      <summary>
            Base class for all expressions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XExpression.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XExpression.GetExpressionType">
      <summary>
            Get the expression type
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XExpression.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressDereferenceExpression">
      <summary>
            Address dereference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressDereferenceExpression.Expression">
      <summary>
            Expression to dereference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XAddressDereferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressOutExpression">
      <summary>
            Address out expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressOutExpression.Expression">
      <summary>
            The source expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XAddressOutExpression">
      <summary>
            Represents an 'out' argument expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XAddressOutExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAddressOutExpression.Expression">
      <summary>
            Expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressReferenceExpression">
      <summary>
            Address reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressReferenceExpression.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XAddressReferenceExpression">
      <summary>
            Represents a 'ref' argument expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XAddressReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAddressReferenceExpression.Expression">
      <summary>
            Expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAnonymousMethodExpression">
      <summary>
            Anonymous method expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAnonymousMethodExpression.Body">
      <summary>
            Body of statements
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAnonymousMethodExpression.DelegateType">
      <summary>
            Delegate type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAnonymousMethodExpression.Parameters">
      <summary>
            Parameter declarations for delegate
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression">
      <summary>
            Anonymous method expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression.Body">
      <summary>
            Body of the anonymous expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression.DelegateType">
      <summary>
            Anonymous expression delegate type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression.Parameters">
      <summary>
            Method parameters
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAnonymousMethodExpression.ReturnType">
      <summary>
            Anonymous method return type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArgumentReferenceExpression">
      <summary>
            Argument reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArgumentReferenceExpression.Parameter">
      <summary>
            The argument
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XArgumentReferenceExpression">
      <summary>
            Represents an argument reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XArgumentReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArgumentReferenceExpression.Parameter">
      <summary>
            Parameter reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression">
      <summary>
            Array creation expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression.Dimensions">
      <summary>
            Dimensions of array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression.Initializer">
      <summary>
            Initializer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression.Type">
      <summary>
            Element type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XArrayCreateExpression">
      <summary>
            Represents an array creation expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XArrayCreateExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayCreateExpression.Dimensions">
      <summary>
            Dimension array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayCreateExpression.Initializer">
      <summary>
            Array initializer
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayCreateExpression.Type">
      <summary>
            Array element type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression">
      <summary>
            Array index expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression.Indices">
      <summary>
            Index expressions
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression.Target">
      <summary>
            Expression being indexed
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XArrayIndexerExpression">
      <summary>
            Represent an array of index expressions applied to an array expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XArrayIndexerExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.IDotNetType">
      <summary>
            Interface that exposes the dotNET type of the code model type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.IDotNetType.DotNetType">
      <summary>
            The dotNET type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IType">
      <summary>
            All types are derived from this
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType">
      <summary>
            Array type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType.Rank">
      <summary>
            Rank of the array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType.ElementType">
      <summary>
            Element type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XArrayType">
      <summary>
            Represents an array type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayType.Rank">
      <summary>
            The rank of the array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayType.ElementType">
      <summary>
            The element type of the array
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XArrayType.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssemblyReference">
      <summary>
            Assembly reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssemblyReference.Name">
      <summary>
            Name of the assembly
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XAssemblyReference">
      <summary>
            Represents a reference to an assembly
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAssemblyReference.Name">
      <summary>
            Assembly name
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression">
      <summary>
            Assignment expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression.Expression">
      <summary>
            Expression being assigned
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression.Target">
      <summary>
            Target of the assignment
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XAssignExpression">
      <summary>
            Assign expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XAssignExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAssignExpression.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XAssignExpression.Target">
      <summary>
            The target
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBaseReferenceExpression">
      <summary>
            Base reference expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XBaseReferenceExpression">
      <summary>
            Base reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XBaseReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBinaryExpression">
      <summary>
            Binary expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBinaryExpression.Left">
      <summary>
            Expression to the left of the operator
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBinaryExpression.Operator">
      <summary>
            The operator
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBinaryExpression.Right">
      <summary>
            Expression to the right of the operator
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XBinaryExpression">
      <summary>
            A bibary expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XBinaryExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XBinaryExpression.Left">
      <summary>
            The expression to the left of the operator
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XBinaryExpression.Operator">
      <summary>
            The operator
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XBinaryExpression.Right">
      <summary>
            The expression to the right of the operator
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockExpression">
      <summary>
            Block expression - i.e. an expression which is a collection of expressions
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockExpression.Expressions">
      <summary>
            The collection of expressions in the block
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XBlockExpression">
      <summary>
             A block of expressions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XBlockExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XBlockExpression.Expressions">
      <summary>
            The expressions in the block
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IBreakStatement">
      <summary>
            Break statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XBreakStatement">
      <summary>
            Break statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICanCastExpression">
      <summary>
            Interface for an 'is' expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICanCastExpression.TargetType">
      <summary>
            Target type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICanCastExpression.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICastExpression">
      <summary>
            Cast expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICastExpression.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICastExpression.TargetType">
      <summary>
            The target type for the cast
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XCastExpression">
      <summary>
            A cast expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XCastExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCastExpression.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCastExpression.TargetType">
      <summary>
            The type of the cast
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause">
      <summary>
            Catch clause
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause.Body">
      <summary>
            The body of the clause
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause.Condition">
      <summary>
            Condition expression for catch clause
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause.Variable">
      <summary>
            Variable declaration for catch clause
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCatchClause.Body">
      <summary>
            The body of the catch clause - a body of statements
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IComment">
      <summary>
            Comment
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IComment.Text">
      <summary>
            Text for comment
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XComment">
      <summary>
            A comment in the code
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XComment.Text">
      <summary>
            The text of the comment
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICommentStatement">
      <summary>
            Comment statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICommentStatement.Comment">
      <summary>
            Text for comment statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XCommentStatement">
      <summary>
             A comment statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCommentStatement.Comment">
      <summary>
            The comment
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.CompareItems">
      <summary>
            A static class with various methods for comparison and equality testing
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.CompareTypeReferences(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference)">
      <summary>
            Compare two type references
            </summary>
      <param name="itra">Type reference a</param>
      <param name="itrb">Type reference b</param>
      <returns>-1, 0, or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.MethodSignaturesAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature)">
      <summary>
            Determine if two method signatures are equal
            </summary>
      <param name="imsRef">Reference method signature</param>
      <param name="imsDecl">Method declaration signature</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.MethodReferencesAreEqualInner(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Determine if two method references are equal, ignoring declaring type
            </summary>
      <param name="imr1">Method reference 1</param>
      <param name="imr2">Method reference 2</param>
      <returns>true if equal</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.MethodReferencesAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Determine if two method references are equal
            </summary>
      <param name="imr1">First method reference</param>
      <param name="imr2">Second method reference</param>
      <returns>true if equal</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.CompareMethodReferences(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference)">
      <summary>
            Compare two method references
            </summary>
      <param name="imr1">First method reference</param>
      <param name="imr2">Second method reference</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.CompareArrayTypes(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType)">
      <summary>
            Compare two array types
            </summary>
      <param name="iat1">First array type</param>
      <param name="iat2">Second array type</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.ArrayTypesAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType)">
      <summary>
            Determine if two array types are equal
            </summary>
      <param name="iat1">Reference method signature</param>
      <param name="iat2">Method declaration signature</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.TypesAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Determine if two ITypes are equal
            </summary>
      <param name="it1">First IType</param>
      <param name="it2">Second IType</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.ComparePropertyReferences(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference)">
      <summary>
            Compare two property references
            </summary>
      <param name="ipr1">First property reference</param>
      <param name="ipr2">Second property reference</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.CompareItems.PropertyReferencesAreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference)">
      <summary>
            Determine if two property references are equal
            </summary>
      <param name="ipr1">Property reference 1</param>
      <param name="ipr2">Property reference 2</param>
      <returns>true if equal</returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchCase">
      <summary>
            Switch case
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchCase.Body">
      <summary>
            Body of switch case
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionCase">
      <summary>
            Condition case
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionCase.Condition">
      <summary>
            Condition expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XConditionCase">
      <summary>
            A condition block
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionCase.Condition">
      <summary>
            An expression giving the condition
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionCase.Body">
      <summary>
            The body of statements
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionExpression">
      <summary>
            Condition expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionExpression.Condition">
      <summary>
            If condition
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionExpression.Else">
      <summary>
            Else expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionExpression.Then">
      <summary>
            Then expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XConditionExpression">
      <summary>
            A condition expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XConditionExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionExpression.Condition">
      <summary>
            The condition
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionExpression.Else">
      <summary>
            Else expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionExpression.Then">
      <summary>
            Then expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement">
      <summary>
            Condition statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement.Condition">
      <summary>
            If condition
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement.Else">
      <summary>
            Else block of statements
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement.Then">
      <summary>
            Then block of statements
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XConditionStatement">
      <summary>
            A condition statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionStatement.Condition">
      <summary>
            Condition expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionStatement.Else">
      <summary>
            The block of 'else' statements
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConditionStatement.Then">
      <summary>
            The block of 'then' statements
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberReference">
      <summary>
            Member reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberReference.DeclaringType">
      <summary>
            Declaring type for the member
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberReference.Name">
      <summary>
            Name of the member
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature">
      <summary>
            Method signature
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature.Parameters">
      <summary>
            Parameter declarations
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature.ReturnType">
      <summary>
            Return type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodSignature.MethodInfo">
      <summary>
            dotNet method info
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgumentProvider">
      <summary>
            Generic Argument Provider
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgumentProvider.GenericArguments">
      <summary>
            The provided type collection
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference">
      <summary>
            Method reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference.Resolve">
      <summary>
            Resolve to a method declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference.GenericMethod">
      <summary>
            Generic method reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttributeProvider">
      <summary>
            Custom attribute provider
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttributeProvider.Attributes">
      <summary>
            Attributes
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDocumentationProvider">
      <summary>
            Documentation provider
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDocumentationProvider.Documentation">
      <summary>
            The documentation text
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberDeclaration">
      <summary>
            A member declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration">
      <summary>
            Method declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Abstract">
      <summary>
            Abstract flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Body">
      <summary>
            Method body
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Final">
      <summary>
            Final flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Overrides">
      <summary>
            Collection of overrides
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Static">
      <summary>
            Static flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Virtual">
      <summary>
            Virtual flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration.Visibility">
      <summary>
            Visibility
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration">
      <summary>
            This class models a method declaration. It is not the specialization of a generic type
            but may be a generic method definition
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Resolve">
      <summary>
            Always returns this
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Equals(System.Object)">
      <summary>
            Determines if this method reference is equal to another (representing the method declaration)
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.GetHashCode">
      <summary>
            GetHashCode override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Abstract">
      <summary>
            Wther the method is abstract
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Body">
      <summary>
            The body of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Final">
      <summary>
            Whether the method is final - i.e. it is an override which cannot be overridden itself
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Overrides">
      <summary>
            Overrides for this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Static">
      <summary>
            Whether this is a static method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Virtual">
      <summary>
            Whether this method can be overridden
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Visibility">
      <summary>
            Visibility of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.GenericMethod">
      <summary>
            Always returns null and cannot be set
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.DeclaringType">
      <summary>
            The declaring type for this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Name">
      <summary>
            The name of this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.MethodInfo">
      <summary>
            Method Info
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Parameters">
      <summary>
            Parameters declarations
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.ReturnType">
      <summary>
            Return type of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.GenericArguments">
      <summary>
            Generic types, if this is derived from a generic method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Attributes">
      <summary>
            The custom attributes attached to this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodDeclaration.Documentation">
      <summary>
            The documentation for this method
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConstructorDeclaration">
      <summary>
            Constructor declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IConstructorDeclaration.Initializer">
      <summary>
            Initializer
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XConstructorDeclaration">
      <summary>
            A constructor declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XConstructorDeclaration.Initializer">
      <summary>
            The method call
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IContinueStatement">
      <summary>
            Interface for 'continue' statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement">
      <summary>
            For statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement.Body">
      <summary>
            The body of the if statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement.Count">
      <summary>
            The count of the repeat statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XRepeatStatement">
      <summary>
            Repeat block
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XRepeatStatement.Body">
      <summary>
            The body of the repeat block
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XRepeatStatement.Count">
      <summary>
            The count expression for the repeat block
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttribute">
      <summary>
            Custom attribute
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttribute.Arguments">
      <summary>
            Attribute arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttribute.Constructor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XCustomAttribute">
      <summary>
            A custom attribute
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCustomAttribute.Arguments">
      <summary>
            The attribute's arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XCustomAttribute.Constructor">
      <summary>
            Attribute constructor
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDefaultCase">
      <summary>
            Default case
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XDefaultCase">
      <summary>
            The default case in a switch case
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XDefaultCase.Body">
      <summary>
            The block of statements for the default case
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDefaultExpression">
      <summary>
            Interface for default(T) expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDefaultExpression.Type">
      <summary>
            The type 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XDefaultExpression.Type">
      <summary>
            The type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateCreateExpression">
      <summary>
            Delegate create expressions
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateCreateExpression.DelegateType">
      <summary>
            Delegate type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateCreateExpression.Method">
      <summary>
            Delegate method reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateCreateExpression.Target">
      <summary>
            Expression for creating delegate
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XDelegateCreateExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateInvokeExpression">
      <summary>
            Interface for delegate invoke expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateInvokeExpression.Arguments">
      <summary>
            Arguments for delegate invoke expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateInvokeExpression.Target">
      <summary>
            Target for delegate invoke expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XDelegateInvokeExpression">
      <summary>
            Method invoke expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XDelegateInvokeExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XDelegateInvokeExpression.Arguments">
      <summary>
            Arguments of the method
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReference">
      <summary>
            Event reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReference.Resolve">
      <summary>
            Resolve the reference to an event declaration
            </summary>
      <returns>Event declaration</returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReference.EventType">
      <summary>
            Delegate type for the event
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReference.GenericEvent">
      <summary>
            Generic event reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration">
      <summary>
            Property declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration.InvokeMethod">
      <summary>
            Reference to method which allows client code to trigger the event
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration">
      <summary>
            Event declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.Resolve">
      <summary>
            Resolve - just returns this as it is already a declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.CompareTo(System.Object)">
      <summary>
            Compares this instance with another object
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.ToString">
      <summary>
            String representation
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.Equals(System.Object)">
      <summary>
            Determines whether this instance is equal to another instance
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.GetHashCode">
      <summary>
            Hash code for the instance
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.InvokeMethod">
      <summary>
            Reference for event invoke method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.EventType">
      <summary>
            Type of the event
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.GenericEvent">
      <summary>
            The generic event from which this event is derived (if any)
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.DeclaringType">
      <summary>
            Declaring type of this event
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.Name">
      <summary>
            The name of this event
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.Attributes">
      <summary>
            The custome attributes attached to this event
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventDeclaration.Documentation">
      <summary>
            The documentation for this event
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XEventReference">
      <summary>
            Event reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReference.Resolve">
      <summary>
            Resolve the event reference
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReference.CompareTo(System.Object)">
      <summary>
            Compare this event reference to another object
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReference.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReference.Equals(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReference.GetHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReference.EventType">
      <summary>
            Event type reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReference.GenericEvent">
      <summary>
            Gets/sets the generic event reference. This will be specialised by
            the containing specialised class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReference.DeclaringType">
      <summary>
            Declaring type for this property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReference.Name">
      <summary>
            Name of this property
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReferenceExpression">
      <summary>
            Event reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReferenceExpression.Event">
      <summary>
            The event reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReferenceExpression.Target">
      <summary>
            The instance
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XEventReferenceExpression">
      <summary>
            A event reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XEventReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReferenceExpression.Event">
      <summary>
            The event reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XEventReferenceExpression.Target">
      <summary>
            The target expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReference">
      <summary>
            Field reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReference.Resolve">
      <summary>
            Resolve to a field declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReference.FieldType">
      <summary>
            Field type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReference.GenericField">
      <summary>
            Generic field reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration">
      <summary>
            Field declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration.Initializer">
      <summary>
            Initializer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration.Literal">
      <summary>
            Literal flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration.ReadOnly">
      <summary>
            Read only flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration.Static">
      <summary>
            Static flag
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration.Visibility">
      <summary>
            Field visibility
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration">
      <summary>
            Field declaraion
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Resolve">
      <summary>
            Resolve - just returns this as it is already a declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Initializer">
      <summary>
            Initializer for the field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Literal">
      <summary>
            Whether the field is a literal
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.ReadOnly">
      <summary>
            Whether the field is read only
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Static">
      <summary>
            Whether this is a static field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Visibility">
      <summary>
            Visibility of the field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.FieldType">
      <summary>
            Type of the field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.GenericField">
      <summary>
            The generic field from which this field is derived (if any)
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.DeclaringType">
      <summary>
            Declaring type of this field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Name">
      <summary>
            The name of this field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Attributes">
      <summary>
            The custome attributes attached to this field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldDeclaration.Documentation">
      <summary>
            The documentation for this field
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XFieldReference">
      <summary>
            A field reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XFieldReference.Resolve">
      <summary>
            Resolve to a field declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldReference.FieldType">
      <summary>
            The type of the field
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldReference.GenericField">
      <summary>
            A reference to the generic field for which this field is a specialization (if any)
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReferenceExpression">
      <summary>
            Field reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReferenceExpression.Field">
      <summary>
            The field reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReferenceExpression.Target">
      <summary>
            The expression for the type instance
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XFieldReferenceExpression">
      <summary>
            A field reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XFieldReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldReferenceExpression.Field">
      <summary>
            The field reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XFieldReferenceExpression.Target">
      <summary>
            The target expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement">
      <summary>
            For each statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement.Body">
      <summary>
            The statements in the body of the for each statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement.Expression">
      <summary>
            Expression in the foreach statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement.Variable">
      <summary>
            Variable declaration in the for each statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XForEachStatement">
      <summary>
            A Foreach statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForEachStatement.Body">
      <summary>
            The Foreach statement code body
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForEachStatement.Expression">
      <summary>
            The expression 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForEachStatement.Variable">
      <summary>
            The variable declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement">
      <summary>
            For statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement.Body">
      <summary>
            The body of the if statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement.Condition">
      <summary>
            The condition of the for statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement.Increment">
      <summary>
            The incrementer of the for statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement.Initializer">
      <summary>
            The initializer of the for statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XForStatement">
      <summary>
            For loop
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForStatement.Body">
      <summary>
            The body of the for loop
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForStatement.Condition">
      <summary>
            The condition expression for the for loop
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForStatement.Increment">
      <summary>
            The increment statement for the for loop
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XForStatement.Initializer">
      <summary>
            The initializer statement for the for loop
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgument">
      <summary>
            Generic argument
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgument.Resolve">
      <summary>
            Resolve the generic argument to a type
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgument.Owner">
      <summary>
            The provider of types for the generic argument
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgument.Position">
      <summary>
            The position of the generic argument
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XGenericArgument">
      <summary>
            This class represents a generic type argument for a generic type or
            a generic method
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XGenericArgument.Resolve">
      <summary>
            Resolve the argument - return the type of the argument
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XGenericArgument.Equals(System.Object)">
      <summary>
            Test whether one generic argument equals another
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericArgument.Owner">
      <summary>
            The type reference or method reference which specifies this argument
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericArgument.Position">
      <summary>
            The position of this argument
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericArgument.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericParameter">
      <summary>
            A generic parameter
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericParameter.Constraints">
      <summary>
            A set of type constraints for the generic parameter
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericParameter.Name">
      <summary>
            The name of the generic parameter
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XGenericParameter.Equals(System.Object)">
      <summary>
            Test whether one generic argument equals another
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericParameter.Owner">
      <summary>
            The type reference or method reference which specifies this argument
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericParameter.Position">
      <summary>
            The position of this argument
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XGenericParameter.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Generics">
      <summary>
            A static class providing a GetType method to convert generic types to specific types
            based on the specified generic argument providers
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Generics.GetType(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType,MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgumentProvider,MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgumentProvider)">
      <summary>
            Use the generic argument providers to specialize a type
            </summary>
      <param name="type">The type to resolve</param>
      <param name="declaringType">The declaring type as a generic argument provider</param>
      <param name="method">The method as a generic argument provider</param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssembly">
      <summary>
            Dummy interface - doesn't implement any Reflector capability
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator">
      <summary>
            Binary operators
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.Add">
      <summary>
            Add operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.Subtract">
      <summary>
            Subtraction operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.Multiply">
      <summary>
            Multiplication operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.Divide">
      <summary>
            Division operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.Modulus">
      <summary>
            Modulus operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.ShiftLeft">
      <summary>
            Shift left operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.ShiftRight">
      <summary>
            Shift right operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.IdentityEquality">
      <summary>
            Identity equality operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.IdentityInequality">
      <summary>
            Identity inequality operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.ValueEquality">
      <summary>
            Equality operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.ValueInequality">
      <summary>
            Inequality operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.BitwiseOr">
      <summary>
            Bitwise OR operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.BitwiseAnd">
      <summary>
            Bitwise AND operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.BitwiseExclusiveOr">
      <summary>
            Bitwise Exclusive OR operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.BooleanOr">
      <summary>
            Boolean OR operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.BooleanAnd">
      <summary>
            Boolean AND operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.LessThan">
      <summary>
            Less than operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.LessThanOrEqual">
      <summary>
            Less than or equal operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.GreaterThan">
      <summary>
            Greater than operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.BinaryOperator.GreaterThanOrEqual">
      <summary>
            Greater than or equal operator
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility">
      <summary>
            Field visibility
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.PrivateScope">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.Private">
      <summary>
            Private scope
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.FamilyAndAssembly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.Assembly">
      <summary>
            Assembly scope
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.Family">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.FamilyOrAssembly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.FieldVisibility.Public">
      <summary>
            Public scope
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ILambdaExpression">
      <summary>
            Interface for a lambda expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ILambdaExpression.Body">
      <summary>
            The body of the expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ILambdaExpression.Parameters">
      <summary>
            The list of parameters
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ILiteralExpression">
      <summary>
            A literal expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ILiteralExpression.Value">
      <summary>
            The value of the literal expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberInitializerExpression">
      <summary>
            A member initializer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberInitializerExpression.Member">
      <summary>
            The member reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberInitializerExpression.Value">
      <summary>
            The initializer expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility">
      <summary>
            Method visibility
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.PrivateScope">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.Private">
      <summary>
            Private
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.FamilyAndAssembly">
      <summary>
            Private visibility
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.Assembly">
      <summary>
            Visible within the assembly
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.Family">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.FamilyOrAssembly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.MethodVisibility.Public">
      <summary>
            Public visibility
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression">
      <summary>
            Method invoke expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression.Arguments">
      <summary>
            The arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression.Method">
      <summary>
            The method
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReferenceExpression">
      <summary>
            Method reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReferenceExpression.Method">
      <summary>
            Method reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReferenceExpression.Target">
      <summary>
            Instance expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnStatement">
      <summary>
            Method return statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnStatement.Expression">
      <summary>
            Expression to return
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnType">
      <summary>
            Method return type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnType.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IModule">
      <summary>
            Dummy interface - doesn't implement any Reflector capability
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.INamespace">
      <summary>
            Namespace
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.INamespace.Name">
      <summary>
            Name of the namespace
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.INamespace.Types">
      <summary>
            Type declarations
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression">
      <summary>
            Object creation expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression.Arguments">
      <summary>
            Arguments to the constructor
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression.Constructor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression.Initializer">
      <summary>
            Initializer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression.Type">
      <summary>
            Type of object
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IOptionalModifier">
      <summary>
            Optional modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IOptionalModifier.ElementType">
      <summary>
            Element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IOptionalModifier.Modifier">
      <summary>
            Modifier type reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterReference">
      <summary>
            Parameter reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterReference.Resolve">
      <summary>
            Resolve the reference
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterReference.Name">
      <summary>
            Parameter name
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration">
      <summary>
            Parameter declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration.ParameterType">
      <summary>
            Parameter type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPointerType">
      <summary>
            Pointer type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPointerType.ElementType">
      <summary>
            Element type for pointer type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference">
      <summary>
            Property reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference.Resolve">
      <summary>
            Resolve the reference to a property declaration
            </summary>
      <returns>Property declaration</returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference.GenericProperty">
      <summary>
            Generic property reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference.Parameters">
      <summary>
            Parameter declarations
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReference.PropertyType">
      <summary>
            Property type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration">
      <summary>
            Property declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration.GetMethod">
      <summary>
            Get method reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration.Initializer">
      <summary>
            Initializer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration.SetMethod">
      <summary>
            Set method reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyIndexerExpression">
      <summary>
            Property indexer expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyIndexerExpression.Indices">
      <summary>
            Index expression collection
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyIndexerExpression.Target">
      <summary>
            Property reference expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReferenceExpression">
      <summary>
            Property reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReferenceExpression.Property">
      <summary>
            The property reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReferenceExpression.Target">
      <summary>
            The instance
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IReferenceType">
      <summary>
            Reference type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IReferenceType.ElementType">
      <summary>
            The type referenced
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRequiredModifier">
      <summary>
            Required modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRequiredModifier.ElementType">
      <summary>
            Element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IRequiredModifier.Modifier">
      <summary>
            Modifier type reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISettableTypeDeclaration">
      <summary>
            Whether the type declaration is settable - for example in a type reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISettableTypeDeclaration.Declaration">
      <summary>
            The type declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement">
      <summary>
            Switch statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement.Cases">
      <summary>
            The cases in the switch statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IThisReferenceExpression">
      <summary>
            'This' reference expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IThrowExceptionStatement">
      <summary>
            Interface for throw exception statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IThrowExceptionStatement.Expression">
      <summary>
            The expression thrown
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement">
      <summary>
            Try/catch/finally statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement.CatchClauses">
      <summary>
            The catch clauses
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement.Fault">
      <summary>
            The unconditional catch clause body
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement.Finally">
      <summary>
            The finally body
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement.Try">
      <summary>
            The try body
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility">
      <summary>
            Type visibility
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.Private">
      <summary>
            Private
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.Public">
      <summary>
            Public
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedPublic">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedPrivate">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedFamily">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedAssembly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedFamilyAndAssembly">
      <summary>
      </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.TypeVisibility.NestedFamilyOrAssembly">
      <summary>
      </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference">
      <summary>
            Type reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.Resolve">
      <summary>
            Resolve to a type declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.GenericType">
      <summary>
            The generic type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.Name">
      <summary>
            Name of the reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.Namespace">
      <summary>
            Namespace of the reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.Owner">
      <summary>
            Owner of the reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference.ValueType">
      <summary>
            Whether this is a value type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration">
      <summary>
            Type declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Abstract">
      <summary>
            Whether the type is abstract - i.e. cannot be instantiated
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.BaseType">
      <summary>
            Reference to base type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Fields">
      <summary>
            Collection of fields
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Interface">
      <summary>
            Whether the type is an interface
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Interfaces">
      <summary>
            Interfaces this type is derived from
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Methods">
      <summary>
            Collection of methods
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.NestedTypes">
      <summary>
            Collection of nested types
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Properties">
      <summary>
            Collection of properties
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Events">
      <summary>
            Collection of events
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Sealed">
      <summary>
            True if the type is sealed (cannot be derived from)
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Partial">
      <summary>
            True if the declaration is partial
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration.Visibility">
      <summary>
            Visibility of the type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeOfExpression">
      <summary>
            Typeof expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeOfExpression.Type">
      <summary>
            The type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReferenceExpression">
      <summary>
            Type reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReferenceExpression.Type">
      <summary>
            Type reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator">
      <summary>
            Unary operators
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.Negate">
      <summary>
            Negation operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.BooleanNot">
      <summary>
            Boolean NOT operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.BitwiseNot">
      <summary>
            Bitwise NOT operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.PreIncrement">
      <summary>
            Pre-increment operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.PreDecrement">
      <summary>
            Pre-decrement operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.PostIncrement">
      <summary>
            Post-increment operator
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeModel.Interfaces.UnaryOperator.PostDecrement">
      <summary>
            Post-decrement operator
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUnaryExpression">
      <summary>
            Unary expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUnaryExpression.Expression">
      <summary>
            The source expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUnaryExpression.Operator">
      <summary>
            The operator that acts on the source expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement">
      <summary>
            Using statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement.Body">
      <summary>
            The body of the statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement.Expression">
      <summary>
            The using expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReference">
      <summary>
            Variable reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReference.Resolve">
      <summary>
            Resolve
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReference.Variable">
      <summary>
            Variable declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration">
      <summary>
            Variable declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration.Identifier">
      <summary>
      </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration.Name">
      <summary>
            Variable name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration.VariableType">
      <summary>
            Variable type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression">
      <summary>
            Variable declaration expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression.Variable">
      <summary>
            Variable declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression">
      <summary>
            Variable reference expression
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression.Variable">
      <summary>
            Variable reference
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement">
      <summary>
            While statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement.Body">
      <summary>
            Body of while statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement.Condition">
      <summary>
            Condition for while statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XLiteralExpression">
      <summary>
            A Literal expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XLiteralExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XLiteralExpression.Value">
      <summary>
            The literal value
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMemberInitializerExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration">
      <summary>
            This class models a method declaration which is a specialization
            of a generic model declaration as given by the GenericMethod property
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Resolve">
      <summary>
            Just returns this - it is already a declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Abstract">
      <summary>
            Whether the method is abstract - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Body">
      <summary>
            The body of this specialization
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Final">
      <summary>
            Whether the method is final (i.e. can no longer be overridden) - this is the
            same as for the GenericMethod. For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Overrides">
      <summary>
            The overrides for this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Static">
      <summary>
            Whether the method is static - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Virtual">
      <summary>
            Whether the method is virtual - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Visibility">
      <summary>
            The visibility of the method - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.GenericMethod">
      <summary>
            The generic method for which this is a specialization.
            Setting this property will trigger a resolve of the method
            reference to its declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.DeclaringType">
      <summary>
            The type of the declaring class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Name">
      <summary>
            The method's name - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.MethodInfo">
      <summary>
            Method Info
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Parameters">
      <summary>
            Parameter declarations
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.GenericArguments">
      <summary>
            Any remaining generic arguments needed by this method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Attributes">
      <summary>
            The custom attributes for this method - these are the same as for the GenericMethod.
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceDeclaration.Documentation">
      <summary>
            The documentation for the method - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference">
      <summary>
            This class models a reference to a specialization of a generic method
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.CompareTo(System.Object)">
      <summary>
            Compare this to an IMethodReference
            </summary>
      <param name="obj">Method reference to comapre to</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.GenericMethod">
      <summary>
            Reference to the generic method if this method is a specialisation of a generic method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.DeclaringType">
      <summary>
            The declaring type for this method instance
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.Name">
      <summary>
            Method instance name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.MethodInfo">
      <summary>
            Method Info
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.Parameters">
      <summary>
            Parameter declarations 
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.ReturnType">
      <summary>
            Return type of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInstanceReference.GenericArguments">
      <summary>
            Generic argument collection
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodInvokeExpression">
      <summary>
            Method invoke expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodInvokeExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInvokeExpression.Arguments">
      <summary>
            Arguments of the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodInvokeExpression.Method">
      <summary>
            The method
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodReference">
      <summary>
            This class models a reference to a method
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReference.Resolve">
      <summary>
            Resolve the method reference
            </summary>
      <returns>The declaration for the reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReference.CompareTo(System.Object)">
      <summary>
            Compare one method reference to another
            </summary>
      <param name="obj">Method reference to compare to</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReference.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReference.Equals(System.Object)">
      <summary>
            Determines if this method reference is equal to another (representing the method declaration)
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReference.GetHashCode">
      <summary>
            GetHashCode override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.Attributes">
      <summary>
            Custom attributes for the method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.GenericMethod">
      <summary>
            Reference to the generic method if this method is a specialisation of a generic method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.DeclaringType">
      <summary>
            The declaring type for this member method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.Name">
      <summary>
            Method name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.MethodInfo">
      <summary>
            Method Info
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.Parameters">
      <summary>
            Parameter declarations
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.ReturnType">
      <summary>
            Method return type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReference.GenericArguments">
      <summary>
            Generic types, if this is derived from a generic method
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodReferenceExpression">
      <summary>
            Method reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XMethodReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReferenceExpression.Method">
      <summary>
            The method
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReferenceExpression.Target">
      <summary>
            The target
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodReturnStatement">
      <summary>
            Method return statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReturnStatement.Expression">
      <summary>
            The expression in the statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XMethodReturnType">
      <summary>
            Method return type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReturnType.Type">
      <summary>
            The type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XMethodReturnType.Attributes">
      <summary>
            The attributes of the return type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XNamespace">
      <summary>
            Namespace
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XNamespace.Name">
      <summary>
            The namespace name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XNamespace.Types">
      <summary>
            The type collection
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression">
      <summary>
            Object create expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression.Arguments">
      <summary>
            Expressions for the constructor arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression.Constructor">
      <summary>
            The constructor method reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression.Initializer">
      <summary>
            Initializer
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XObjectCreateExpression.Type">
      <summary>
            Type of object being constructed
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XOptionalModifier">
      <summary>
            An optional modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XOptionalModifier.ElementType">
      <summary>
            Element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XOptionalModifier.Modifier">
      <summary>
            Modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XOptionalModifier.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration">
      <summary>
            Parameter declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.Resolve">
      <summary>
            Always returns this
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.Equals(System.Object)">
      <summary>
            Test whether one parameter declaration equals another
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.GetHashCode">
      <summary>
            Hash code override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.ParameterType">
      <summary>
            Type of the parameter
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.Name">
      <summary>
            Parmater name
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XParameterDeclaration.Attributes">
      <summary>
            Attributes attached to the parameter
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XPointerType">
      <summary>
            A pointer type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPointerType.ElementType">
      <summary>
            The associated element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPointerType.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XPropertyDeclaration">
      <summary>
            Property declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyDeclaration.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyDeclaration.Equals(System.Object)">
      <summary>
            Determines if this method reference is equal to another (representing the method declaration)
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyDeclaration.GetHashCode">
      <summary>
            GetHashCode override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XPropertyIndexerExpression">
      <summary>
            Property index expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyIndexerExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyIndexerExpression.Indices">
      <summary>
            Expressions for the indices
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyIndexerExpression.Target">
      <summary>
            Property reference expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XPropertyReference">
      <summary>
            Property reference
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.Resolve">
      <summary>
            Resolve the property reference
            </summary>
      <remarks>
            This does not deal with generic properties
            </remarks>
      <returns>The property declaration for this reference</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.Equals(System.Object)">
      <summary>
            Determines if this method reference is equal to another (representing the method declaration)
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.GetHashCode">
      <summary>
            GetHashCode override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.GenericProperty">
      <summary>
            Generic property of which this is a specialization (if any)
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.Parameters">
      <summary>
            Parameters of the property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.PropertyType">
      <summary>
            Type of the property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.DeclaringType">
      <summary>
            Declaring type for this property
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReference.Name">
      <summary>
            Name of this property
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XPropertyReferenceExpression">
      <summary>
            Property reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XPropertyReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReferenceExpression.Property">
      <summary>
            The property reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XPropertyReferenceExpression.Target">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XReferenceType">
      <summary>
            Reference type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XReferenceType.ElementType">
      <summary>
            The underlying element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XReferenceType.DotNetType">
      <summary>
            The dotNet type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XRequiredModifier">
      <summary>
            A required modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XRequiredModifier.ElementType">
      <summary>
            The element type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XRequiredModifier.Modifier">
      <summary>
            The modifier
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XRequiredModifier.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XSwitchStatement">
      <summary>
            A switch statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XSwitchStatement.Cases">
      <summary>
            The collection of cases
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XSwitchStatement.Expression">
      <summary>
            The expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XThisReferenceExpression">
      <summary>
            A 'this' reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XThisReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XThrowExceptionStatement.Expression">
      <summary>
            The expression thrown
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTryCatchFinallyStatement.CatchClauses">
      <summary>
            The catch clauses
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTryCatchFinallyStatement.Fault">
      <summary>
            Default catch statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTryCatchFinallyStatement.Finally">
      <summary>
            Finally statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration">
      <summary>
            This class models a type declaration. It is not the specialization of a generic type
            but may be a generic type definition
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.ToString">
      <summary>
            ToString override
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Resolve">
      <summary>
            Resolve. As this is a declaration, it resolves to itself
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Abstract">
      <summary>
            Whether this is an abstract type or not
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.BaseType">
      <summary>
            Type that this type is inherited from
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Fields">
      <summary>
            Fields declared by this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Interface">
      <summary>
            Whether this type is an interface or not
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Interfaces">
      <summary>
            Interfaces that this type derives from
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Methods">
      <summary>
            Methods declared by this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.NestedTypes">
      <summary>
            Declared types nested in this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Properties">
      <summary>
            Properties declared in this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Events">
      <summary>
            Events declared in this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Sealed">
      <summary>
            Whether this type is sealed or not
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Partial">
      <summary>
            Whether this declaration is partial or not
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Visibility">
      <summary>
            Visibility of this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.GenericType">
      <summary>
            TypeDeclaration is not used to represent specializations - use TypeInstanceDeclaration
            instead. This method will return null on get and throw an exception on set
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Name">
      <summary>
            Name of the type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Namespace">
      <summary>
            Namespace of the type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Owner">
      <summary>
            Owner of the type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Attributes">
      <summary>
            Attributes attached to this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.Documentation">
      <summary>
            Documentation for this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeDeclaration.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration">
      <summary>
            This class models a type declaration which is a specialization of a generic type
            declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Resolve">
      <summary>
            Just returns this. It is already a declaration
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Abstract">
      <summary>
            Whether the type is abstract - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.BaseType">
      <summary>
            This type's base typ - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Fields">
      <summary>
            Get the specialized collection of fields
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Interface">
      <summary>
            Whether this type is an interface - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Interfaces">
      <summary>
            Get the specialized collection of interfaces implemented by this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Methods">
      <summary>
            Get the specialized collection of methods implemented by this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Properties">
      <summary>
            Get the specialized collection of properties
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Events">
      <summary>
            Get the specialized collection of events
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Sealed">
      <summary>
            Whether this type is sealed - this is the same as for the GenericType.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Partial">
      <summary>
            Whether this type declaration is partial - this is the same as for the GenericType.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Visibility">
      <summary>
            The visibility of this specialization - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.GenericType">
      <summary>
            The generic type for which this is a specialization.
            Setting this property will trigger a resolve of the type
            reference to its declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Name">
      <summary>
            The name of this type - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Namespace">
      <summary>
            The namespace of this type - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Owner">
      <summary>
            The owner of this specialization - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.ValueType">
      <summary>
            Whether this is a value type or not - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.GenericArguments">
      <summary>
            Generic arguments for this type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Attributes">
      <summary>
            Custom attributes for this declaration
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.Documentation">
      <summary>
            The documentation for this type - this is the same as for the GenericMethod.
            For this reason, it cannot be set in this class
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceDeclaration.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference">
      <summary>
            This class models a reference to a specialization of a generic type
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.AreEqual(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference)">
      <summary>
            Static method to see if two TypeInstanceReferences are equal
            </summary>
      <param name="itr1">First TypeInstanceReference</param>
      <param name="itr2">Second TypInstanceReference</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.Compare(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference)">
      <summary>
            Static method to compare two TypeInstanceReference instances
            </summary>
      <param name="itr1">First TypeInstanceReference</param>
      <param name="itr2">Second TypInstanceReference</param>
      <returns>-1, 0 or 1</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.Resolve">
      <summary>
            Resolve this specialization
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.GenericType">
      <summary>
            Generic type of which this is a specialization (if any)
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.Name">
      <summary>
            Name of type specialization
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.Namespace">
      <summary>
            Namespace
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.Owner">
      <summary>
            Owner
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.ValueType">
      <summary>
            WHether this is a value type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.GenericArguments">
      <summary>
            Generic arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeInstanceReference.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeOfExpression">
      <summary>
            'typeof' expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeOfExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeOfExpression.Type">
      <summary>
            The type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeReference">
      <summary>
            Type reference
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeReference.GenericArguments">
      <summary>
            Generic arguments
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeReference.DotNetType">
      <summary>
            Dot net type
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XTypeReferenceExpression">
      <summary>
            Type reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XTypeReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XTypeReferenceExpression.Type">
      <summary>
            The type referecne
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XUnaryExpression">
      <summary>
            Unary expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XUnaryExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XUnaryExpression.Expression">
      <summary>
            The expression operated on
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XUnaryExpression.Operator">
      <summary>
            The operator
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XUsingStatement">
      <summary>
            Using statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XUsingStatement.Body">
      <summary>
            The body of the using statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XUsingStatement.Expression">
      <summary>
            The expression in the using statement
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XVariableDeclaration">
      <summary>
            Variable declaration
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XVariableDeclaration.Resolve">
      <summary>
            Always returns 'this'
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XVariableDeclaration.Identifier">
      <summary>
            Identifier for this variable
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XVariableDeclaration.Name">
      <summary>
            Name of this variable
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XVariableDeclaration.VariableType">
      <summary>
            Type of the variable
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XVariableDeclarationExpression">
      <summary>
            Variable declaration expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XVariableDeclarationExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XVariableDeclarationExpression.Variable">
      <summary>
            The variable declaration
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XVariableReferenceExpression">
      <summary>
            Variable reference expression
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeModel.XVariableReferenceExpression.GetExpressionType">
      <summary>
            Get expression type
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XVariableReferenceExpression.Variable">
      <summary>
            The variable
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeModel.XWhileStatement">
      <summary>
            While statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XWhileStatement.Body">
      <summary>
            The body of the while statement
            </summary>
    </member>
    <member name="P:MicrosoftResearch.Transforms.CodeModel.XWhileStatement.Condition">
      <summary>
            The condition expression
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeRecognizer">
      <summary>
            Helper class for recognizing patterns in code which is to be transformed.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeRecognizer.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsStaticMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type)">
      <summary>
            True if expr is a MethodInvokeExpression on any static method of type.
            </summary>
      <param name="expr">
      </param>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsStaticMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,System.String)">
      <summary>
            True if expr is a MethodInvokeExpression on any overload of the named static method of type.
            </summary>
      <param name="expr">
      </param>
      <param name="type">
      </param>
      <param name="methodName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsStaticGenericMethod(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Type,System.String)">
      <summary>
            True if imie is a MethodInvokeExpression on any overload of the named static generic method of type.
            </summary>
      <param name="expr">
      </param>
      <param name="type">
      </param>
      <param name="methodName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsBeingMutated(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the expression is being mutated in the given context.  For example, this will
            be true if the expression is the LHS of an assignment, or the argument to an 'out' parameter.
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.MutatingFirstAffectsSecond(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Boolean,System.Collections.Generic.IDictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeRecognizer.Bounds},System.Collections.Generic.IDictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,MicrosoftResearch.Transforms.CodeRecognizer.Bounds},System.Collections.Generic.IDictionary{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration,System.Int32},System.Collections.Generic.ICollection{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Returns true if mutating the first expression would affect the value of the second.
            For example, if the first expression is 'x' and the second is 'x[1]' the answer is true.
            If the first expression is 'x[0]' and the second is 'x[1]' the answer is false.
            
            If 'mutatesWithinOnly' is true, the result will only be true if the first expression mutates
            all or part of the second, but nothing else.  For example, if the first is 'x[0]' and the second is 'x'
            the result is true but not if the first is 'x' and the second 'x[0]'. 
            </summary>
      <param name="context">The context</param>
      <param name="mutated">The mutating expression</param>
      <param name="affected">The possibly affected expression</param>
      <param name="mutatesWithinOnly">See summary</param>
      <param name="boundsInMutated">Lower bounds on the index variables in mutated</param>
      <param name="boundsInAffected">Lower bounds on the index variables in affected</param>
      <param name="offsets">Modified to contain indexing offsets necessary for a match</param>
      <param name="extraIndices">Modified to contain loop indices in mutated that must be iterated to cover affected (i.e. loops that cannot be merged)</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsOnLHSOfAssignment(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if expr is on the left hand side of the innermost assignment statement in the context stack.
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsIndexedBy(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression},MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Returns true if any of the reference expressions refer to the specified index variable.
            </summary>
      <param name="refs">
      </param>
      <param name="indexVar">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsPartOf(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the first expression is equal to, or a subarray or element of the second expression.
            For example, x, x[0], x[0][0] are all subarrays of x, but x[1] is not part of x[0].
            </summary>
      <param name="expr">
      </param>
      <param name="arrayExpr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetParameterDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Extracts the declaration of the parameter reference from a, possibly indexed, argument reference expression.
            Returns null if the expression is not either of these.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetFieldReference(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Extracts the field reference from a, possibly indexed, field reference expression.
            Returns null if the expression is not either of these.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetVariableDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Extracts the variable declaration from a, possibly indexed, reference or declaration expression.
            Returns null if the expression is not either of these.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Extracts the variable or parameter declaration from a, possibly indexed, reference or declaration expression.
            Returns null if the expression is not either of these.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetTarget(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get the innermost target of an expression, e.g. x[0].field[1].method(y) returns 'x'
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetAllPrefixes(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get a list of prefixes of the given expression, starting from the innermost target, up to and including the given expression.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.ForEachVariable(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Perform an action on each variable reference that appears in an expression.  The same variable may appear more than once.
            </summary>
      <param name="expr">Any expression</param>
      <param name="action">Any action</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.ForEachTarget(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Apply action to every expression on the lhs of an assignment.
            </summary>
      <param name="ist">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.ForEachTargetVariable(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement,System.Action{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration})">
      <summary>
            Apply action to every variable on the lhs of an assignment.
            </summary>
      <param name="ist">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetVariableDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Extracts the variable declaration from a declaration statement.
            Returns null if the statement is not a declaration statement.
            </summary>
      <param name="ist">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetIndexingDepth(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns the number of indexing brackets at the end of expr (zero if none)
            </summary>
      <param name="iexpr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.AddIndexers(MicrosoftResearch.Transforms.BasicTransformContext,System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration[]},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Add the declarations of all loop variables in expr to indVars.
            </summary>
      <param name="context">
      </param>
      <param name="indVars">
      </param>
      <param name="expr">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Get a list of all index expressions at the end of expr, innermost first.
            </summary>
      <param name="expr">
      </param>
      <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetIndices(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@)">
      <summary>
            Get a list of all index expressions at the end of expr, innermost first.
            </summary>
      <param name="expr">
      </param>
      <param name="target">On exit, the innermost expression being indexed, i.e. the array variable</param>
      <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.AddIndices(System.Collections.Generic.List{System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression}},MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@)">
      <summary>
            Add all index expressions at the end of expr to indices, innermost first.
            </summary>
      <param name="indices">Index expressions</param>
      <param name="expr">The expression</param>
      <param name="target">The output expression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.RemoveLastIndex(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Remove the last index from an expression
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.GetLoopForVariable(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Returns the for statement associated with the specified loop counter or null if none
            </summary>
      <param name="context">
      </param>
      <param name="loopRef">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.ForLoopDepth(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Returns the number of nested for loops in the deepest part of the statement.
            </summary>
      <param name="ist">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsAnyStochastic(MicrosoftResearch.Transforms.BasicTransformContext,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression})">
      <summary>
            Returns true if any of the expression are stochastic.
            </summary>
      <param name="context">
      </param>
      <param name="iec">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.IsStochastic(MicrosoftResearch.Transforms.BasicTransformContext,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Returns true if the expression is stochastic.
            </summary>
      <param name="context">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.CodeRecognizer.RemoveCast(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Removes a cast when it is safe to do so.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.CodeTransformer">
      <summary>
            Transforms type declarations.
            </summary>
            TODO: Add GeneratedCode attribute to results.
        </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.language">
      <summary>
            The language that we'll compile
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.writeSourceFiles">
      <summary>
            If true, source code files are written out for each transformed class.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.useExistingFiles">
      <summary>
            If true, existing source code files are used.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.generateInMemory">
      <summary>
            If true, source code files are written out for each transformed class.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.GeneratedSourceFolder">
      <summary>
            The absolute or relative path to the generated source code.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.showProgress">
      <summary>
            If true, print messages about compilation progress.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.optimizeCode">
      <summary>
            If true, causes the C# compiler to generate optimized code
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.CodeCompiler.includeDebugInformation">
      <summary>
            If true, causes the C# compiler to include debug information in the generated DLL.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Infer.CompilerAttributes.DescriptionAttribute">
      <summary>
            Specifies a description for whatever the attribute is attached to.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Infer.CompilerAttributes.DescriptionAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.CompilerAttributes.DescriptionAttribute" /> class.
            </summary>
      <param name="description">The description for the attribute</param>
    </member>
    <member name="P:MicrosoftResearch.Infer.CompilerAttributes.DescriptionAttribute.Description">
      <summary>
            The description for the attribute.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.ExpressionEvaluator.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.ExpressionEvaluator.Quote(System.Object)">
      <summary>
            Quotes an object instance or returns null if it cannot.  
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.LinqExpressionTransform">
      <summary>
            Converts expressions in the form of a Linq Expression tree into
            the equivalent Infer.NET expression.
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.Convert(System.Linq.Expressions.Expression)">
      <summary>
            Converts a LINQ expression into the Infer.NET equivalent.
            </summary>
      <param name="expression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>
            Converts a LINQ method call expression into the Infer.NET equivalent.
            </summary>
      <param name="methodCallExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>
            Converts a LINQ constant expression into the Infer.NET equivalent.
            </summary>
      <param name="constantExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertParameterRef(System.Linq.Expressions.ParameterExpression)">
      <summary>
            Converts a LINQ parameter expression into the Infer.NET equivalent.
            </summary>
      <param name="parameterExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertMember(System.Linq.Expressions.MemberExpression)">
      <summary>
            Converts a LINQ member expression into the Infer.NET equivalent.
            </summary>
      <param name="memberExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>
            Converts a LINQ binary expression into the Infer.NET equivalent.
            </summary>
      <param name="binaryExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertBinaryOp(System.Linq.Expressions.ExpressionType)">
      <summary>
            Converts a LINQ binary operator into the Infer.NET equivalent.
            </summary>
      <param name="nodeType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertLambda(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Converts a LINQ lambda expression into the Infer.NET equivalent.
            </summary>
      <param name="lambdaExpression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertParameterToVar(System.Linq.Expressions.ParameterExpression)">
      <summary>
            Converts a parameter expression into the Infer.NET equivalent variable declaration.
            (needed because we use variable declarations instead of parameter declarations for lambda parameters).
            </summary>
      <param name="p">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LinqExpressionTransform.ConvertParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>
            Converts a parameter expression into the Infer.NET equivalent
            </summary>
      <param name="p">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.IDeclarationProvider">
      <summary>
            Declaration provider
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.IDeclarationProvider.GetTypeDeclaration(System.Type,System.Boolean)">
      <summary>
            Get type declaration from type
            </summary>
      <param name="t">The dotNET type</param>
      <param name="translate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.LanguageWriter">
      <summary>
            Language writer base class. It is intended that classes implementing
            ILanguageWriter should inherit from this class.
            The base class manages the general traversal, generating a tree of source nodes.
            Specific leaf details are filled in by derived classes
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.Builder">
      <summary>
            Helps build class declarations
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.nodeStack">
      <summary>
            node stack representing the current path in the tree node collection
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.typeReferenceMap">
      <summary>
            Dictionary mapping type reference names to namespace
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.tabStrings">
      <summary>
            List of tabs
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.isConflict">
      <summary>
            Flag that tracks if there's a conflict in type names. If so,
            the specific type will need to be fully qualified.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.BinaryOpLookUp">
      <summary>
            Binary operator look-up table
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.UnaryOpLookUp">
      <summary>
            Unary operator look-up table
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.LanguageWriter.IntrinsicTypeAlias">
      <summary>
            Type look-up table for intrinsic dotNet types
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.Initialise">
      <summary>
            Initialise the language writer
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.ValidIdentifier(System.String)">
      <summary>
            Return a valid identifier - this deals with reserved words in the
            particular language
            </summary>
      <param name="ident">Identifier</param>
      <returns>A valid identifier</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.GetTabString">
      <summary>
            Get the current tab string
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AddChild(MicrosoftResearch.Transforms.SourceNode)">
      <summary>
            Add a child to the current source node
            </summary>
      <param name="sn">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendArrayType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType)">
      <summary>
            Append an array type to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="iat">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendTypeReference(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference)">
      <summary>
            Append a type reference to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="itr">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendReferenceType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IReferenceType)">
      <summary>
            Append a reference type to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="irt">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendGenericParameterType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericParameter)">
      <summary>
            Append a generic parameter type to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="igpt">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendGenericArgumentType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgument)">
      <summary>
            Append a generic argument type to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="igat">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendType(System.Text.StringBuilder,System.Type)">
      <summary>
            Append a type to a StringBuilder
            </summary>
      <param name="sb">The StringBuilder</param>
      <param name="it">The type</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Append a type to a StringBuilder
            </summary>
      <param name="sb">The StringBuilder</param>
      <param name="it">The type</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.TypeSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IType)">
      <summary>
            Type source
            </summary>
      <param name="it">Type</param>
      <returns>type source string</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.VariableDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Variable declaration source
            </summary>
      <param name="ivd">Variable declaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AppendExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Append an expression to a StringBuilder
            </summary>
      <param name="sb">The StringBuilder</param>
      <param name="ie">The IExpression</param>
      <remarks>This is not exhaustive</remarks>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.ExpressionSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            Expression source
            </summary>
      <param name="ie">Expression</param>
      <returns>expression source string</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.ParameterDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration)">
      <summary>
            Parameter declaration source
            </summary>
      <param name="ipd">Parameter declaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.ParameterDeclarationCollectionSource(System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration})">
      <summary>
            Parameter collection source
            </summary>
      <param name="parameters">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.TypeDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            This converts an input type into source, calling recursively into any
            methods, fields, properties, and/or nested types.
            </summary>
      <param name="itd">The input type declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachBlockStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            Attach block statement
            </summary>
      <param name="ibs">Block statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachBreakStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBreakStatement)">
      <summary>
            Attach break statement
            </summary>
      <param name="ibs">Break statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachCommentStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.ICommentStatement)">
      <summary>
            Attach comment statement
            </summary>
      <param name="ics">Comment statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachConditionStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            Attach condition statement
            </summary>
      <param name="ics">Condition statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachExpressionStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpressionStatement)">
      <summary>
            Attach expression statement
            </summary>
      <param name="ies">Expression statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachForEachStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement)">
      <summary>
            Attach foreach statement
            </summary>
      <param name="ifes">Foreach statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachForStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            Attach for statement
            </summary>
      <param name="ifs">For statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachRepeatStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement)">
      <summary>
            Attach repeat statement
            </summary>
      <param name="irs">Repeat statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachMethodReturnStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnStatement)">
      <summary>
            Attach method return statement
            </summary>
      <param name="imrs">Method return statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachSwitchStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement)">
      <summary>
            Attach switch statement
            </summary>
      <param name="iss">Switch statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachSwitchCase(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchCase)">
      <summary>
            Attach Switch case
            </summary>
      <param name="isc">Switch case</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachCatchClause(MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause)">
      <summary>
            Attach catch clause
            </summary>
      <param name="icc">Catch clause</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachThrowExceptionStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IThrowExceptionStatement)">
      <summary>
            Attach a throw exception statement
            </summary>
      <param name="ites">Throw exception statement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachTryCatchFinallyStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            Attach a Try/Catch/Finally statement
            </summary>
      <param name="itcfs">Try/Catch/Finally statement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachUsingStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement)">
      <summary>
            Attach using statement
            </summary>
      <param name="ius">Using statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachWhileStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement)">
      <summary>
            Attach while statement
            </summary>
      <param name="iws">While statement</param>
      <returns>source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachStatement(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Attach statement to the source tree
            </summary>
      <param name="ist">The statement</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachStatements(System.Collections.Generic.IEnumerable{MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement})">
      <summary>
            Attach all statements to the source tree
            </summary>
      <param name="isc">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.StatementSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IStatement)">
      <summary>
            Source for a statement
            </summary>
      <param name="ist">Statement</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachMethodDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            Attach a method to the source tree
            </summary>
      <param name="imd">Method declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.MethodDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            Method declaration source
            </summary>
      <param name="imd">Method declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachFieldDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration)">
      <summary>
            Attach a field to the source tree
            </summary>
      <param name="ifd">Field declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.FieldDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration)">
      <summary>
            Convert an individual field to source
            </summary>
      <param name="ifd">Field declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachPropertyDeclarationCollection(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration})">
      <summary>
            Convert property collection to a source node and attach to
            cuurent node
            </summary>
      <param name="ipdc">Property collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.PropertyDeclarationCollectionSource(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration})">
      <summary>
            Convert properties to source
            </summary>
      <param name="ipdc">Property collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachPropertyDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration)">
      <summary>
            Attach a property to the source tree
            </summary>
      <param name="ipd">Property declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.PropertyDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration)">
      <summary>
            Generate source for a single property
            </summary>
      <param name="ipd">Property declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachEventDeclarationCollection(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration})">
      <summary>
            Convert event collection to a source node and attach to
            cuurent node
            </summary>
      <param name="iedc">Events collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.EventDeclarationCollectionSource(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration})">
      <summary>
            Convert events to source
            </summary>
      <param name="iedc">Event collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachEventDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            Attach an event declaration to the source tree
            </summary>
      <param name="ied">Event declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.EventDeclarationSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            Generate source for a single event
            </summary>
      <param name="ied">Event declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachTypeDeclarationCollection(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration})">
      <summary>
            Attach a type collection to the source tree
            </summary>
      <param name="intdc">Type collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.TypeDeclarationCollectionSource(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration})">
      <summary>
            Convert type collection to source
            </summary>
      <param name="intdc">Type collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachFieldDeclarationCollection(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration})">
      <summary>
            Attach field collection to source tree
            </summary>
      <param name="ifdc">Field collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.FieldDeclarationCollectionSource(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration})">
      <summary>
            Convert fields to source
            </summary>
      <param name="ifdc">Field collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.AttachMethodDeclarationCollection(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration})">
      <summary>
            Attach method collection to the source tree
            </summary>
      <param name="imdc">Method collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.MethodDeclarationCollectionSource(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration})">
      <summary>
            Convert methods to source
            </summary>
      <param name="imdc">Method collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriter.WriteSourceNode(System.IO.TextWriter,MicrosoftResearch.Transforms.SourceNode)">
      <summary>
            Write a source node to a string
            </summary>
      <param name="sw">String writer</param>
      <param name="sn">Source node</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendInterfaces(System.Text.StringBuilder,System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReference},System.Boolean)">
      <summary>
            Append interfaces from which a class is derived
            </summary>
      <param name="sb">The string builder to append to</param>
      <param name="interfaces">The interfaces</param>
      <param name="hasBaseType">Whether the type has a base type</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAttribute(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ICustomAttribute)">
      <summary>
            Append an attribute.
            </summary>
      <param name="sb">StringBuilder to append to </param>
      <param name="attr">The attribute</param>
      <remarks>This is not exhaustive</remarks>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendGenericArguments(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IGenericArgumentProvider)">
      <summary>
            Append generic arguments to a type or method name
            </summary>
      <param name="sb">string builder</param>
      <param name="igap">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendArrayRank(System.Text.StringBuilder,System.Int32)">
      <summary>
            Append an array rankn to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ar">array rank</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendVariableDeclaration(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclaration)">
      <summary>
            Append a variable declaration to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ivd">IVariableDeclaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAddressOutExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressOutExpression)">
      <summary>
            Append address out expression
            </summary>
      <param name="sb">string builder</param>
      <param name="iae">address out expression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendArgumentReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArgumentReferenceExpression)">
      <summary>
            Append argument reference expression
            </summary>
      <param name="sb">string builder</param>
      <param name="iare">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendArrayType(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayType)">
      <summary>
            Append an array type to a string builder
            </summary>
      <param name="sb">
      </param>
      <param name="iat">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendArrayCreateExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayCreateExpression)">
      <summary>
      </summary>
      <param name="sb">string builder</param>
      <param name="iae">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendArrayIndexerExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IArrayIndexerExpression)">
      <summary>
      </summary>
      <param name="sb">string builder</param>
      <param name="iaie">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAssignExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IAssignExpression)">
      <summary>
            Append an IAssignExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iae">IAssignExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendBaseReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBaseReferenceExpression)">
      <summary>
            Append an IBaseReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ibre">IBaseReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendBinaryExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBinaryExpression)">
      <summary>
            Append an IBinaryExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ibe">IBinaryExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendBlockExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockExpression)">
      <summary>
            Append an IBlockExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ibe">IBlockExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendCastExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ICastExpression)">
      <summary>
            Append an ICastExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ice">ICastExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendConditionExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionExpression)">
      <summary>
            Append an IConditionExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ice">IConditionExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendDelegateCreateExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateCreateExpression)">
      <summary>
            Append an IDelegateCreateExpression expression
            </summary>
      <param name="sb">string builder</param>
      <param name="idce">IDelegateCreateExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendEventReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventReferenceExpression)">
      <summary>
            Append an IEventReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iere">IEventReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendFieldReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldReferenceExpression)">
      <summary>
            Append an IFieldReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ifre">IFieldReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendLambdaExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ILambdaExpression)">
      <summary>
            Append an ILambdaExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ile">ILambdaExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendLiteralExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ILiteralExpression)">
      <summary>
            Append an ILiteralExpression to a string builder, maximizing readability.
            </summary>
      <param name="sb">string builder</param>
      <param name="ile">ILiteralExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendMethodInvokeExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodInvokeExpression)">
      <summary>
            Append an IMethodInvokeExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="imie">IMethodInvokeExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MayNeedParentheses(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression)">
      <summary>
            True if the expression may need to be parenthesized when used in a larger expression.
            </summary>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendMethodReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReferenceExpression)">
      <summary>
            Append an IMethodReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="imre">IMethodReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendObjectCreateExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IObjectCreateExpression)">
      <summary>
            Append an IObjectCreateExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ioce">IObjectCreateExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendPropertyIndexerExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyIndexerExpression)">
      <summary>
            Append an IPropertyIndexerExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ipie">IPropertyIndexerExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendPropertyReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyReferenceExpression)">
      <summary>
            Append an IPropertyReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ipre">IPropertyReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendThisReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IThisReferenceExpression)">
      <summary>
            Append an IThisReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="itre">IThisReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendTypeOfExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeOfExpression)">
      <summary>
            Append an ITypeOfExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="itoe">ITypeOfExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendTypeReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeReferenceExpression)">
      <summary>
            Append an ITypeReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="itre">ITypeReferenceExpression&gt;</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendUnaryExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IUnaryExpression)">
      <summary>
            Append an IUnaryExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iue">IUnaryExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendVariableDeclarationExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableDeclarationExpression)">
      <summary>
            Append an IVariableDeclarationExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ivde">IVariableDeclarationExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendVariableReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IVariableReferenceExpression)">
      <summary>
            Append an IVariableReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="ivre">IVariableReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAddressReferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressReferenceExpression)">
      <summary>
            Append an IAddressReferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iare">IAddressReferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAddressDereferenceExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IAddressDereferenceExpression)">
      <summary>
            Append an IAddressDereferenceExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iade">IAddressDereferenceExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendAnonymousMethodExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IAnonymousMethodExpression)">
      <summary>
            Append an IAnonymousMethodExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="iame">IAnonymousMethodExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendMemberInitializerExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IMemberInitializerExpression)">
      <summary>
            Append an IMemberInitializerExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="imie">IMemberInitializerExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendDelegateInvokeExpression(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IDelegateInvokeExpression)">
      <summary>
            Append an IDelegateInvokeExpression to a string builder
            </summary>
      <param name="sb">string builder</param>
      <param name="idie">IDelegateInvokeExpression</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendParameterDeclaration(System.Text.StringBuilder,MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration)">
      <summary>
            Append parameter declaration to a string builder
            </summary>
      <param name="sb">String builder</param>
      <param name="ipd">Parameter declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendParameterDeclarationCollection(System.Text.StringBuilder,System.Collections.Generic.IList{MicrosoftResearch.Transforms.CodeModel.Interfaces.IParameterDeclaration})">
      <summary>
            Append parameter declaration collection to a string builder
            </summary>
      <param name="sb">String builder</param>
      <param name="parameters">Parameter collection</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AttachPropertyAccessor(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReference,System.Boolean)">
      <summary>
            Attach a property accessor
            </summary>
      <param name="imr">Method reference</param>
      <param name="set">True if set rather than get</param>
      <remarks>This is not fully general</remarks>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.GenerateSource(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            Generate the source
            </summary>
      <param name="itd">The type declaration</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AppendDocumentation(System.Text.StringBuilder,System.String)">
      <summary>
            Appends documentation.
            </summary>
      <param name="sb">
      </param>
      <param name="doc">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.AttachTypeDeclaration(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration)">
      <summary>
            Attach a type to the source tree
            </summary>
      <param name="itd">Type declaration</param>
      <returns>Source node</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.BlockStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            IBlockStatement start string
            </summary>
      <param name="ibs">IBlockStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.BlockStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBlockStatement)">
      <summary>
            IBlockStatement end string
            </summary>
      <param name="ibs">IBlockStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.BreakStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IBreakStatement)">
      <summary>
            IBreakStatement start string
            </summary>
      <param name="ibs">IBreakStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.CommentStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ICommentStatement)">
      <summary>
            ICommentStatement start string
            </summary>
      <param name="ics">ICommentStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.IfStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            IConditionStatement IfThen start string
            </summary>
      <param name="ics">IConditionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.IfStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            IConditionStatement IfThen end string
            </summary>
      <param name="ics">IConditionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ElseStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            IConditionStatement Else start string
            </summary>
      <param name="ics">IConditionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ElseStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IConditionStatement)">
      <summary>
            IConditionStatement Else end string
            </summary>
      <param name="ics">IConditionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ContinueStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IContinueStatement)">
      <summary>
            IContinueStatement start string
            </summary>
      <param name="ics">IContinueStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ExpressionStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpressionStatement)">
      <summary>
            IExpressionStatement start string
            </summary>
      <param name="ies">IExpressionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ExpressionStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpressionStatement)">
      <summary>
            IExpressionStatement end string
            </summary>
      <param name="ies">IExpressionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ForEachStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement)">
      <summary>
            IForEachStatement start string
            </summary>
      <param name="ifes">IForEachStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ForEachStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForEachStatement)">
      <summary>
            IForEachStatement end string
            </summary>
      <param name="ifes">IForEachStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ForStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            IForStatement start string
            </summary>
      <param name="ifs">IForStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ForStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IForStatement)">
      <summary>
            IForStatement end string
            </summary>
      <param name="ifs">IForStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.RepeatStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement)">
      <summary>
            IRepeatStatement start string
            </summary>
      <param name="irs">IRepeatStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.RepeatStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IRepeatStatement)">
      <summary>
            IRepeatStatement end string
            </summary>
      <param name="irs">IRepeatStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodReturnStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnStatement)">
      <summary>
            IMethodReturnStatement start string
            </summary>
      <param name="imrs">IMethodReturnStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodReturnStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodReturnStatement)">
      <summary>
            IMethodReturnStatement end string
            </summary>
      <param name="imrs">IMethodReturnStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.SwitchStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement)">
      <summary>
            ISwitchStatement start string
            </summary>
      <param name="iss">ISwitchStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.SwitchStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchStatement)">
      <summary>
            ISwitchStatement end string
            </summary>
      <param name="iss">ISwitchStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.SwitchCaseStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchCase)">
      <summary>
            ISwitchCase start string
            </summary>
      <param name="isc">ISwitchCase</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.SwitchCaseEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ISwitchCase)">
      <summary>
            ISwitchCase end string
            </summary>
      <param name="isc">ISwitchCase</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ThrowExceptionStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IThrowExceptionStatement)">
      <summary>
            Throw exception start string
            </summary>
      <param name="ites">IThrowExceptionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.ThrowExceptionEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IThrowExceptionStatement)">
      <summary>
            Throw exception end string
            </summary>
      <param name="ites">IThrowExceptionStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.TryBlockStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally start string for Try block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.TryBlockEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally end string for Try block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FaultBlockStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally start string for Fault block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FaultBlockEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally end string for Fault block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.CatchClauseStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause)">
      <summary>
            Catch clause start
            </summary>
      <param name="icc">catch clause</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.CatchClauseEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ICatchClause)">
      <summary>
            Catch clause end
            </summary>
      <param name="icc">catch clause</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FinallyBlockStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally start string for Finally block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FinallyBlockEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.ITryCatchFinallyStatement)">
      <summary>
            ITryCatchFinally end string for Finally block
            </summary>
      <param name="itcfs">ITryCatchFinally</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.UsingStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement)">
      <summary>
            UsingStatementStart start string
            </summary>
      <param name="ius">UsingStatementStart</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.UsingStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IUsingStatement)">
      <summary>
            UsingStatementStart end string
            </summary>
      <param name="ius">UsingStatementStart</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.WhileStatementStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement)">
      <summary>
            IWhileStatement start string
            </summary>
      <param name="iws">IWhileStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.WhileStatementEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IWhileStatement)">
      <summary>
            IWhileStatement end string
            </summary>
      <param name="iws">IWhileStatement</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodDeclarationStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            IMethodDeclaration start string
            </summary>
      <param name="imd">IMethodDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodDeclarationEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration)">
      <summary>
            IMethodDeclaration end string
            </summary>
      <param name="imd">IMethodDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FieldDeclarationStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration)">
      <summary>
            IFieldDeclaration start string
            </summary>
      <param name="ifd">IFieldDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FieldDeclarationEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration)">
      <summary>
            IFieldDeclaration end string
            </summary>
      <param name="ifd">IFieldDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.PropertyDeclarationCollectionStart(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration})">
      <summary>
            IPropertyDeclarationCollection start string
            </summary>
      <param name="ipdc">IPropertyDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.PropertyDeclarationCollectionEnd(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration})">
      <summary>
            IPropertyDeclarationCollection end string
            </summary>
      <param name="ipdc">IPropertyDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.PropertyDeclarationStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration)">
      <summary>
            IPropertyDeclaration start string
            </summary>
      <param name="ipd">IPropertyDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.PropertyDeclarationEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IPropertyDeclaration)">
      <summary>
            IPropertyDeclaration end string
            </summary>
      <param name="ipd">IPropertyDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.EventDeclarationStart(MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            IEventDeclaration start string
            </summary>
      <param name="ied">IEventDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.EventDeclarationEnd(MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration)">
      <summary>
            IEventDeclaration end string
            </summary>
      <param name="ied">IEventDeclaration</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.TypeDeclarationCollectionStart(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration})">
      <summary>
            ITypeDeclarationCollection start string
            </summary>
      <param name="intdc">ITypeDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.TypeDeclarationCollectionEnd(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.ITypeDeclaration})">
      <summary>
            ITypeDeclarationCollection end string
            </summary>
      <param name="intdc">ITypeDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FieldDeclarationCollectionStart(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration})">
      <summary>
            IFieldDeclarationCollection start string
            </summary>
      <param name="ifdc">IFieldDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.FieldDeclarationCollectionEnd(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IFieldDeclaration})">
      <summary>
            IFieldDeclarationCollection end string
            </summary>
      <param name="ifdc">IFieldDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodDeclarationCollectionStart(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration})">
      <summary>
            IMethodDeclarationCollection start string
            </summary>
      <param name="imdc">IMethodDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.MethodDeclarationCollectionEnd(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IMethodDeclaration})">
      <summary>
            IMethodDeclarationCollection end string
            </summary>
      <param name="imdc">IMethodDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.EventDeclarationCollectionStart(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration})">
      <summary>
            IEventDeclarationCollection start string
            </summary>
      <param name="iedc">IEventDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.EventDeclarationCollectionEnd(System.Collections.Generic.List{MicrosoftResearch.Transforms.CodeModel.Interfaces.IEventDeclaration})">
      <summary>
            IEventDeclarationCollection end string
            </summary>
      <param name="iedc">IEventDeclarationCollection</param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.LanguageWriters.CSharpWriter.IsNegativeZero(System.Double)">
      <summary>
            True if the given double is negative zero (-0.0).
            </summary>
      <param name="x">A double.</param>
      <returns>True, if the given double is negative zero (-0.0).</returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.Quoter">
      <summary>
            Provides static methods for quoting objects into instances of the code model.
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.Quoter.Builder">
      <summary>
            Helps build expressions
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.Quoter.Quote(System.Object)">
      <summary>
            Quotes the object and returns the quoted expression.
            </summary>
      <param name="value">The object to quote</param>
      <returns>An expression which would evaluate to the supplied value.</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.Quoter.TryQuoteConstructable(System.Object,MicrosoftResearch.Transforms.CodeModel.Interfaces.IExpression@,System.String,System.Type)">
      <summary>
            Trys to quote an object using any Construction attributes that it is
            annotated with.
            </summary>
      <remarks>
            This method can be used to quote a different object that the one passed in, by using
            'useWhenOverride'.  For example, setting it to 'IsUniform' will mean that the value will
            be quoted as if 'IsUniform' were true.  In general, this will result in quoting the closest
            value that meets the specified condition.
            </remarks>
      <param name="value">The value to quote</param>
      <param name="expr">The quoted expression or null if quoting failed</param>
      <param name="useWhenOverride">Overrides which construction attribute to use, to quote
            <param name="valueType">The type of the value to quote or null to use value.GetType()</param>
            the object passed in modified to have the condition be true</param>
      <returns>True if the quoting succeeded</returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.Quoter.GetPublicType(System.Type)">
      <summary>
            When quoting objects whose types are not public, the quoted expression
            must have a different type.  If the passed in type is not public, this method 
            returns the public type that it will be quoted as.  If it is public, the type
            argument will be returned as is.
            </summary>
      <param name="tp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:MicrosoftResearch.Transforms.Quoter.ShouldInlineType(System.Type)">
      <summary>
            Whether constants of this type should be inlined as literals, rather that
            put in a single place.
            </summary>
      <param name="tp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.SourceNode">
      <summary>
            This class is used by a language writer to build a tree of source fragments
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.SourceNode.StartString">
      <summary>
            The start string for the code element
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.SourceNode.EndString">
      <summary>
            The end string for the code element
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.SourceNode.ASTElement">
      <summary>
            The element in the abstract syntax tree corresponding to this source fragment
            </summary>
    </member>
    <member name="F:MicrosoftResearch.Transforms.SourceNode.Children">
      <summary>
            Children nodes
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.SourceNode.Clear">
      <summary>
            Clear the node
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.SourceNode.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:MicrosoftResearch.Transforms.SourceNode.#ctor(System.String)">
      <summary>
            Construct from start string
            </summary>
      <param name="start">
      </param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.SourceNode.#ctor(System.String,System.String,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="start">start string</param>
      <param name="end">end string</param>
      <param name="element">element</param>
    </member>
    <member name="M:MicrosoftResearch.Transforms.SourceNode.ToString(MicrosoftResearch.Transforms.ILanguageWriter)">
      <summary>
            Display the source node as a string in a given language
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:MicrosoftResearch.Transforms.TransformerChain">
      <summary>
            A chain of transformers, used to apply a series of transforms.
            </summary>
    </member>
    <member name="T:MicrosoftResearch.Transforms.TransformResults">
      <summary>
            Describes the results of a transformation, including errors and warnings encountered.
            </summary>
    </member>
  </members>
</doc>