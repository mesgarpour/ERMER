<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Infer.Runtime</name>
    </assembly>
    <members>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayDictionary`1">
            <summary>
            Represents a dictionary with non-negative integers as keys.
            </summary>
            <remarks>
            This structure is efficient when the keys are zero-based and consecutive,
            since the dictionary is represented by an array under the hood.
            </remarks>
            <typeparam name="T">The type of a value.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.keyToValue">
            <summary>
            An array of values, indexed by key.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.keyPresent">
            <summary>
            An array of flags indicating whether the corresponding key is present in the dictionary.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.ArrayDictionary`1"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.ArrayDictionary`1"/> class with a given capacity.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Gets the value associated with a given key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">
            When this method returns, contains the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter.
            </param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.Add(System.Int32,`0)">
            <summary>
            Adds a given key and value to the dictionary.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.ContainsKey(System.Int32)">
            <summary>
            Determines whether the dictionary contains a given key.
            </summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the dictionary in ascending key order.
            </summary>
            <returns>An enumerator for the dictionary.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the dictionary in ascending key order.
            </summary>
            <returns>An enumerator for the dictionary.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.DoAdd(System.Int32,`0,System.Boolean)">
            <summary>
            Adds a given key and value to the dictionary.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
            <param name="throwIfKeyPresent">Specifies whether the method should throw if the key is already present in the dictionary.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ArrayDictionary`1.Item(System.Int32)">
            <summary>
            Gets or sets the value associated with a given key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value associated with the specified key.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FileArray`1">
            <summary>
            An IArray where each element is stored as a disk file.
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks><para>
            The elements (whose values do not equal default(T)) are stored as individual files in a temp folder.
            Elements equal to default(T) are not stored.
            A FileArray may contain FileArrays as elements: these are called child FileArrays.
            Child FileArrays must be created using the special constructor.
            When a FileArray (that is not a child) is Disposed or garbage collected, the folder is deleted.
            A child FileArray is deleted only when its parent is deleted.
            Thus if the program exits normally, all temp folders should be deleted.
            However, if the program halts with an exception, temp folders will not be deleted and must be cleaned up manually.
            </para><para>
            Be careful when modifying elements of the FileArray in place.  If fa is a FileArray, then the syntax
            <code>fa[i][j] = 0;</code> or <code>fa[i].property = 0;</code> will not have any effect.  This happens
            because <code>fa[i]</code> reads the element from disk but does not write it back again.  You must explicitly
            read the element, modify it, then write it back like so: <code>T item = fa[i];  item.property=0;  fa[i] = item;</code>
            </para>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IArray`1">
            <summary>
            Interface to an array of arbitrary rank.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IArray`1.GetLength(System.Int32)">
            <summary>
            Get the size of a specified dimension of a multidimensional array.
            </summary>
            <param name="dimension">Zero-based dimension of the array.</param>
            <returns>The size of the specified dimension of the array.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray`1.Rank">
            <summary>
            Get the number of dimensions of the array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FileArray`1.#ctor(System.String,System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a file array
            </summary>
            <param name="folder">Temporary folder for storing data.  Will be deleted when the FileArray is disposed.</param>
            <param name="count"></param>
            <param name="func"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FileStats">
            <summary>
            Stores global counters for monitoring FileArrays
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncExtensions">
            <summary>
            Provides extension methods for Func that support collection and sparse collections
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Maps one enumerable sequence to another. Supports sparse representations.
            </summary>
            <typeparam name="T">Source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">The source sequence</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``3(System.Func{``0,``1,``2},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Maps two enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``4(System.Func{``0,``1,``2,``3},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Maps three enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <param name="c">Second source sequence</param>
            <returns></returns>		
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``5(System.Func{``0,``1,``2,``3,``4},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>
            Maps four enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="T4">Fourth source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Third source sequence</param>
            <param name="c">Fourth source sequence</param>
            <param name="d">Fifth source sequence</param>
            <returns></returns>		
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``6(System.Func{``0,``1,``2,``3,``4,``5},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4})">
            <summary>
            Maps four enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="T4">Fourth source sequence element type</typeparam>
            <typeparam name="T5">Fifth source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <param name="c">Third source sequence</param>
            <param name="d">Fourth source sequence</param>
            <param name="e">Fifth source sequence</param>
            <returns></returns>		
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2">
            <summary>
            Sparse iterator class for a function of one sparse collection
            </summary>
            <typeparam name="T">Type of source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1">
            <summary>
            Iterator base class for sparse enumeration
            </summary>
            <typeparam name="TRes"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1">
            <summary>
            Contract for sparse enumeration
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CurrentIndex">
            <summary>
            Current index. If past end of list, current index shows count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CommonValueCount">
            <summary>
            Current common value count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CommonValue">
            <summary>
            The common value for the sparse enumeration
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CurrentIndex">
            <summary>
            Returns the index of the current sparse element
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CommonValueCount">
            <summary>
            Returns the count of common values up to this point. Once <see cref="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.MoveNext"/> returns
            false, this property gives the total common value count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CommonValue">
            <summary>
            Gets the common value for this sparse collection
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The enumerator is
            positioned before the first or after the last element of the collection.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3">
            <summary>
            Sparse iterator class for a function of two sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4">
            <summary>
            Sparse iterator class for a function of three sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5">
            <summary>
            Sparse iterator class for a function of four sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="T4">Type of fourth source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6">
            <summary>
            Sparse iterator class for a function of four sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="T4">Type of fourth source collection</typeparam>
            <typeparam name="T5">Type of fifth source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`2">
            <summary>
            Enumerable generated as a function of the elements of another enumerable
            </summary>
            <typeparam name="T">Type for source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`3">
            <summary>
            Enumerable generated as a function of the elements of two other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.#ctor(System.Func{`0,`1,`2},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Creates a new enumerator for a function of two variables to act on two collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`4">
            <summary>
            Enumerable generated as a function of the elements of three other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.#ctor(System.Func{`0,`1,`2,`3},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`5">
            <summary>
            Enumerable generated as a function of the elements of four other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.#ctor(System.Func{`0,`1,`2,`3,`4},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
             <param name="d">The fourth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`6">
            <summary>
            Enumerable generated as a function of the elements of five other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
             <typeparam name="T5">Type for fifth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
            <param name="e">The fifth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2">
            <summary>
            Sparse enumerable generated as a function of the elements of another sparse enumerable
            </summary>
            <typeparam name="T">Type for source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseEnumerable`1">
            <summary>
            Sparsely enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ISparseEnumerable`1.GetSparseEnumerator">
            <summary>
            Returns a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2.#ctor(System.Func{`0,`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a sparse collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3">
            <summary>
            Sparse enumerable generated as a function of the elements of two other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3.#ctor(System.Func{`0,`1,`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1})">
            <summary>
            Creates a new enumerator for a function of two variables to act on two sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4">
            <summary>
            Sparse enumerable generated as a function of the elements of three other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4.#ctor(System.Func{`0,`1,`2,`3},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5">
            <summary>
            Sparse enumerable generated as a function of the elements of four other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5.#ctor(System.Func{`0,`1,`2,`3,`4},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`3})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6">
            <summary>
            Sparse enumerable generated as a function of the elements of four other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="T5">Type for fifth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`3},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`4})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
            <param name="e">The fifth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IEnumerableExensions">
            <summary>
            Provides extension methods for IEnumerable that support sparse collections.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IEnumerableExensions.EnumerableReduce``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``0,System.Int32,``1})">
            <summary>
            Reduces across an enumerable, supporting sparse enumerables
            </summary>
            <typeparam name="T">Type of this collection</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This collection</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>		
            <param name="repeatedFun">The function when the same value enters the reduction several times.</param>		
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IListExtensions">
            <summary>
            Provides extension methods for IList that support sparse lists.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.IsSparse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns true if and only if this list is sparse
            </summary>
            <typeparam name="T">The type of this list</typeparam>
            <param name="source">The list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSelect``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Similar to LINQ Select, except it takes and returns a list.
            If the supplied list is sparse, the returned list will also be sparse.
            </summary>
            <typeparam name="T">The type of this list</typeparam>
            <typeparam name="T2">The target element type</typeparam>
            <param name="source">This list</param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSum(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Sums the elements of this list.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSum(System.Collections.Generic.IList{System.Int32},System.Func{System.Int32,System.Double})">
            <summary>
            Sums the elements of this list, after transforming each element using the specified converter.
            </summary>
            <param name="source"></param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.Inner(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Double})">
            <summary>
            Computes the inner product between an integer list and a double list of the same size.
            </summary>
            <param name="source"></param>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListReduce``2(System.Collections.Generic.IList{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Reduces across a list.
            </summary>
            <typeparam name="T">Type of this list</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This list</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>		/// <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListReduce``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``1},``2,System.Func{``2,``0,``1,``2})">
            <summary>
            Reduces across a list and another collection
            </summary>
            <typeparam name="T">Type of this list</typeparam>
            <typeparam name="T2">Type of the other list</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This list</param>
            <param name="secondList">The other collection</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ToVector(System.Collections.Generic.IList{System.Double})">
            <summary>
            Converts a list of doubles into a vector.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ToVector(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Converts a list of ints into a double vector.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.SetTo``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sets this list from an enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.SetTo(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Sets this list from an enumerable (need separate implementation from
            generic version for interop with Vectors)
            </summary>
            <param name="source"></param>
            <param name="that"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray">
            <summary>
            Class that provides useful static methods for jagged arrays
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType(System.Type)">
            <summary>
            Gets the innermost non-array type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType``1">
            <summary>
            Gets the innermost non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type,System.Type)">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``2">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            over the specified leaf type
            </summary>
            <typeparam name="JaggedType">The jagged array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type)">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``1">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type,System.Type)">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <param name="jaggedType"></param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``2">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagge array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type)">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <param name="jaggedType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``1">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type)">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type)">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type,System.Type)">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <param name="targetLeafType">Desired leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``2">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``1">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``3">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <typeparam name="TargetLeafType">Target leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable,System.Type)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator``1(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <typeparam name="LeafType">Leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaftype.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="sourceLeafType">The leaf type of the source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew``2(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter{``0,``1})">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <typeparam name="SourceLeafType">Leaf type of the source jagged array</typeparam>
            <typeparam name="TargetLeafType">Leaf type of the target jagged array</typeparam>
            <param name="sourceArray">The source array</param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="leafType">The leaf type of the jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="leafType">The leaf type of the target array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements with the specified leaf type, and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="leafType">Element type</param>
            <param name="action">Action delegate</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="action">Action delegate</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)">
            <summary>
            Visits all elements oftwo jagged arrays, and perform the action
            </summary>
            <param name="jaggedArray1">First jagged array</param>
            <param name="jaggedArray2">Second jagged array</param>
            <param name="leafType1">Leaf type of first jagged array element</param>
            <param name="leafType2">Leaf type of second jagged array element</param>
            <param name="action">The action to take</param>
            <remarks>There is no checking of compatibility between the two jagged arrays</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)">
            <summary>
            Visits all elements oftwo jagged arrays, and perform the action
            </summary>
            <param name="jaggedArray1">First jagged array</param>
            <param name="jaggedArray2">Second jagged array</param>
            <param name="action">The action to take</param>
            <remarks>There is no checking of compatibility between the two jagged arrays</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter`2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <typeparam name="SourceLeafType">Type of leaf elements in source array</typeparam>
            <typeparam name="TargetLeafType">Type of leaf elements in target array</typeparam>
            <param name="elt"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction">
            <summary>
            Delegate for jagged array element visitor
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2">
            <summary>
            Delegate for generic jagged array element visitor
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayFromFunc`1">
            <summary>
            A virtual read-only 1D array whose elements are provided by a function.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayFromFunc2D`1">
            <summary>
            A virtual read-only 2D array whose elements are provided by a function.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IArray2D`1">
            <summary>
            Interface to a two-dimensional array.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or set an element of a two-dimensional array.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.KeyedPool`2">
            <summary>
            A pool of items that can be registered against a given key.
            </summary>
            <typeparam name="TKey">The type of a key.</typeparam>
            <typeparam name="TItem">The type of an item.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.KeyedPool`2.storage">
            <summary>
            A mapping from a key to a list of items registered against that key.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.KeyedPool`2.itemFactory">
            <summary>
            A factory for producing new items.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.KeyedPool`2.#ctor(System.Func{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.KeyedPool`2"/> class.
            </summary>
            <param name="itemFactory">A factory for producing new items.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.KeyedPool`2.Acquire(`0)">
            <summary>
            Returns an item registered against a given key. If there are no items registered against that key,
            returns an item registered against any key. If there are no registered items at all,
            returns a new one.
            </summary>
            <param name="desiredKey">The desired key.</param>
            <returns>An item.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.KeyedPool`2.Release(`1,`0)">
            <summary>
            Returns a given item to the pool and registers it against a provided key.
            </summary>
            <param name="item">The item.</param>
            <param name="key">The key to register the item against.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.KeyedPool`2.ExtractItem(`0,System.Collections.Generic.LinkedList{`1})">
            <summary>
            Extracts an item from the list of items registered against a given key.
            </summary>
            <param name="key">The key.</param>
            <param name="items">The list of items registered against <paramref name="key"/>.</param>
            <returns>The extracted item.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IndexedSet`1">
            <summary>
            A bidirectional mapping of unique elements to non-negative indexes.
            </summary>
            <typeparam name="T">The type of an element.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.IndexedSet`1.elementToIndex">
            <summary>
            A mapping from an element to its index.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.IndexedSet`1.indexToElement">
            <summary>
            A mapping from an index to its element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.IndexedSet`1"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.IndexedSet`1"/> class.
            </summary>
            <param name="elements">A collection of elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.Add(`0,System.Boolean)">
            <summary>
            Adds a new element to the indexed set.
            </summary>
            <param name="element">The element to add.</param>
            <param name="throwIfPresent">
            If true, an exception is throw when adding an element that is already present in the indexed set. Defaults to true.
            </param>
            <returns>The index of the added element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.GetElementByIndex(System.Int32)">
            <summary>
            Gets an element for a specified index.
            </summary>
            <param name="index">The index to get the element for.</param>
            <returns>The element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.TryGetIndex(`0,System.Int32@)">
            <summary>
            Gets the index for a specified element.
            </summary>
            <param name="element">The element to get the index for.</param>
            <param name="index">The index for the specified element, if present in the set.</param>
            <returns>True if <paramref name="element"/> is present in the indexed set and false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.Contains(`0)">
            <summary>
            Returns true if the specified element is contained in the indexed set and false otherwise.
            </summary>
            <param name="element">The element.</param>
            <returns>True if the specified element is contained in the indexed set and false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IndexedSet`1.Clear">
            <summary>
            Removes all elements from the indexed set.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IndexedSet`1.Count">
            <summary>
            Gets the number of elements in the indexed set.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IndexedSet`1.Elements">
            <summary>
            Gets all elements in the indexed set.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IndexedSet`1.Indexes">
            <summary>
            Gets the indexes of all elements in the indexed set.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseList`1">
            <summary>
            A list which is optimised for the case where most of its elements share a common value.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseList`1">
            <summary>
            Exposes sparse lists. Inherits from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.FromSize(System.Int32)">
            <summary>
            Create a sparse list of given length with elements all equal
            to the default value for the element type
            </summary>
            <param name="count">Number of elements in the list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Constant(System.Int32,`0)">
            <summary>
            Create a sparse list of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="value">Value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Copy(System.Collections.Generic.IList{`0})">
            <summary>
            Creator a sparse list as a copy of another list (which may not be sparse)
            </summary>
            <param name="that">The source list - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}})">
            <summary>
            Constructs a sparse list from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor">
            <summary>
            Null constructor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32)">
            <summary>
            Constructs a sparse list with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32,`0)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}})">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(MicrosoftResearch.Infer.Collections.ISparseList{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetSparseIndex(System.Int32)">
            <summary>
            Gets the index into the sparse values array corresponding to an element index.
            If there is no sparse value at that index, returns the binary complement of the 
            index in the sparse array where such an element should be inserted to retain the
            sort order of the sparse array.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the list elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the list elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetAllElementsTo(`0)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(System.Collections.Generic.IList{`0})">
            <summary>
            Copies values from another list.
            </summary>
            <param name="that"></param>
            <remarks> The source list can be dense, in which case 
            default(T) is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.CheckCompatible``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Checks that a given list is the same size as this list.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The list to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(MicrosoftResearch.Infer.Collections.SparseList{`0})">
            <summary>
            Copies values from a sparse list to this sparse list.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(System.Collections.Generic.IList{`0},`0)">
            <summary>
            Copies values from a list which must have the same size as this list,
            using the specified common value.
            </summary>
            <param name="dlist">The list to copy from</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Clone">
            <summary>
            Clones this list - return as a sparse list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#ICloneable#Clone">
            <summary>
            Clones this list - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (list) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.EqualsAll(`0)">
            <summary>
            Tests if all elements are equal to the given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.All(System.Converter{`0,System.Boolean})">
            <summary>
            Tests if all elements in the list satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Any(System.Converter{`0,System.Boolean})">
            <summary>
            Tests if any elements in the list satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.IndexOfAll(System.Converter{`0,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``1(``0,System.Func{``0,`0,``0})">
            <summary>
            Reduce method. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``1(``0,System.Func{``0,`0,``0},System.Func{``0,`0,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``2(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,`0,``1,``0},System.Func{``0,`0,``1,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and another sparse list
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">The other sparse list</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``3(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,`0,``1,``2,``0},System.Func{``0,`0,``1,``2,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and two other sparse lists
            </summary>
            <param name="initial">Initial value</param>
            <param name="b">A second sparse list</param>
            <param name="c">A third sparse list</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``0,`0,``1,``0})">
            <summary>
            Reduce method. Operates on this list and another list.
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second list</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``3(``0,System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2},System.Func{``0,`0,``1,``2,``0})">
            <summary>
            Reduce method. Operates on this list and two other lists.
            </summary>
            <param name="initial">Initial value</param>
            <param name="a">A second list</param>
            <param name="b">A third list</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="a"/> and <paramref name="b"/></param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Contains(`0)">
            <summary>
            Returns true if this list contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.IndexOf(`0)">
            <summary>
            Returns the index of the first occurence of the given value in the list.
            Returns -1 if the value is not in the list
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the list</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies this sparse list to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Insert(System.Int32,`0)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.RemoveAt(System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Add(`0)">
            <summary>
            Not implemented
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Clear">
            <summary>
            Clears this list, setting it to zero length.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Remove(`0)">
            <summary>
            Not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an array from the list
            </summary>
            <typeparam name="T2"></typeparam>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of another sparse list
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a sparse collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.SparseList{``0},MicrosoftResearch.Infer.Collections.SparseList{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are all the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this list to a function of the elements of two collections
            </summary>
            <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``3(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``4(MicrosoftResearch.Infer.Collections.ISparseList{``0},MicrosoftResearch.Infer.Collections.ISparseList{``1},MicrosoftResearch.Infer.Collections.ISparseList{``2},MicrosoftResearch.Infer.Collections.ISparseList{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three other collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of four sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunctionInPlace``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{`0,``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of this sparse list and another sparse list
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps (T,T1) to T</param>
            <param name="b">The other sparse list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToString">
            <summary>
            Converts this sparse list into a human readable string
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToString(System.String)">
            <summary>
            String representation of this list with a specified delimiter
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToArray">
            <summary>
            Converts this sparse list to an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToList">
            <summary>
            Converts this sparse list to an ordinary non-sparse list
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetSparseEnumerator">
            <summary>
            Gets a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Sparsity">
            <summary>
            The <see cref="P:MicrosoftResearch.Infer.Collections.SparseList`1.Sparsity"/> specification of this list.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.SparseValues">
            <summary>
            A list of the value and indices of elements which may not have the common value 
            (although they are not precluded from doing so).
            This list is kept sorted by index to allow efficient operations on the sparse list.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.CommonValue">
            <summary>
            The value of all elements not mentioned explicitly as sparse values.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Count">
            <summary>
            Get or set the number of elements in this list.  Set the number of elements
            will grow or shrink the list accordingly.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.SparseCount">
            <summary>
            The number of elements not equal to the common value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Item(System.Int32)">
            <summary>Gets or sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.HasCommonElements">
            <summary>
            Returns true if there is at least one element which has the common value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.IsReadOnly">
            <summary>
            Sparse lists are not read only.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1">
            <summary>
            Approximate Sparse List.
            </summary>
            <typeparam name="T">List element type. Must implement <see cref="T:MicrosoftResearch.Infer.Maths.Diffable"/>.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.DefaultTolerance">
            <summary>
            The default tolerance for the approximate sparse list
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.FromSize(System.Int32,System.Double)">
            <summary>
            Create a sparse list of given length with elements all equal
            to the default value for the element type
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Constant(System.Int32,`0,System.Double)">
            <summary>
            Create a sparse list of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="value">Value for each element</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}},System.Double)">
            <summary>
            Constructs a sparse list from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor">
            <summary>
            Null constructor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32)">
            <summary>
            Constructs an approximate sparse list with the given number of elements
            and with default tolerance.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            The tolerance is set to the default value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}})">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            The tolerance is set to the default value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(MicrosoftResearch.Infer.Collections.ISparseList{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Double)">
            <summary>
            Constructs an approximate sparse list with the given tolerance
            </summary>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs an approximate sparse list with the given number of elements
            and with the given tolerance.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Double)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}},System.Double)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(MicrosoftResearch.Infer.Collections.ISparseList{`0},System.Double)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetTo(MicrosoftResearch.Infer.Collections.ApproximateSparseList{`0})">
            <summary>
            Copies values from a sparse list to this sparse list.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetTo(System.Collections.Generic.IList{`0},`0)">
            <summary>
            Copies values from a list which must have the same size as this list,
            using the specified common value.
            </summary>
            <param name="dlist">The list to copy from</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Clone">
            <summary>
            Clones this list - return as a sparse list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of another sparse list
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a sparse collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.SparseList{``0},MicrosoftResearch.Infer.Collections.SparseList{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this approximate sparse list to a function of the elements of
            two other sparse lists
            </summary>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are all the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this list to a function of the elements of two collections
            </summary>
            <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``3(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``4(MicrosoftResearch.Infer.Collections.ISparseList{``0},MicrosoftResearch.Infer.Collections.ISparseList{``1},MicrosoftResearch.Infer.Collections.ISparseList{``2},MicrosoftResearch.Infer.Collections.ISparseList{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three other collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of four sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunctionInPlace``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{`0,``0,`0})">
            <summary>
            Sets the elements of this approximate sparse list to a function of the elements
            of this sparse list and another sparse list x = fun(x,b)
            </summary>
            <param name="fun">The function which maps (T,T1) to T</param>
            <param name="b">The other sparse list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Tolerance">
            <summary>
            The tolerance for the approximation
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Item(System.Int32)">
            <summary>Gets or sets an element.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1">
            <summary>
            Iterator class for sparse lists
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.#ctor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}},System.Int32,`0)">
            <summary>
            Constructs a sparse enumerator instance for a sparse list
            </summary>
            <param name="sparseList"></param>
            <param name="totalCount"></param>
            <param name="commonValue"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ValueAtIndex`1">
            <summary>
            Stores a value and its index in the collection.
            </summary>
            <typeparam name="T">The type of the stored value.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.ValueAtIndex`1.NoElement">
            <summary>
            Represents value missing from a collection.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ValueAtIndex`1.#ctor(System.Int32,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Collections.ValueAtIndex`1"/> struct.
            </summary>
            <param name="index">The value of the collection element.</param>
            <param name="value">The index of the collection element.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ValueAtIndex`1.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <returns>The string representation of the value of this instance.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ValueAtIndex`1.Index">
            <summary>
            Gets or sets the index of the element.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ValueAtIndex`1.Value">
            <summary>
            Gets or sets the value of the element.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.FunctionEval">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="x">Independent value</param>
            <param name="dX">If reference is not null, calculate the deriv here</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.IterationEventHandler">
            <summary>
            Event delegate for handling iteration event
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs">
            <summary>
            Optimiser iteration event
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="iteration"></param>
            <param name="objVal"></param>
            <param name="rmsDeriv"></param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.iteration">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.objVal">
            <summary>
            Objective value
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.rmsDeriv">
            <summary>
            Root mean square derivative
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.DerivativeChecker">
            <summary>
            Class used to check analytic derivatives using finite difference approximation
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DerivativeChecker.CheckDerivatives(MicrosoftResearch.Infer.Maths.FunctionEval,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Check whether "func" correctly calculates derivatives
            </summary>
            <param name="func">Return the objective and calculates gradients</param>
            <param name="x0">The point to perform the check around</param>
            <returns>Whether the derivatives are correctly calculated. </returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.BFGS">
            <summary>
            This implementation of BFGS is based on Algorithm 6.1 from
            Nocedal and Wright (Second edition, 2006).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.dimension">
            <summary>
            Following fields are set up by the main run
            routine, and are used to provide the 1-D function that
            the line search needs
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.debug">
            <summary>
            Whether to output debug info
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.convergenceCriteria">
            <summary>
             Convergence criteria:
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.#ctor">
            <summary>
            BFGS constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.SetWolfeConstants(System.Double,System.Double)">
            <summary>
            Set Wolfe conditions
            </summary>
            <param name="c1">Sufficient decrease condition</param>
            <param name="c2">Curvature condition</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.LSEval(System.Double,System.Boolean,System.Double@)">
            <summary>
            This is the 1-D function that the line search sees.
            The Run function will set up the necessary fields
            </summary>
            <param name="step">step</param>
            <param name="calcDeriv">flag to calculate derivative</param>
            <param name="deriv">the derivative</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.TryLineSearch(System.Double,System.Double,System.Double)">
            <summary>
            Line search
            </summary>
            <param name="s0">Initial step</param>
            <param name="smax">Maximum step</param>
            <param name="currentGrad"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.Run(MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.FunctionEval)">
            <summary>
            Run an unconstrained minimization using BFGS
            </summary>
            <param name="x0">Starting step</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.RaiseIterationEvent(System.Int32,System.Double,System.Double)">
            <summary>
            Safely invoke the iteration event
            </summary>
            <param name="iteration"></param>
            <param name="objVal"></param>
            <param name="rmsDeriv"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.linesearchDebug">
            <summary>
            Whether to debug the line search
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.IterationsPerformed">
            <summary>
             Number of iterations performed to reach convergence (or failure)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.Epsilon">
            <summary>
            Convergence tolerance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.MaximumStep">
            <summary>
            Maximum step
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.InitialStep">
            <summary>
            Initial step
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.MaximumIterations">
            <summary>
            Maximum number of iterations
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.Cancel">
            <summary>
            Cancel
            </summary>
        </member>
        <member name="E:MicrosoftResearch.Infer.Maths.BFGS.OnIteration">
            <summary>
            Event triggered at each iteration
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria">
            <summary>
             Convergence criteria:
            - Gradient: |grad F|/sqrt(dimensions) &lt;= eps
            - Objective: |F(k+1)-F(k)|&lt;=eps*max{|F(k)|,|F(k+1)|,1}
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria.Gradient">
            <summary>
            |grad F|/sqrt(dimensions) &lt;= eps
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria.Objective">
            <summary>
            |F(k+1)-F(k)|&lt;=eps*max{|F(k)|,|F(k+1)|,1}
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.ContinuedFraction">
            <summary>
            A class for evaluating continued fractions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ContinuedFraction.GetNumerator(System.Int32)">
            <summary>
            Gets the numerator for the current term.
            </summary>
            <param name="n">The iteration - must be greater than 0.</param>
            <returns>The numerator for the current term.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ContinuedFraction.GetDenominator(System.Int32)">
            <summary>
            Gets the denominator for the current term.
            </summary>
            <param name="n">The iteration - must be greater than 0.</param>
            <returns>The denominator for the current term.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ContinuedFraction.Evaluate(System.Double)">
            <summary>
            Evaluates the continued fraction.
            </summary>
            <param name="epsilon">The convergence tolerance.</param>
            <returns>The value of the fraction</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PiecewiseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many contiguous ranges
            of elements have the same value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Vector">
            <summary>
            Base class for vectors. <see cref="T:MicrosoftResearch.Infer.Maths.DenseVector"/>, <see cref="T:MicrosoftResearch.Infer.Maths.SparseVector"/>, and <see cref="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector"/>
            all inherit from this base class.
            </summary>
            <remarks>This class includes factory methods for instantiating Vectors of different <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/>
            specifications. Beyond this initial construction, application code does not need to know the
            the sparsity, and most operations can be done via this general base class which will handle sparsity correctly.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableTo`1">
            <summary>
            Supports setting an instance to a value
            </summary>
            <typeparam name="T">The type of value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableTo`1.SetTo(`0)">
            <summary>
            Set the instance to have the same value as given
            </summary>
            <param name="value">The value to set to</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.CanSetAllElementsTo`1">
            <summary>
            Supports setting all elements to duplicates of the same value
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.CanSetAllElementsTo`1.SetAllElementsTo(`0)">
            <summary>
            Set all elements to duplicates of the given value
            </summary>
            <param name="value">The value to set to</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToPower`1">
            <summary>
            Supports setting an instance to a value raised to a power
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToPower`1.SetToPower(`0,System.Double)">
            <summary>
            Set this to the given value raised to the given power
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`1">
            <summary>
            Supports setting an instance to the product of two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`2">
            <summary>
            Supports setting an instance to the product of
            two values of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToProduct`2.SetToProduct(`0,`1)">
            <summary>
            Set this to the product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1">
            <summary>
            Supports setting an instance to the weighted sum of
            two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1.SetToSum(System.Double,`0,System.Double,`0)">
            <summary>
            Set the parameters to best match a mixture distribution.
            </summary>
            <param name="weight1">A finite nonnegative weight.</param>
            <param name="weight2">A finite nonnegative weight.</param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Zero(System.Int32)">
            <summary>
            Creates a dense vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Zero(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Constant(System.Int32,System.Double)">
            <summary>
            Create a dense vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Constant(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Create a vector of given length with elements all equal to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a vector as a copy of another vector.
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
            <remarks>Sparsity of created vector matches that of source vector</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Copy(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Create a vector as a copy of another vector with a given target sparsity
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[])">
            <summary>
            Constructs a dense vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[],MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromList(System.Collections.Generic.IList{System.Double})">
            <summary>
            Constructs a vector from a list. Maintains sparsity. 
            </summary>
            <param name="list">List to create vector from.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Int32,System.Double[],System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified item value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CheckCompatible(MicrosoftResearch.Infer.Maths.Vector,System.String)">
            <summary>
            Checks that a given vector is the same size as this vector.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The vector to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Any(MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Boolean})">
            <summary>
            Test if any corresponding elements in this and that vector satisfy a condition
            </summary>
            <param name="that"></param>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration over the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun">A function to check if the condition is satisfied.</param>
            <returns>An enumeration over the indices of all elements which satisfy the specified condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FindAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration over the indices and values of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun">A function to check if the condition is satisfied.</param>
            <returns>An enumeration over the indices and values of all elements which satisfy the specified condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CountAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the number of elements in the vector which satisfy a given condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>The number of elements in the vector which satisfy the condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToArray">
            <summary>
            Converts this vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SumI">
            <summary>
            Returns the sum of over zero-based index * element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of a function of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Median">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="that">The given vector</param>
            <param name="fun">The function which maps doubles to doubles</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <param name="fun">The function which maps two doubles to a double</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToPower(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise product of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise sum of two other vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to another vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the difference of two vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Set this vector to another vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a constant minus another vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to a vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the product of a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to the product of a matrix by a vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise ratio of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Multiplies every element of a vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiply every element of this vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_ExclusiveOr(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns a vector to some power.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with this[i] = Math.Pow(a[i],b).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the elementwise product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a scalar to every element of a vector.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A vector with the sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the sum of two vectors.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the difference of two vectors
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a vector which is the unary negation of a vector.
            </summary>
            <param name="a">The vector to negate.</param>
            <returns>The negation of a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Division(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the ratio of two vectors
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>The inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Equality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if the vectors have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Inequality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if vectors are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (DenseVector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThan(System.Double)">
            <summary>
            Tests if all elements are strictly greater than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly greater than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThan(System.Double)">
            <summary>
            Tests if all elements are strictly less than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly less than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are greater than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are greater than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are less than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThan(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Greater than operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is greater than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThan(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Greater than operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is greater than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThan(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Less than operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is less than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThan(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Less than operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is less than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Greater than or equal to operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is not less than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Greater than or equal to operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is not less than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Less than or equal to operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is not greater than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Less than or equal to operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is not greater than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is an upper triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">An upper triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'x=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A'\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Premultiply this vector by the inverse of a positive definite matrix
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Return a new vector which is the concatenation of this vector and a second vector.
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Concat(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a vector by concatenating two vectors.
            </summary>
            <param name="first">First vector</param>
            <param name="second">Second vector</param>
            <returns>A new vector with all elements of the first vector followed by all elements of the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32,System.Int32)">
            <summary>
            Copy a subvector.
            </summary>
            <param name="source">A vector whose length is at least <c>count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="source"/> to copy.</param>
            <param name="count">The number of elements to copy.</param>
            <returns>A Vector of length <paramref name="count"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this vector
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String)">
            <summary>
            String representation of vector with a specified format for each element
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString">
            <summary>
            Converts this sparse vector into a human readable string
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity">
            <summary>
            The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification of this vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsDense">
            <summary>
            True if this vector is dense
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsSparse">
            <summary>
            True if is this vector is sparse (exact or approximate)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsApproximate">
            <summary>
            True if this vector is approximate (sparse only)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsExact">
            <summary>
            True if this vector is exact (dense or sparse)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsReadOnly">
            <summary>
            Is read only
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Count">
            <summary>
            Number of elements in vector
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Zero(System.Int32)">
            <summary>
            Create a piecewise vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a piecewise vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creator a piecewise vector as a copy of another vector (of any type)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromArray(System.Double[])">
            <summary>
            Constructs a piecewise vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromSubvectors(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Maths.ConstantVector})">
            <summary>
            Constructs a piecewise vector from a sorted list of subvectors, which will
            be used directly and not copied.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedDisjointVectors">Sorted list of disjoint subvectors</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new piecewise vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Maths.ConstantVector})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of vectors. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedVectors">The list of vectors, which must be disjoint and sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a piecewise vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetSubvector(System.Int32)">
            <summary>
            Gets the subvector that contains the specified index, or null if none.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetCommonValueCount">
            <summary>
            Gets the number of elements that don't belong to any subvector
            and so take the common value.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.HasCommonElements">
            <summary>
            Gets whether there are any elements that don't belong to a subvector
            and so take the common value.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ApplyRangeFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,MicrosoftResearch.Infer.Maths.PiecewiseVector.RangeFunc)">
            <summary>
            Applies a function to ranges in common between this vector and another
            and returns the number of elements with common values in both vectors.
            </summary>
            <param name="b"></param>
            <param name="func"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Copies values from a piecewise vector to this piecewise vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToConstantInRange(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the vector to a constant value between the specified
            start and end indices inclusive (and zero elsewhere).
            </summary>
            <param name="start">The start index</param>
            <param name="end">The end index</param>
            <param name="value">The constant value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToConstantInRanges(System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
            <summary>
            Sets the vector to a constant value in multiple ranges (and zero elsewhere).
            The start and end points of the ranges are specified as consecutive pairs
            in a single enumerable which must therefore have even length.
            </summary>
            <param name="startEndPairs">Enumerable containing pairs of start and end values</param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IList{System.Double})">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector.
            The 'common value' is set to the minimum value of the list.
            </summary>
            <param name="dlist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.InsertPiece(MicrosoftResearch.Infer.Maths.ConstantVector,System.Int32)">
            <summary>
            Inserts a piece into the pieces list, merging it with
            the preceding piece if they are adjacent and have the same value.
            </summary>
            <remarks>
            The calling code must ensure that 'index' is set to ensure
            that 'pieces' remains in the correct sorted order.
            This code just handles any merging necessary.
            </remarks>
            <param name="sub">The piece to insert</param>
            <param name="index">The index to insert at</param>
            <returns>The index of the piece added or merged</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (vector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>True if all elements satisfy the condition, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>True if any elements satisfy the condition, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FindAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration over the indices and values of all the elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun">A function to check if the condition is satisfied.</param>
            <returns>An enumeration over the indices and values of all the elements which satisfy the specified condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.CountAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the number of elements in the vector which satisfy a given condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>The number of elements in the vector which satisfy the condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce``1(``0,System.Func{``0,System.Double,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of piecewise structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this piecewise vector filtered by a function of a second piecewise vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Returns the inner product of this piecewise vector with another piecewise vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this piecewise vector with a function of a second piecewise vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this piecewise vector with a function of a second piecewise vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of another piecewise vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of two other piecewise vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of this piecewise vector and another piecewise vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String)">
            <summary>
            String representation of vector with a specified format for each element
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToArray">
            <summary>
            Converts this piecewise vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToVector">
            <summary>
            Converts this piecewise vector to an ordinary dense vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies values from a vector. If the source vector is piecewise, then the common value
            is set to the common value from the source vector. If the source vector
            is dense, then the common value is set to the minimum of the data in the source vector
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Int32)">
            <summary>
            Copies values from a piecewise vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this piecewise vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a PiecewiseVector from XML.
            </summary>
            <param name="reader"></param>
            <returns>PiecewiseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Write to XML.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Pieces">
            <summary>
            A list of the pieces of this vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.CommonValue">
            <summary>
            The value of all elements which are not in any of the vector pieces.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PiecewiseVector.RangeFunc">
            <summary>
            An action that takes a range and two values.
            </summary>
            <param name="start">The start of the range</param>
            <param name="end">The end of the range</param>
            <param name="value1">The first value</param>
            <param name="value2">The second value</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.ConstantVector">
            <summary>
            A vector which has a constant value between its start and end indices.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.Contains(System.Int32)">
            <summary>
            True if the index lies inside this vector.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.ToString">
            <summary>
            String representation of this constant vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.ToString(System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of this constant vector using the supplied value format
            and function for converting ints to strings.
            </summary>
            <param name="format"></param>
            <param name="intToString"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.CompareTo(System.Object)">
            <summary>
            Compares this constant vector to another one.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Start">
            <summary>
            The start index
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.End">
            <summary>
            The end index
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Value">
            <summary>
            The value of the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.DenseVector">
            <summary>
            1-dimensional dense container of double precision data that supports vector operations.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.CreateSourceArray(System.Int32)">
            <summary>
            Point the cursor at a new source array.
            </summary>
            <remarks>
            The source array is allocated to have nRecords * Count positions.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.ReferenceClone">
            <summary>
            Make a new cursor object having the same source array, at the same position.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Start">
            <summary>
            The position of the cursor in its source array.
            </summary>
            <remarks>
            Position is measured in the same units as Count.
            The instance data spans locations <c>Start, ..., Start+Count-1</c> in 
            the source array.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Count">
            <summary>
            The number of positions in the source array that one instance consumes.
            </summary>
            <remarks>
            The cursor can be advanced to the next instance via
            <c>Start = Start + Count</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a DenseVector from XML of the form <example>&lt;DenseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/DenseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>DenseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;DenseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/DenseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Zero(System.Int32)">
            <summary>
            Create a dense vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a dense vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a dense vector as a copy of another vector
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArray(System.Double[])">
            <summary>
            Constructs a dense vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArrayReference(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector by referencing an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            The vector will not copy the array but only reference it, 
            so any numerical changes to the array will also apply to the vector.
            If the array grows larger, the extra elements are ignored.
            The array must not shrink or else the vector will become inconsistent.
            </para><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the vector.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified item value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FindAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration over the indices and values of all the elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun">A function to check if the condition is satisfied.</param>
            <returns>An enumeration over the indices and values of all the elements which satisfy the specified condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.CountAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the number of elements in the vector which satisfy a given condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>The number of elements in the vector which satisfy the condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.CreateSourceArray(System.Int32)">
            <summary>
            Creates a source array with a given number of records
            </summary>
            <param name="nRecords"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ReferenceClone">
            <summary>
            Creates a clone of this instance which references the source array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToArray">
            <summary>
            Converts this vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Double[])">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector by referencing an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            The vector will not copy the array but only reference it, 
            so any numerical changes to the array will also apply to the vector.
            If the array grows larger, the extra elements are ignored.
            The array must not shrink or else the vector will become inconsistent.
            </para><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value
            </summary>
            <param name="count"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns a new vector which appends a second dense vector to this dense vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a vector to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Copies values from a dense vector to this dense vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.DenseVector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A dense vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this vector
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of to copy to.</param>
            <param name="that">A dense vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToPower(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToPower(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this dense vector to the elementwise product of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise product of two other dense vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.DenseVector,System.Double,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise sum of two other vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise sum of two other dense vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to another vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this dense vector to another dense vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the difference of two vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the difference of two othe dense vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Set this vector to another vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Set this dense vector to another dense vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a constant minus another vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this dense vector to a constant minus another dense vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to a vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this dense vector to a dense vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the product of a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this dense vector to the product of a dense vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to the product of a matrix by a vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this dense vector to the product of a matrix by a dense vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise ratio of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToRatio(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise ratio of two other dense vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this dense vector and that dense vector
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.DenseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="fun">Reduction function</param>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this dense vector filtered by a function of a second dense vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Median">
            <summary>
            Returns the median of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the inner product of this dense vector with another dense vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this dense vector with a function of a second dense vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this dense vector with a function of a second dense vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Outer(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the outer product of this dense vector with another dense vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (DenseVector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(System.Double)">
            <summary>
            Tests if all elements are strictly greater than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly greater than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(System.Double)">
            <summary>
            Tests if all elements are strictly less than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly less than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is strictly greater than a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is strictly less than a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are greater than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are greater than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are less than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is greater than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is greater than or equal to a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is less than or equal to a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the maximum absolute difference between this dense vector and another dense vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Returns the maximum relative difference between this dense vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is an upper triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">An upper triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'x=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A'\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Premultiply this vector by the inverse of the given positive definite matrix
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.SourceArray">
            <summary>
            Gets/sets source array for the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.IsReadOnly">
            <summary>
            Is read only
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Count">
            <summary>
            Number of elements in vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Start">
            <summary>
            Gets/sets the start index in the source array
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGS">
            <summary>
            Implements the LBFGS compact Quasi-Newton solver. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.#ctor(System.Int32)">
            <summary>
            Limited-memory BFGS constructor
            </summary>
            <param name="approxDim">Approximation dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.Init">
            <summary>
            Clear various arrays
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.Run(MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.FunctionEval)">
            <summary>
            Run an unconstrained minimization using BFGS
            </summary>
            <param name="x0">Starting step</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LBFGS.ApproximationDimension">
            <summary>
            Number of dimesions to use in the approximation to the inverse Hessian. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGSArray">
            <summary>
            Implements the LBFGS compact Quasi-Newton solver on an array of Vectors (which may be sparse)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGSArray.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="approxDim">Rank of the hessian approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGSArray.Run(MicrosoftResearch.Infer.Maths.Vector[],System.Double,MicrosoftResearch.Infer.Maths.LBFGSArray.FunctionEvalArray)">
            <summary>
            Run an unconstrained minimization using LBFGS
            </summary>
            <param name="x0">Starting value</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGSArray.FunctionEvalArray">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="x">Independent value</param>
            <param name="dX">If reference is not null, calculate the deriv here</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LineSearchEval">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="step">Step value</param>
            <param name="calcDeriv">Calculate the derivative</param>
            <param name="deriv">Where to put the derivative</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LineSearch">
            <summary>
            This line search algorithm is algorithm 3.5/3.6 from
            Nocedal and Wright (Second edition, 2006). It provides
            a step length that satisfies the strong Wolfe conditions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.SetWolfeConstants(System.Double,System.Double)">
            <summary>
            Set Wolfe conditions
            </summary>
            <param name="c1">Sufficient decrease condition</param>
            <param name="c2">Curvature condition</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.Zoom(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Zoom in once we have bracketed the desired step length
            </summary>
            <param name="lo">Low point of step interval</param>
            <param name="phiLo">Evaluation at lo</param>
            <param name="dPhiLo">Derivative at lo</param>
            <param name="hi">High point of step interval</param>
            <param name="phiHi">Evaluation at lo</param>
            <param name="dPhiHi">Derivative at lo</param>
            <returns>The best step length</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.Run(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Main execution method for line search
            </summary>
            <param name="initialStep"></param>
            <param name="maxStep"></param>
            <param name="phi0"></param>
            <param name="dPhi0"></param>
            <returns>Step satisfying Wolfe conditions</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.Phi">
            <summary>
            Line search evaluation function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.InterpolationTolerance">
            <summary>
            When performing interpolation this is the minimum
            fraction of the range by which the interpolant
            must be from one of the two end points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.MaximumZoomIterations">
            <summary>
            Maximum number of iterations for the zoom method
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.ExtrapolationMultiplier">
            <summary>
            Multiplier for the extrapolation
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SerializableMatrix">
            <summary>
            Helper class for serializing Matrices.  To serialize a Matrix, first cast it to SerializableMatrix.  After deserializing, cast back to Matrix.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SerializableVector">
            <summary>
            Helper class for serializing Vectors.  To serialize a Vector, first cast it to SerializableVector.  After deserializing, cast back to Vector.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SparseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many of the 
            elements share a common value (which need not be zero).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a SparseVector from XML of the form <example>&lt;SparseVector&gt;&lt;Tolerance%gt;0.1&lt;/Tolerance%gt;&lt;SparseElement&gt;...&lt;/SparseElement&gt;...&lt;/SparseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>SparseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;SparseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/SparseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Zero(System.Int32)">
            <summary>
            Create a sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creator a sparse vector as a copy of another vector (which may not be sparse)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromArray(System.Double[])">
            <summary>
            Constructs a sparse vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromSparseValues(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{System.Double}})">
            <summary>
            Constructs a sparse vector from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new sparse vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense, or if the common values
            for the two vectors are different, then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a sparse vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetSparseIndex(System.Int32)">
            <summary>
            Gets the index into the sparse values array corresponding to an element index.
            If there is no sparse value at that index, returns the binary complement of the 
            index in the sparse array where such an element should be inserted to retain the
            sort order of the sparse array.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetSparseEnumerator">
            <summary>
            Returns a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Copies values from a sparse vector to this sparse vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IList{System.Double})">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector.
            The 'common value' is set to the minimum value of the list.
            </summary>
            <param name="dlist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (vector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Any(MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Boolean})">
            <summary>
            Test if any corresponding elements in this and that vector satisfy a condition
            </summary>
            <param name="that"></param>
            <param name="fun"></param>
            <returns></returns>		
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Any(MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Boolean})">
            <summary>
            Test if any corresponding elements in this and that vector satisfy a condition
            </summary>
            <param name="that"></param>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FindAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration over the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun">A function to check if the condition is satisfied.</param>
            <returns>An enumeration over the indices and values of all the elements which satisfy the specified condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.CountAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the number of elements in the vector which satisfy a given condition.
            </summary>
            <param name="fun">The condition for the elements to satisfy.</param>
            <returns>The number of elements in the vector which satisfy the condition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="fun">Reduction function</param>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``1(``0,System.Func{``0,System.Double,``0},System.Func{``0,System.Double,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``2(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,System.Double,``1,``0},System.Func{``0,System.Double,``1,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and another sparse collection
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">The other sparse collection</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``3(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,System.Double,``1,``2,``0},System.Func{``0,System.Double,``1,``2,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and two other sparse collections
            </summary>
            <param name="initial">Initial value</param>
            <param name="b">A second sparse collection</param>
            <param name="c">A third sparse collection</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this sparse vector filtered by a function of a second sparse vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Median">
            <summary>
            Returns the median of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Returns the inner product of this sparse vector with another sparse vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this sparse vector with a function of a second sparse vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this sparse vector with a function of a second sparse vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Outer(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Returns the outer product of this sparse vector with another sparse vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of another sparse vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of two other sparse vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of this sparse vector and another sparse vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format">Format of each element value</param>
            <param name="delimiter">Delimiter between sparse elements</param>
            <returns>A string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToArray">
            <summary>
            Converts this sparse vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToVector">
            <summary>
            Converts this sparse vector to an ordinary non-sparse vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.AsSparseVector(System.Collections.Generic.IList{System.Double})">
            <summary>
            Converts the supplied list of doubles to a sparse vector, or does nothing
            if it is already a sparse vector.
            </summary>
            <param name="iList"></param>
            <returns>A sparse vector containing the list of doubles</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array. The minimum is used as the common value
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies values from a vector. If the source vector is sparse, then the common value
            is set to the common value from the source vector. If the source vector
            is dense, then the common value is set to the minimum of the data in the source vector
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.SparseVector,System.Int32)">
            <summary>
            Copies values from a sparse vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this sparse vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this sparse vector to another vector. The common value is
            not changed
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.SparseValues">
            <summary>
            A list of the value and indices of elements which may not have the common value 
            (although they are not precluded from doing so).
            This list is kept sorted by index to allow efficient operations on the sparse vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.CommonValue">
            <summary>
            The value of all elements not mentioned explicitly as sparse values.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.SparseCount">
            <summary>
            The number of elements not equal to the common value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.Item(System.Int32)">
            <summary>Gets or sets an element at a given index.</summary>
            <param name="index">The index of an element.</param>
            <returns>The element at a given index.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.HasCommonElements">
            <summary>
            Returns true if there is at least one element which has the common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many of the 
            elements share a common value (which need not be zero) within some tolerance.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a SparseVector from XML of the form <example>&lt;ApproximateSparseVector&gt;&lt;Sparsity%gt;...&lt;/Sparsity%gt;...&lt;/ApproximateSparseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>SparseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.ToXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;ApproximateSparseVector&gt;&lt;Sparsity&gt;...&lt;/Sparsity&gt;...&lt;/ApproximateSparseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Zero(System.Int32)">
            <summary>
            Creates an approximate sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Zero(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates an approximate sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="s">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Constant(System.Int32,System.Double)">
            <summary>
            Creates an approximate sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Constant(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates an approximate sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <param name="s">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates an approximate sparse vector as a copy of another vector (which may not be sparse)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromArray(System.Double[])">
            <summary>
            Constructs a sparse vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromSparseValues(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{System.Double}})">
            <summary>
            Constructs a sparse vector from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="s">Sparsity</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new sparse vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense, or if the common values
            for the two vectors are different, then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a zero vector with the given number of elements and sparsity spec.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="s">Sparsity specification</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="s">Sparsity</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="s">Sparsity</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(MicrosoftResearch.Infer.Maths.ApproximateSparseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a sparse vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(MicrosoftResearch.Infer.Maths.ApproximateSparseVector)">
            <summary>
            Copies values from a sparse vector to this sparse vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Set this vector to a collection
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value up to tolerance
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of another sparse vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunctionInPlace(System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of themselves.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of two other sparse vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of this sparse vector and another sparse vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array. The minimum is used as the common value
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.SparseVector,System.Int32)">
            <summary>
            Copies values from a sparse vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this sparse vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this sparse vector to another vector. The common value is
            not changed
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Tolerance">
            <summary>
            The tolerance at which vector element values are considered equal to the common value.
            </summary>
            <remarks>By default this tolerance is set to 0.000001.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.CountTolerance">
            <summary>
            The maximum allowed count of vector elements not set to the common value.
            </summary>
            <remarks>This is ignored if &lt;= 0 which is the default value.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Item(System.Int32)">
            <summary>Gets or sets an element at a given index.</summary>
            <param name="index">The index of an element.</param>
            <returns>The element at a given index.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayBase`1">
            <summary>
            The base class for arrays of any rank using value equality.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Array`1">
            <summary>
            A one-dimensional array with value equality.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ConvertibleToArray">
            <summary>
            Indicates if the object can convert to and from an array.
            </summary>
            <remarks>
            Possessing this interface implies that the object also has a constructor accepting an array type,
            such that <c>new T(this.ToArray())</c> is equivalent to <c>this.Clone()</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Array2D`1">
            <summary>
            A two-dimensional array with value equality.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayAsList`1">
            <summary>
            Wraps a multidimensional array to look like a linear list.
            </summary>
            <remarks>
            In the MSDN documentation, the Array class claims to implement IList.  In fact, this interface is only supported
            for one-dimensional arrays.  ArrayAsList provides this missing functionality for multidimensional arrays.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Pair`2">
            <summary>
            Represent a pair of elements.
            Should be used instead of <see cref="T:System.Tuple`2"/> when a value type is preferred, e.g. for performance reasons.
            </summary>
            <typeparam name="T1">The type of a first element.</typeparam>
            <typeparam name="T2">The type of a second element.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Pair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Pair`2"/> struct.
            </summary>
            <param name="first">The first element of the pair.</param>
            <param name="second">The second element of the pair.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Pair`2.ToString">
            <summary>
            Gets the string representation of this pair.
            </summary>
            <returns>The string representation of the pair.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Pair`2.First">
            <summary>
            Gets or sets the first element of the pair.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Pair`2.Second">
            <summary>
            Gets or sets the second element of the pair.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Pair">
            <summary>
            Represents a pair of elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Pair.Create``2(``0,``1)">
            <summary>
            Creates a pair of elements.
            </summary>
            <param name="first">The first element of the pair.</param>
            <param name="second">The second element of the pair.</param>
            <typeparam name="T1">The type of the first element of the pair.</typeparam>
            <typeparam name="T2">The type of the second element of the pair.</typeparam>
            <returns>The created pair.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.ProgressChangedEventArgs">
            <summary>
            Provides information about the progress of the inference algorithm, as it
            is being executed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.ProgressChangedEventArgs.#ctor(System.Int32)">
            <summary>
            Create a ProgressChangedEventArgs with the given iteration number
            </summary>
            <param name="iteration"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.ProgressChangedEventArgs.Iteration">
            <summary>
            The iteration of inference that has just been completed (the first iteration is 0).
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.QueryTypes">
            <summary>
            Static query types
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QueryTypes.Marginal">
            <summary>
            The default query type - returns the marginal.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QueryTypes.Samples">
            <summary>
            This returns the samples for sampling algorithms
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QueryTypes.Conditionals">
            <summary>
            For sampling algorithms, this returns the list of distributions from which the samples were drawn.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QueryTypes.MarginalDividedByPrior">
            <summary>
            Returns the marginal distribution divided by the prior distribution, leaving only the data likelihood
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Argument">
            <summary>
            Useful routines for checking arguments of a function for correctness.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Argument.CheckIfNotNull``1(``0,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/> if the argument is <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="argument">The argument.</param>
            <param name="argumentName">The name of the argument.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Argument.CheckIfNotNull``1(``0,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/> with the specified message if the argument is <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="argument">The argument.</param>
            <param name="argumentName">The name of the argument.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Argument.CheckIfInRange(System.Boolean,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if the <paramref name="inRangeCondition"/> is <see langword="false"/>.
            </summary>
            <param name="inRangeCondition"><see langword="true"/> if the argument is in its valid range, <see langword="false"/> otherwise.</param>
            <param name="argumentName">The name of the argument.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Argument.CheckIfValid(System.Boolean,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the <paramref name="isValidCondition"/> is <see langword="false"/>.
            </summary>
            <param name="isValidCondition"><see langword="true"/> if the argument has a valid value, <see langword="false"/> otherwise.</param>
            <param name="argumentName">The name of the argument.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Argument.CheckIfValid(System.Boolean,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> without specifying the argument
            if the <paramref name="isValidCondition"/> is <see langword="false"/>.
            </summary>
            <param name="isValidCondition"><see langword="true"/> if the exception should not be thrown, <see langword="false"/> otherwise.</param>
            <param name="message">The exception message.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.ArrayComparer`1">
            <summary>
            An equality comparer that compares arrays based on content.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertFailedException">
            <summary>
            Thrown when Assert.IsTrue fails.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Assert">
            <summary>
            Assertion methods for debugging.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertWhenDebugging">
            <summary>
            Assertion methods which are stripped out in release mode.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.CursorArray`1">
            <summary>
            A multidimensional array of objects which share a single storage block.
            </summary>
            <remarks><para>
            A CursorArray is meant to behave like an ordinary Array, while being
            more memory-efficient.  Instead of storing multiple instances of the
            same object type, it uses a single instance as a cursor over a block
            of data.  The cursor acts like a pointer which is targeted at
            the desired part of the array (via its Start property).
            </para><para>
            The CursorArray object does not hold a pointer to the actual source data.
            It is agnostic about the actual type and layout of the 
            data that the cursor is walking over, providing a large degree of 
            flexibility in the implementation of the cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32[])">
            <summary>
            Position the cursor at a multidimensional index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32)">
            <summary>
            Position the cursor at a linear index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(System.Action)">
            <summary>
            Invoke an action for each element of an array.
            </summary>
            <param name="action">A delegate which accesses the array cursor.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,System.Action)">
            <summary>
            Invoke an element-wise action across two arrays.
            </summary>
            <param name="that">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,MicrosoftResearch.Infer.Collections.ICursorArray,System.Action)">
            <summary>
            Invoke an element-wise action across three arrays.
            </summary>
            <param name="a">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32[])">
            <summary>
            Retrieve an object by multidimensional index.
            </summary>
            <remarks>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32)">
            <summary>
            Retrieve an object by linear index.
            </summary>
            <remarks><para>
            If the array is multidimensional, this will index the elements 
            sequentially in row-major order, i.e. the rightmost dimension varies
            fastest.
            </para><para>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Count">
            <summary>
            The total number of structures across all dimensions
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Lengths">
            <summary>
            The size of each dimension of the array.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Rank">
            <summary>
            The number of dimensions of the array.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Predicate`2">
            <summary>
            Delegate for two argument predicate
            </summary>
            <typeparam name="T1">Type of first argument</typeparam>
            <typeparam name="T2">Type of second argument</typeparam>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Predicate`3">
            <summary>
            Delegate for three argument predicate
            </summary>
            <typeparam name="T1">Type of first argument</typeparam>
            <typeparam name="T2">Type of second argument</typeparam>
            <typeparam name="T3">Type of third argument</typeparam>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.EnumerableExtensions">
            <summary>
            Extension methods for IEnumerable
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.EnumerableExtensions.FindIndex``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Get the index of the first item where predicate returns true, or -1 if none
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.EnumerableExtensions.Merge``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Merges two sorted lists into one list in ascending order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list1"></param>
            <param name="list2"></param>
            <param name="comparer"></param>
            <returns></returns>
            <remarks>
            If items from list1 and list2 are equal, the items from list1 are put first.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.EnumerableExtensions.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.List{``0}@)">
            <summary>
            Skip n items from a stream, saving the skipped items to a list
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <param name="stream">A stream</param>
            <param name="count">The number of items to skip from the front of the stream.</param>
            <param name="head">On return, the skipped items.</param>
            <returns>The rest of the stream.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.EnumerableComparer`1">
            <summary>
            An equality comparer for IEnumerable that requires elements at the same position to match
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ListComparer`1">
            <summary>
            An equality comparer for IList that requires elements at the same index to match
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.DictionaryComparer`2">
            <summary>
            An equality comparer that requires the sequence of keys and values to match
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Collection">
            <summary>
            Extension methods for ICollection
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.Sort``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>
            Sort a pair of collections according to the values in the first collection
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="keys"></param>
            <param name="items"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add multiple items to a collection
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection to add to</param>
            <param name="items">The items to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.ContainsAll``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Test if a collection contains multiple items
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection</param>
            <param name="items">The items to search for</param>
            <returns>True if the collection contains all items.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Test if a collection contains any of multiple items
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection</param>
            <param name="items">The items to search for</param>
            <returns>True if the collection contains any item in items.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.CompiledExpression`1">
            <summary>
            Class that stores a delegate expression together with its compiled form.
            </summary>
            <typeparam name="TFunc">Type of a delegate represented by the expression.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.#ctor">
            <summary>
            Creates new instance of a class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.#ctor(System.Linq.Expressions.Expression{`0})">
            <summary>
            Creates new instance of a class that stores given expression inside.
            </summary>
            <param name="expression">Expression to store.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.Get">
            <summary>
            Retrieves compiled version of the stored expression.
            </summary>
            <returns>Compiled expression.</returns>
            <exception cref="T:System.InvalidOperationException">If this instances stores no expression.</exception>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.CompiledExpression`1.Expression">
            <summary>
            Gets or sets the expression stored by this instance.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.DataContractSurrogate">
            <summary>
            Allows DataContractSerializer to serialize Vector and Matrix objects
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Hash">
            <summary>
            Utilities for implementing GetHashCode().
            </summary>
            <remarks><para>
            To hash an object with two fields x and y:
            <code>return Hash.Combine(x.GetHashCode(), y.GetHashCode());</code>
            </para><para>
            To hash an array:
            <example><code>
            int hash = Hash.Start;
            for(int i = 0; i &lt; Count; i++)
            	hash = Hash.Combine(hash, this[i].GetHashCode());
            return hash;
            </code></example>
            </para><para>
            Algorithm: FNV hash from http://www.isthe.com/chongo/tech/comp/fnv/
            </para><para>
            Note: You should not use xor to combine hash codes, even though it is
            recommended by MSDN.  xor is invariant to permutation, which means
            "abc" and "bac" and "cba" will hash to the same value (bad).
            Also xoring a hash value with itself produces 0, so "aab" and "b"
            will hash to the same value (bad).
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.Hash.Start">
            <summary>
            The recommended start value for a combined hash value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Byte)">
            <summary>
            Combines an existing hash key with a new byte value
            </summary>
            <param name="hash">Current hash code</param>
            <param name="key">New byte of the new hash code to be integrated</param>
            <returns>A new hash-count that is neither order invariant nor "idempotent"</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            Combines two int32 hash keys
            </summary>
            <param name="hash">First hash key</param>
            <param name="key">Second hash key</param>
            <returns>Incorporates the second hash key into the first hash key and returns the new, combined hash key</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Double)">
            <summary>
            Incorporates the hash key of a double into an existing hash key
            </summary>
            <param name="hash">Exisiting hash key</param>
            <param name="number">Floating point number to incorporate</param>
            <returns>The new, combined hash key</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.HashedList`1">
            <summary>
            Hash-indexed list.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            The user can supply a list and it will be automatically indexed.
            However, only changes made through this interface will be indexed properly.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IArrayFactory`2">
            <summary>
            Interface to an object providing a constructor for new arrays.
            </summary>
            <typeparam name="ItemType"></typeparam>
            <typeparam name="ArrayType"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix">
            <summary>
            Class for lower triangular matrices
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Matrix">
            <summary>
            Two-dimensional container of doubles.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.RowVector(System.Int32)">
            <summary>
            A row of the matrix.
            </summary>
            <param name="row">An integer in [0,Rows-1].</param>
            <returns>If colStride == 1, then a Vector object pointing at one row of this matrix.  Otherwise a copy of the row.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetEnumerator">
            <summary>
            Gets a typed enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Contains(System.Double)">
            <summary>
            Returns true if this matrix contains the given value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the values in this matrix to an array starting at a given index in the destination array
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IndexOf(System.Double)">
            <summary>
            Returns the first index of the given item if it exists in the matrix,
            otherwise returns -1
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Construct a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Construct a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Clone">
            <summary>
            Fully clones this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToArray">
            <summary>
            Creates a 2-D arrays from this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[0:,0:])">
            <summary>
            Copies matrix values to a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copies values from another matrix.
            </summary>
            <param name="that">The second matrix, which must have the same size as this.</param>
            <returns>The mutated this matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[0:,0:])">
            <summary>
            Copies values from a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SymmetryError">
            <summary>
            max | this[i,j] - this[j,i] |
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Symmetrize">
            <summary>
            Set a[i,j] to the average (a[i,j]+a[j,i])/2
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentity">
            <summary>
            Sets the matrix to the identity.
            </summary>
            <remarks>The matrix must be square.</remarks>
            <returns>The mutated matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentityScaledBy(System.Double)">
            <summary>
            Sets the matrix to the identity times a number.
            </summary>
            <param name="scale"></param>
            <returns>The mutated matrix.</returns>
            <remarks>The matrix must be square.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Identity(System.Int32)">
            <summary>
            Creates an identity matrix of the specified size
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates an identity matrix of the specified size, scaled by the specified value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Transpose">
            <summary>
            Transposes the matrix.
            </summary>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets the matrix to the transpose of another.
            </summary>
            <param name="that">The matrix to transpose.  Can be the same object as <c>this</c>.  <c>that.Count</c> must equal <c>this.Count</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the transposed matrix, and must already
            be the correct size.
            If <c>this</c> and <paramref name="that"/> are different objects but occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSubmatrix(MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32)">
            <summary>
            Sets the matrix to a submatrix of another.
            </summary>
            <param name="that">Size must be at least <c>this.Rows+firstRow</c> by <c>this.Cols+firstColumn</c>.</param>
            <param name="firstRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="firstColumn">Index of the first column in <paramref name="that"/> to copy.</param>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Set a submatrix of this matrix to match another matrix.
            </summary>
            <param name="firstRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="firstColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-thisRow</c> by <c>this.Cols-thisColumn</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets a submatrix of this matrix to match another matrix.
            </summary>
            <param name="thisRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="thisColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-firstRow</c> by <c>this.Cols-firstColumn</c>.</param>
            <param name="thatRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="thatColumn">Index of the first column in <paramref name="that"/> to copy.</param>
            <param name="numRows">The number of rows to copy</param>
            <param name="numColumns">The number of columns to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDiagonal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this matrix to a diagonal matrix with diagonal values specified in the given vector
            </summary>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetDiagonal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the diagonal elements to the values specified in the given vector
            </summary>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Diagonal">
            <summary>
            Creates a vector from the diagonal values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EnumerateDiagonal">
            <summary>
            Enumerator which yields the diagonal elements of the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.TraceOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>sum_i sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.DiagonalOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>v[i] = sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Scale(System.Double)">
            <summary>
            Multiplies this matrix by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleRows(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each row of this matrix by a different scalar.
            </summary>
            <param name="rowScale">The ith element scales row i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleCols(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each column of this matrix by a different scalar.
            </summary>
            <param name="colScale">The ith element scales column i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Median">
            <summary>
            Returns the median of the values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise product of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] * b[i,j]</c>.  <c>this</c> receives the product, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseRatio(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise ratio of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] / b[i,j]</c>.  <c>this</c> receives the ratio, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Gets a matrix times a scalar.
            </summary>
            <param name="m">A matrix, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="s">A scalar.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="m"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Multiplies every element of a matrix by a scalar.
            </summary>
            <param name="m">A matrix.</param>
            <param name="s">A scalar.</param>
            <returns>A new matrix with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of two matrices.
            </summary>
            <param name="A">First matrix.  Cannot be <c>this</c>.</param>
            <param name="B">Second matrix.  Cannot be <c>this</c>.</param>
            <remarks><paramref name="A"/> and <paramref name="B"/> must have compatible dimensions.
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="B"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of a matrix and its transpose (A*A').
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A*A' and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Outer">
            <summary>
            Returns the product of this matrix and its transpose
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuterTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product A'*A.
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A'*A and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.OuterTranspose">
            <summary>
            Returns the transpose of this matrix times this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Matrix product.
            </summary>
            <param name="A">First matrix.</param>
            <param name="B">Second matrix.</param>
            <returns>A new matrix with their product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Premultiplies a vector by a matrix (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Postmultiplies a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.</param>
            <param name="A">A matrix.</param>
            <returns>The new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of two vectors.
            </summary>
            <param name="a">First vector, of length <c>this.Rows</c>.</param>
            <param name="b">Second vector, of length <c>this.Cols</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSumWithOuter(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a matrix plus the scaled outer product of two vectors.
            </summary>
            <param name="m">A matrix with the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="scale"></param>
            <param name="a">A vector with <c>a.Count == this.Rows</c></param>
            <param name="b">A vector with <c>b.Count == this.Cols</c></param>
            <returns>this[i,j] = m[i,j] + scale*a[i]*b[j]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ax (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <remarks><c>this</c> must be a square matrix with Rows == x.Count.</remarks>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ay (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <param name="y">A vector whose length equals Cows.</param>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to sum of two other matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] + b[i,j]</c>.  <c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of two matrices with scale factors.
            </summary>
            <param name="aScale">A scale factor.</param>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="bScale">A scale factor.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = aScale*a[i,j] + bScale*b[i,j]</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Addition(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the sum of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to a - bScale*b
            </summary>
            <param name="a"></param>
            <param name="bScale"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Subtraction(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the negation of a matrix.
            </summary>
            <param name="a">The matrix to negate.</param>
            <returns>The negation -a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Equality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second Matrix.</param>
            <returns>True if the matrices have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Inequality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>True if matrices are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Equals(System.Object)">
            <summary>
            Object comparator.
            </summary>
            <param name="obj">An object - must be an IntMatrix.</param>
            <returns>True if objects are equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetHashCode">
            <summary>
            Hash code generator.
            </summary>
            <returns>The hash code for the instance.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckCompatible(MicrosoftResearch.Infer.Maths.Matrix,System.String)">
            <summary>
            Checks that a given matrix is the same size as this matrix.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The matrix to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckSymmetry(System.String)">
            <summary>
            Checks this matrix for symmetry
            </summary>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the maximum absolute difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <returns>max(abs(this[i,j] - that[i,j])).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Returns the maximum relative difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns>max(abs(this[i,j] - that[i,j])/(abs(this[i,j]) + rel)).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToString(System.String)">
            <summary>
            Convert the matrix to a string, using a specified number format
            </summary>
            <param name="format">The format string for each matrix entry</param>
            <returns>A string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Parse(System.String)">
            <summary>
            Parse a string (in the format produced by ToString) to recover a Matrix
            </summary>
            <param name="s">The string to parse</param>
            <returns>A matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IsPositiveDefinite">
            <summary>
            Tests for positive-definiteness.
            </summary>
            <returns>True if the matrix is positive-definite, i.e. all eigenvalues > 0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Trace">
            <summary>
            Trace of a square matrix.
            </summary>
            <returns>The trace.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Determinant">
            <summary>
            Determinant of a square matrix
            </summary>
            <returns>The determinant</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inverse">
            <summary>
            Return the inverse of this matrix - not implemented yet
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inner(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inner product of matrices.
            </summary>
            <param name="A">A matrix with the same size as this.</param>
            <returns>sum_ij A[i,j]*this[i,j].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is an upper triangular matrix and
            B is a matrix of right-hand sides.	It is equivalent to the left-division X = A\B.
            </summary>
            <param name="A">An upper triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'X=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A'\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Cols == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToEigenvectorsOfSymmetric(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Set the columns to the eigenvectors of a symmetric matrix, modifying the input matrix to contain its eigenvalues on the diagonal
            </summary>
            <param name="symmetricMatrix">A symmetric matrix, modified on return to contain its eigenvalues on the diagonal</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EigenvaluesInPlace(System.Double[],System.Double[])">
            <summary>
            Compute the eigenvalues of a square matrix, destroying the contents of the matrix.
            </summary>
            <param name="eigenvaluesReal">On output, the real part of the eigenvalues.</param>
            <param name="eigenvaluesImag">On output, the imaginary part of the eigenvalues.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetColumn(System.Int32)">
            <summary>
            Returns the specified column as an array of doubles
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetRow(System.Int32)">
            <summary>
            Returns the specified row as an array of doubles
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32,System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Rows">
            <summary>
            The number of rows of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Cols">
            <summary>
            The number of columns of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.SourceArray">
            <summary>
            Gets/sets the matrix's source array
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Count">
            <summary>
            Number of elements in the matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this instance (including the data)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.CheckLowerTriangular">
            <summary>
            Checks that this instance is lower triangular
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Modifies <c>this</c> to be the inverse of A.
            </summary>
            <param name="A">Can be the same object as <c>this</c></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Inverse">
            <summary>
            Returns the inverse of this lower triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Transpose">
            <summary>
            Returns the transpose of this lower triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements of this lower triangular matrix
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this lower-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.TraceLn(System.Boolean)">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.LogDeterminant(System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of a lower-triangular matrix.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToCholesky(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Gets the Cholesky decomposition of another matrix.
            </summary>
            <param name="A">A symmetric matrix to decompose.</param>
            <returns>True if <paramref name="A"/> is positive definite, otherwise false.</returns>
            <remarks>
            The decomposition is a lower triangular matrix L, returned in <c>this</c>.
            <paramref name="A"/> must be symmetric, but need not be positive definite.
            If <paramref name="A"/> is positive semidefinite, 
            then L will satisfy L*L' = A.
            Otherwise, L will only approximately satisfy L*L' = A.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LuDecomposition">
            <summary>
            Class for calculating and doing operations with an LU decomposition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.LuDecomposition.LU">
            <summary>
            Stores the permuted L in the lower triangle (whose diagonal is assumed to be 1), with U in the upper triangle and diagonal.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance with a given number of rows and columns
            </summary>
            <param name="nRows">Number of rows</param>
            <param name="nCols">Number of columns</param>
            <remarks><para>
            Currently this only supports square matrices
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs an instance and performs the decomposition on the given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.InPlace(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Creates performs and returns an LuDecomposition on a given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Decomposes the matrix A
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose">
            <summary>
            Performs the decomposition for this instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Determinant">
            <summary>
            Compute the determinant of the decomposed matrix. The
            decomposition is assumed to have been performed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Solve(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Solves Ay = x for y, leaving the result in x.
            </summary>
            <param name="x"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixSingularException">
            <summary>
            Exception thrown when a singular matrix is encountered.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixSingularException.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Construct the exception.
            </summary>
            <param name="m">The offending matrix.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixSingularException.Offender">
            <summary>Gets the singular matrix that caused the exception.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy scalar observations,
            and computing sample count, mean, and variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Mean">
            <summary>
            The sample mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Variance">
            <summary>
            Sample variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Count">
            <summary>
            Sample count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2">
            <summary>
            Class for accumulating weighted noisy scalar observations,
            and computing sample count, mean, and variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Mean">
            <summary>
            The sample mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Variance">
            <summary>
            Sample variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.LogCount">
            <summary>
            Sample count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="logWeight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double,System.Double,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="logWeight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.SetTo(MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix">
            <summary>
            A subclass of Matrix with extra methods appropriate to positive-definite matrices.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs a positive-definite matrix type which references an existing matrix.
            </summary>
            <param name="A">A positive-definite matrix.</param>
            <remarks>This method is similar to a typecast, except it creates a new wrapper around the matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Identity(System.Int32)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension, scaled by a given value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Clone">
            <summary>
            Creates a full clone of this positive-definite matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToSum(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to the sum of two positive-definite matrices.
            Assumes compatible matrices
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.op_Addition(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Add two positive-definite matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.op_Multiply(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Multiply matrix times scalar
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>A new matrix with entry [i,j] equal to a[i,j]*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Determinant">
            <summary>
            Returns the determinant of this positive-definite matrix.
            </summary>
            <returns>The determinant of <c>this</c>.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant(System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant of <c>this</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix
            where a lower triangular workspace is passed in.
            </summary>
            <param name="L">A temporary workspace, same size as <c>this</c>.</param>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Inverse">
            <summary>
            Returns the inverse of a positive-definite matrix.
            </summary>
            <returns>A new matrix which is the inverse of <c>this</c></returns>
            <remarks>
            Because <c>this</c> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <c>this</c> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix
            where a lower triangular workspace is passed.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <param name="L">A workspace, same size as <paramref name="A"/>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">
            <summary>
            Exception thrown when a matrix is not positive definite.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException.#ctor">
            <summary>
            Creates a new positive definite matrix exception
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Quadrature">
            <summary>
            Quadrature nodes and weights
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.AdaptiveClenshawCurtis(System.Converter{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>
            Integrate the function f from -Infinity to Infinity
            </summary>
            <param name="f">The function to integrate</param>
            <param name="CCFactor">A positive tuning parameter</param>
            <param name="numIntervals">The initial number of nodes</param>
            <param name="relTol">A threshold to stop subdividing</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GaussianNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gaussian expectations.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{-inf..inf} f(x) N(x; m, v) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute E[x*x] where x ~ N(2,3):
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.GaussianNodesAndWeights(2,3,nodes,weights);
            double result = (weights*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = 7. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GammaNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gamma expectations.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="logWeights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{0..inf} f(x) Ga(x; a, b) dx</c> where
            <c>Ga(x; a, b) = x^a*exp(-x*b)*b^(a+1)/Gamma(a+1)</c>.
            For example, to approximate E[x*x] where x ~ Ga(2,3):
            <code>
            Vector nodes = new Vector(3);
            Vector logWeights = new Vector(3);
            Quadrature.GammaNodesAndWeights(2,3,nodes,logWeights);
            double result = (exp(logWeights)*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = ((a+1)^2 + (a+1))/b^2 = 4/3.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.UniformNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for integrals on [low,high].
            </summary>
            <param name="low">Lower limit of integration.  Must be finite.</param>
            <param name="high">Upper limit of integration.  Must be finite.</param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{low..high} f(x) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute <c>int_{0..1} x^3 dx</c>:
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.UniformNodesAndWeights(0,1,nodes,weights);
            double result = (weights*nodes*nodes*nodes).Sum();
            </code>
            The result is 1/4.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LegendreNodesAndWeights">
            <summary>
            Legendre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LaguerreNodesAndWeights">
            <summary>
            Laguerre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.HermiteNodesAndWeights">
            <summary>
            Hermite nodes and weights
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Rand">
            <summary>
            This class provides a source of non-uniform random numbers.
            It cannot be instantiated and consists of only static functions.
            </summary>
            <remarks>A thread-static <c>System.Random</c> object provides the underlying random numbers.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.threadGenerator">
            <summary>
            Generate random seeds for new threads.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.threadGeneratorLock">
            <summary>
            Lock for threadGenerator.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand._gen">
            <summary>
            Supplies uniform random numbers for this thread.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.usePreviousSample">
            <summary>
            If true, Normal() returns previousSample.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.previousSample">
            <summary>
            If usePreviousSample = true, this is the next value Normal() 
            will return.  Otherwise its value is unspecified.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Restart(System.Int32)">
            <summary>
            Restarts the random number sequence for this thread (and influence future threads)
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.
            If a negative number is specified, the absolute value of the number is used.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int">
            <summary>
            Generates a non-negative random integer.
            </summary>
            <returns>A random integer &gt;= 0.</returns>
            <remarks>Same as <see cref="M:System.Random.Next"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32)">
            <summary>
            Generates a random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>
            </summary>
            <param name="maxPlus1">Upper bound.  Must be &gt;= 0.</param>
            <returns>A random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> is zero, zero is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32,System.Int32)">
            <summary>
            Generates a random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.
            </summary>
            <param name="min">Minimum value.</param>
            <param name="maxPlus1">Maximum value.  Must be &gt;= <paramref name="min"/>.</param>
            <returns>A random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> == <paramref name="min"/>, <paramref name="min"/> is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32,System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Double">
            <summary>
            Generates a random double-precision value in [0,1).
            </summary>
            <returns>A random double.</returns>
            <remarks>Same as <see cref="M:System.Random.NextDouble"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Perm(System.Int32)">
            <summary>
            Generates a random permutation.
            </summary>
            <param name="n">The length of permutation to make. Must be > 0.</param>
            <returns>An array of <paramref name="n"/> unique integers, each in the range [0,<paramref name="n"/>-1].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Shuffle``1(``0[])">
            <summary>
            Permute the elements of an array.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="array">The array to shuffle.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Permute the elements of a list.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="list">The list to shuffle.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] &gt;= 0 is the probability of outcome i, times an arbitrary constant.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
            <exception cref="T:MicrosoftResearch.Infer.Maths.AllZeroException">Thrown when prob is all zeros.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] is the probability of outcome i, times <paramref name="sum"/>.  Must be >= 0.</param>
            <param name="sum">The sum of the prob array.  Must be > 0.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] is the probability of outcome i, times <paramref name="sum"/>.  Must be >= 0.</param>
            <param name="sum">The sum of the prob array.  Must be > 0.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(System.Double,System.Double)">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="stdDev">The standard deviation (sqrt of the variance).</param>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="variance">The covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalP(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precision">The inverse of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="varChol">The lower triangular Cholesky factor of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalPChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.UpperTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precCholT">The upper triangular transpose of the Cholesky factor of the precision matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalGreaterThan(System.Double)">
            <summary>
            Sample from a Gaussian(0,1) truncated at the given lower bound
            </summary>
            <param name="lowerBound">The truncation point.  Can be -Infinity.</param>
            <returns>A real number &gt;= <paramref name="lowerBound"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalBetween(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian(0,1) truncated at the given upper and lower bounds
            </summary>
            <param name="lowerBound">Can be -Infinity.</param>
            <param name="upperBound">Must be &gt;= <paramref name="lowerBound"/>.  Can be Infinity.</param>
            <returns>A real number &gt;= <paramref name="lowerBound"/> and &lt; <paramref name="upperBound"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Gamma(System.Double)">
            <summary>
            Generates a random sample from a Gamma distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <returns>A nonnegative finite real number.  May be zero.</returns>
            <remarks>The distribution is defined as p(x) = x^(a-1)*exp(-x)/Gamma(a).
            To incorporate a scale parameter b, multiply the result by b.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Wishart(System.Double,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Generates a random sample from a Wishart distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <param name="result">Receives the lower triangular Cholesky factor of the sampled matrix.  Must be non-null, square, and already allocated to the desired size.</param>
            <remarks><para>
            The <a href="http://en.wikipedia.org/wiki/Wishart_distribution">Wishart distribution</a> 
            is defined as
            </para><para>
            p(X) = |X|^((n-d-1)/2)*exp(-tr(X))/Gamma_d(n/2) (using parameter n)
            </para><para>
            or 
            </para><para>
            p(X) = |X|^(a-(d+1)/2)*exp(-tr(X))/Gamma_d(a) (using parameter a)
            </para><para>
            This routine returns chol(X).  To incorporate a scale parameter C, 
            set Y = chol(C)*X*chol(C)', which implies chol(Y) = chol(C)*chol(X). 
            If you invert and transpose chol(X), then you have chol(inv(X)), 
            where inv(X) is a sample from the inverse Wishart distribution: 
            </para><para>
            p(X) = |X|^(-a-(d+1)/2)*exp(-tr(inv(X)))/Gamma_d(a)
            </para></remarks>
            <example>
            <code>
            Matrix L = new Matrix(d,d);
            Rand.Wishart(a,L);
            Matrix X = new Matrix(d,d);
            X.SetToProduct(L, L.Transpose());
            </code>
            </example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Beta(System.Double,System.Double)">
            <summary>
            Generates a random sample from the Beta distribution with given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Dirichlet(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from the Dirichlet distribution with the given
            pseudo-count
            </summary>
            <param name="pseudoCount">Pseudo-count</param>
            <param name="result">Where to put the result</param>
            <returns>The sample</returns>
            <remarks>If pseudoCount is a sparse vector and the common
            value for the sparse vector is not 0, then the result will be dense; in such
            a case it is recommended that 'result' be a dense vector type.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Binomial(System.Int32,System.Double)">
            <summary>
            Generates a random sample from the Binomial distribution with parameters p and n.
            </summary>
            <param name="n">Number of trials</param>
            <param name="p">Probability of success per trial</param>
            <remarks>
            Reference:
             [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
             Springer-Verlag, 1986.
             [2] Kachitvichyanukul, V., and Schmeiser, B. W. "Binomial Random Variate Generation." 
             Comm. ACM, 31, 2 (Feb. 1988), 216.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sample from a Multinomial distribution with specified dense vector of probabilities and number of trials.
            </summary>
            <param name="trialCount"></param>
            <param name="probs"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Poisson(System.Double)">
            <summary>
            Sample from a Poisson distribution with specified mean.
            </summary>
            <param name="mean">Must be >= 0</param>
            <returns>An integer in [0,infinity)</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Rand.gen">
            <summary>
            This must be set up as a property to allow correct initialisation across threads.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.AllZeroException">
            <summary>
            Exception type thrown when probability vector = (0,0,0,...,0).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor">
            <summary>
            Constructs the exception.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor(System.String)">
            <summary>
            Constructs the exception with a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Stochastic">
            <summary>
            When applied to a method, indicates that the method is non-deterministic.
            </summary>
            <remarks>
            A method is non-deterministic if its return value is not completely determined by its arguments.
            For a void method, this attribute is meaningless.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MMath">
            <summary>
            This class provides mathematical constants and special functions, 
            analogous to System.Math.
            It cannot be instantiated and consists of static members only.
            </summary>
            <remarks>
            <para>
            In order to provide the highest accuracy, some routines return their results in log form or logit form.
            These transformations expand the domain to cover the full range of double-precision values, ensuring 
            all bits of the representation are utilized.  A good example of this is the NormalCdf function, whose 
            value lies between 0 and 1.  Numbers between 0 and 1 use only a small fraction of the capacity of a 
            double-precision number.  The function NormalCdfLogit transforms the result p according to log(p/(1-p)), 
            providing full use of the range from -Infinity to Infinity and (potentially) much higher precision.
            </para><para>
            To get maximal use out of these transformations, you want to stay in the expanded form as long as 
            possible.  Every time you transform into a smaller domain, you lose precision.  Thus helper functions 
            are provided which allow you to perform common tasks directly in the log form and logit form. 
            For logs, you have addition.  For logit, you have averaging. 
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianQuadratureNodeCount">
            <summary>
            Specifies the number of quadrature nodes that should be used when doing
            Gauss Hermite quadrature for direct KL minimisation 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianVarianceThreshold">
            <summary>
            For integrals with variance greater than this Clenshaw curtis quadrature will be used
            instead of Gauss-Hermite quadrature. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.EulerGamma">
            <summary>
            The Euler-Mascheroni Constant.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Digamma1">
            <summary>
            Digamma(1)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2PI">
            <summary>
            Math.Sqrt(2*Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.InvSqrt2PI">
            <summary>
            1.0/Math.Sqrt(2*Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnSqrt2PI">
            <summary>
            Math.Log(Math.Sqrt(2*Math.PI)).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnPI">
            <summary>
            Math.Log(Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Ln2">
            <summary>
            Math.Log(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2">
            <summary>
            Math.Sqrt(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.SqrtHalf">
            <summary>
            Math.Sqrt(0.5)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g">
            <summary>
            Expansion point of the Lanczos method, used in Gamma and GammaLn.
            Must be consistent with <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Zeta2">
            <summary>
            Zeta(2) = Trigamma(1) = pi^2/6.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_large">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_small">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.M2Zeta3">
            <summary>
            Tetragamma(1) = -2 Zeta(3)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_large">
            <summary>
            The threshold for applying de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_small">
            <summary>
            The threshold for applying de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Zeta4">
            <summary>
            Zeta4 = pi^4/90
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BesselI(System.Double,System.Double)">
            <summary>
            Modified Bessel function of the first kind
            </summary>
            <param name="a">Order parameter.  Any real number except a negative integer.</param>
            <param name="x">Argument of the Bessel function.  Non-negative real number.</param>
            <remarks>
            Reference:
            "A short note on parameter approximation for von Mises-Fisher distributions, And a fast implementation of Is(x)"
            Suvrit Sra
            Computational Statistics, 2011
            http://people.kyb.tuebingen.mpg.de/suvrit/papers/vmfFinal.pdf
            </remarks>
            <returns>BesselI(a,x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BPSer(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Power series for incomplete beta function obtained by replacing the second term in the integrand.
            BPSER method described in Didonato and Morris.
            </summary>
            <param name="x">The value.</param>
            <param name="a">The true count for the Beta.</param>
            <param name="b">The false count for the Beta.</param>
            <param name="epsilon">A tolerance for terminating the series calculation.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BUp(System.Double,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            BUP method described in Didonato and Morris.
            </summary>
            <param name="x">Value.</param>
            <param name="a">True count.</param>
            <param name="b">False count.</param>
            <param name="n">True count increment.</param>
            <param name="epsilon">Tolerance.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BGRat(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            BGRAT method described in Didonato and Morris.
            </summary>
            <param name="x">Value.</param>
            <param name="a">True count.</param>
            <param name="b">False count.</param>
            <param name="epsilon">Tolerance.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BFrac(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            BFRAC method using continued fraction described in Didonato and Morris.
            </summary>
            <param name="x">Value.</param>
            <param name="a">True count.</param>
            <param name="b">False count.</param>
            <param name="maxIterations">Maximum number of iterations.</param>
            <param name="epsilon">Tolerance.</param>
            <param name="useDM">Whether to use the Didonato-Morris (default) or the classic continued fraction.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BAsym(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            BASYM method described in Didonato and Morris.
            </summary>
            <param name="x">Value.</param>
            <param name="a">True count.</param>
            <param name="b">False count.</param>
            <param name="epsilon">Tolerance.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Beta(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the regularized incomplete beta function: int_0^x t^(a-1) (1-t)^(b-1) dt / Beta(a,b)
            </summary>
            <param name="x">The first argument - any real number between 0 and 1.</param>
            <param name="a">The second argument - any real number greater than 0.</param>
            <param name="b">The third argument - any real number greater than 0.</param>
            <param name="epsilon">A tolerance for terminating the series calculation.</param>
            <returns>The incomplete beta function at (<paramref name="x"/>, <paramref name="a"/>, <paramref name="b"/>).</returns>
            <remarks>The beta function is obtained by setting x to 1.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Gamma(System.Double)">
            <summary>
            Evaluates Gamma(x), defined as the integral from 0 to x of t^(x-1)*exp(-t) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>Gamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double)">
            <summary>
            Computes the natural logarithm of the Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <returns>ln(Gamma(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(Gamma(x))</c>, which may fail for large x.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <param name="d">The dimension, an integer > 0.</param>
            <returns>ln(Gamma_d(x))</returns>
            <remarks>The <a href="http://en.wikipedia.org/wiki/Multivariate_gamma_function">multivariate Gamma function</a> 
            is defined as Gamma_d(x) = pi^(d*(d-1)/4)*prod_(i=1..d) Gamma(x + (1-i)/2)</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Digamma(System.Double,System.Double)">
            <summary>
            Derivative of the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0</param>
            <param name="d">The dimension, an integer > 0</param>
            <returns>digamma_d(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Trigamma(System.Double,System.Double)">
            <summary>
            Second derivative of the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0</param>
            <param name="d">The dimension, an integer > 0</param>
            <returns>trigamma_d(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Digamma(System.Double)">
            <summary>
            Evaluates Digamma(x), the derivative of ln(Gamma(x)).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Digamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Trigamma(System.Double)">
            <summary>
            Evaluates Trigamma(x), the derivative of Digamma(x).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Trigamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Tetragamma(System.Double)">
            <summary>
             Evaluates Tetragamma, the forth derivative of logGamma(x)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double)">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(Gamma(k+1)*Gamma(n-k+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double[])">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(prod_i Gamma(k[i]+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaUpper(System.Double,System.Double)">
            <summary>
            Compute the regularized upper incomplete Gamma function: int_x^inf t^(a-1) exp(-t) dt / Gamma(a)
            </summary>
            <param name="a">The shape parameter, &gt; 0</param>
            <param name="x">The lower bound of the integral, &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLower(System.Double,System.Double)">
            <summary>
            Compute the regularized lower incomplete Gamma function: int_0^x t^(a-1) exp(-t) dt / Gamma(a)
            </summary>
            <param name="a">The shape parameter, &gt; 0</param>
            <param name="x">The upper bound of the integral, &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaAsympt(System.Double,System.Double,System.Boolean)">
            <summary>
            Compute the regularized lower incomplete Gamma function: <c>int_0^x t^(a-1) exp(-t) dt / Gamma(a)</c>
            </summary>
            <param name="a">Must be &gt; 20</param>
            <param name="x"></param>
            <param name="upper">If true, compute the upper incomplete Gamma function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLowerSeries(System.Double,System.Double)">
            <summary>
            Compute the regularized lower incomplete Gamma function by a series expansion
            </summary>
            <param name="a">The shape parameter, &gt; 0</param>
            <param name="x">The lower bound of the integral, &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaUpperSeries(System.Double,System.Double)">
            <summary>
            Compute the regularized upper incomplete Gamma function by a series expansion
            </summary>
            <param name="a">The shape parameter, &gt; 0</param>
            <param name="x">The lower bound of the integral, &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ReciprocalFactorialMinus1(System.Double)">
            <summary>
            Computes <c>1/Gamma(x+1) - 1</c> to high accuracy
            </summary>
            <param name="x">A real number &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaUpperScale(System.Double,System.Double)">
            <summary>
            Computes <c>x^a e^(-x)/Gamma(a)</c> to high accuracy.
            </summary>
            <param name="a">A positive real number</param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaUpperConFrac(System.Double,System.Double)">
            <summary>
            Compute the regularized upper incomplete Gamma function by a continued fraction
            </summary>
            <param name="a">A real number &gt; 0</param>
            <param name="x">A real number &gt;= 1.1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLnSeries(System.Double)">
            <summary>
            Computes <c>GammaLn(x) - (x-0.5)*log(x) + x - 0.5*log(2*pi)</c> for x &gt;= 10
            </summary>
            <param name="x">A real number &gt;= 10</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Erfc(System.Double)">
            <summary>
            Computes the complementary error function. This function is defined by 2/sqrt(pi) * integral from x to infinity of exp (-t^2) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>The complementary error function at x.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ErfcInv(System.Double)">
            <summary>
            Computes the inverse of the complementary error function, i.e.
            <c>erfcinv(erfc(x)) == x</c>.
            </summary>
            <param name="y">A real number between 0 and 2.</param>
            <returns>A number x such that <c>erfc(x) == y</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfRatio(System.Double)">
            <summary>
            Computes <c>NormalCdf(x)/N(x;0,1)</c> to high accuracy.
            </summary>
            <param name="x">Any real number.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfRatioDiff_Simple(System.Double,System.Double,System.Double)">
            <summary>
            Computes <c>NormalCdfRatio(x+delta)-NormalCdfRatio(x)</c> given <c>NormalCdfRatio(x)</c>
            </summary>
            <param name="x">Any real number</param>
            <param name="delta">A real number with absolute value less than or equal to 0.5</param>
            <param name="y">NormalCdfRatio(x)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfRatioDiff(System.Double,System.Double,System.Double)">
            <summary>
            Computes <c>NormalCdfRatio(x+delta)-NormalCdfRatio(x)</c> given <c>NormalCdfRatio(x)</c>
            </summary>
            <param name="x">Any real number</param>
            <param name="delta">A real number with absolute value less than or equal to 0.5</param>
            <param name="y">NormalCdfRatio(x)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double)">
            <summary>
            Computes the cumulative Gaussian distribution, defined as the
            integral from -infinity to x of N(t;0,1) dt.  
            For example, <c>NormalCdf(0) == 0.5</c>.
            </summary>
            <param name="x">Any real number.</param>
            <returns>The cumulative Gaussian distribution at <paramref name="x"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double)">
            <summary>
            The natural logarithm of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(NormalCdf(x))</c>, which can fail for x &lt; -7.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLogit(System.Double)">
            <summary>
            The log-odds of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)/(1-NormalCdf(x))).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfInv(System.Double)">
            <summary>
            Computes the inverse of the cumulative Gaussian distribution,
            i.e. <c>NormalCdf(NormalCdfInv(p)) == p</c>.
            For example, <c>NormalCdfInv(0.5) == 0</c>.
            This is also known as the Gaussian quantile function.  
            </summary>
            <param name="p">A real number in [0,1].</param>
            <returns>A number x such that <c>NormalCdf(x) == p</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatio(System.Int32,System.Double)">
            <summary>
            Computes int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))
            </summary>
            <param name="n">The exponent</param>
            <param name="x">Any real number</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatioRecurrence(System.Int32,System.Double)">
            <summary>
            Computes <c>int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))</c>
            </summary>
            <param name="n">The exponent</param>
            <param name="x">A real number &gt; -1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatioTaylor(System.Int32,System.Double,System.Double)">
            <summary>
            Compute <c>int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))</c> by Taylor expansion around <c>x0</c>
            </summary>
            <param name="n"></param>
            <param name="delta"></param>
            <param name="x0"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatioTaylor(System.Int32,System.Double,System.Double[])">
            <summary>
            Compute <c>int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))</c> by Taylor expansion given pre-computed derivatives
            </summary>
            <param name="n"></param>
            <param name="delta"></param>
            <param name="derivs"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatioConFrac(System.Int32,System.Double)">
            <summary>
            Computes int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))
            </summary>
            <param name="n">The exponent</param>
            <param name="x">A real number &lt;= -1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double,System.Double,System.Double)">
            <summary>
            Computes the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>phi(x,y,r)</c></returns>
            <remarks>
            The cumulative bivariate normal distribution is defined as
            <c>int_(-inf)^x int_(-inf)^y N([x;y],[0;0],[1 r; r 1]) dx dy</c>
            where <c>N([x;y],[0;0],[1 r; r 1]) = exp(-0.5*(x^2+y^2-2*x*y*r)/(1-r^2))/(2*pi*sqrt(1-r^2))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.OneMinusSqrtOneMinus(System.Double)">
            <summary>
            Computes <c>1-sqrt(1-x)</c> to high accuracy.
            </summary>
            <param name="x">A real number between 0 and 1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatioSequence(System.Int32,System.Double,System.Boolean)">
            <summary>
            Returns NormalCdfMomentRatio(i,x) for i=n,n+1,n+2,...
            </summary>
            <param name="n">A starting index &gt;= 0</param>
            <param name="x">A real number</param>
            <param name="useConFrac">If true, do not use the lookup table</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>ln(phi(x,y,r))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)">
            <summary>
            Computes the logistic function 1/(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>1/(1+exp(-x)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticLn(System.Double)">
            <summary>
            Compute the natural logarithm of the logistic function, i.e. -log(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>-log(1+exp(-x)).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>-log(1+exp(-x))</c>, 
            which can fail for x &lt; -50 and x > 36.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1Plus(System.Double)">
            <summary>
            Computes the natural logarithm of 1+x.
            </summary>
            <param name="x">A real number in the range -1 &lt;= x &lt;= Inf, or NaN.</param>
            <returns>log(1+x), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+x)</c>,
            particularly when <paramref name="x"/> is small.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogRatio(System.Double,System.Double)">
            <summary>
            Computes log(numerator/denominator) to high accuracy.
            </summary>
            <param name="numerator">Any positive real number.</param>
            <param name="denominator">Any positive real number.</param>
            <returns>log(numerator/denominator)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExp(System.Double)">
            <summary>
            Computes log(1 + exp(x)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(1+exp(x)), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+exp(x))</c>,
            particularly when x &lt; -36 or x > 50.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1MinusExp(System.Double)">
            <summary>
            Computes log(1 - exp(x)) to high accuracy.
            </summary>
            <param name="x">A non-positive real number: -Inf &lt;= x &lt;= 0, or NaN.</param>
            <returns>log(1-exp(x)), which is always &lt;= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1-exp(x))</c>,
            particularly when x &lt; -7.5 or x > -1e-5.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ExpMinus1(System.Double)">
            <summary>
            Computes the exponential of x and subtracts 1.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>exp(x)-1</returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>exp(x)-1</c> when x is small.
            It is the inverse function to Log1Plus: <c>ExpMinus1(Log1Plus(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogExpMinus1(System.Double)">
            <summary>
            Computes <c>log(exp(x)-1)</c> for non-negative x.
            </summary>
            <param name="x">A non-negative real number: 0 &lt;= x &lt;= Inf, or NaN.</param>
            <returns><c>log(exp(x)-1)</c></returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>log(exp(x)-1)</c> when x &lt; 1e-3
            or x > 50.
            It is the inverse function to Log1PlusExp: <c>LogExpMinus1(Log1PlusExp(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogDifferenceOfExp(System.Double,System.Double)">
            <summary>
            Computes log(exp(x) - exp(y)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.  Must be greater or equal to y.</param>
            <param name="y">Any real number from -Inf to Inf, or NaN.  Must be less or equal to x.</param>
            <returns></returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(exp(x)-exp(y))</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.DifferenceOfExp(System.Double,System.Double)">
            <summary>
            Computes exp(x)-exp(y) to high accuracy.
            </summary>
            <param name="x">Any real number</param>
            <param name="y">Any real number</param>
            <returns>exp(x)-exp(y)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Double,System.Double)">
            <summary>
            Computes log(exp(x) + exp(y)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="y">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(exp(x)+exp(y)), which is always >= max(x,y).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(exp(x)+exp(y))</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the log of the sum of exponentials of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExpSparse(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the log of the sum of exponentials of a list of doubles
            </summary>
            <param name="list"></param>    
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.DiffLogSumExp(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(exp(x)+exp(a))-log(exp(x)+exp(b)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="a">A finite real number.</param>
            <param name="b">A finite real number.</param>
            <returns>log(exp(x)+exp(a))-log(exp(x)+exp(b))</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of 
            <c>LogSumExp(x,a)-LogSumExp(x,b)</c>, particularly when x is large.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logit(System.Double)">
            <summary>
            Computes the log-odds function log(p/(1-p)).
            </summary>
            <param name="p">Any number between 0 and 1, inclusive.</param>
            <returns>log(p/(1-p))</returns>
            <remarks>This function is the inverse of the logistic function, 
            i.e. <c>Logistic(Logit(p)) == p.</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogitFromLog(System.Double)">
            <summary>
            Compute log(p/(1-p)) from log(p).
            </summary>
            <param name="logp">Any number between -infinity and 0, inclusive.</param>
            <returns>log(exp(logp)/(1-exp(logp))) = -log(exp(-logp)-1).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})">
            <summary>
            Exponentiate array elements and normalize to sum to 1.
            </summary>
            <param name="x">May be +/-infinity</param>
            <returns>A Vector p where <c>p[k] = exp(x[k])/sum_j exp(x[j])</c></returns>
            <remarks>Sparse lists and vectors are handled efficiently</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExpGaussian(System.Double,System.Double)">
            <summary>
            Evaluates E[log(1+exp(x))] under a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussian(System.Double,System.Double)">
            <summary>
            Calculate sigma(m,v) = \int N(x;m,v) logistic(x) dx
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            Note <c>1-LogisticGaussian(m,v) = LogisticGaussian(-m,v)</c> which is more accurate.
            </para><para>
            For large v we can use the big v approximation <c>\sigma(m,v)=normcdf(m/sqrt(v+pi^2/3))</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            For moderate v we first find the mode of the (log concave) function since this may be quite far from m.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianDerivative(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma'(m,v)=\int N(x;m,v)logistic'(x) dx</c>
            </summary>
            <param name="mean">Mean.</param>
            <param name="variance">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=N(m,0,v+pi^2/3)</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            For moderate v we first find the mode of the (log concave) function since this may be quite far from m.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianDerivative2(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma''(m,v)=\int N(x;m,v)logistic''(x) dx</c>
            </summary>
            <param name="mean">Mean.</param>
            <param name="variance">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=-m/(v+pi^2/3)*N(m,0,v+pi^2/3)</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            The function is multimodal so mode finding is difficult and probably won't help.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianRatio(System.Double,System.Double,System.Int32)">
            <summary>
            Calculate (kth derivative of LogisticGaussian)*exp(0.5*mean^2/variance)
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Max(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the maximum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Min(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the minimum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the minimum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the maximum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximumDouble(System.Collections.Generic.IList{System.Double})">
            <summary>
            Returns the index of the maximum element, or -1 if empty.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[])">
            <summary>
            Returns the median of the array elements.
            </summary>
            <param name="array"></param>
            <returns>The median ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[],System.Int32,System.Int32)">
            <summary>
            Returns the median of elements in a subrange of an array.
            </summary>
            <param name="array"></param>
            <param name="start">Starting index of the range.</param>
            <param name="length">The number of elements in the range.</param>
            <returns>The median of array[start:(start+length-1)], ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.RemoveNaNs(System.Double[],System.Int32,System.Int32)">
            <summary>
            Given an array, returns a new array with all NANs removed.
            </summary>
            <param name="array">The source array</param>
            <param name="start">The start index in the source array</param>
            <param name="length">How many items to look at in the source array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double,System.Double)">
            <summary>
            Returns the relative distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>abs(x - y)/(abs(x) + rel)</c>. 
            Matching infinities give zero.
            </returns>
            <remarks>
            This routine is often used to measure the error of y in estimating x.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double)">
            <summary>
            Returns the distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns><c>abs(x - y)</c>. 
            Matching infinities give zero.
            </returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series">
            <summary>
            Coefficients of the Lanczos series for Gamma, determined by
            the expansion point <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_digamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the digamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_normcdfln_series">
            <summary>
            Coefficients of the asymptotic expansion of NormalCdfLn.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_normcdf_table">
            <summary>
            NormCdf(x)/NormPdf(x) for x = 0, -1, -2, -3, ..., -16
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic">
            <summary>
            The classic incomplete beta function continued fraction.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.EvaluateIncompleteBeta(System.Double)">
            <summary>
            Evaluate the incomplete beta function.
            </summary>
            <param name="epsilon">The convergence tolerance.</param>
            <returns>The function value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.GetNumerator(System.Int32)">
            <summary>
            Gets the numerator of the nth term of the continued fraction.
            </summary>
            <param name="n">The term index.</param>
            <returns>The numerator of the nth term.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.GetDenominator(System.Int32)">
            <summary>
            Gets the deniminator of the nth term of the continued fraction.
            </summary>
            <param name="n">The term index.</param>
            <returns>The denominator of the nth term.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.A">
            <summary>
            True count.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.B">
            <summary>
            False count.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.X">
            <summary>
            The value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.Y">
            <summary>
            1.0 minus the value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MMath.BetaConFracClassic.P">
            <summary>
            The probability of true.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MMath.BetaConFracDidonatoMorris">
            <summary>
            Incomplete beta function continued fraction according to Didonato and Morris.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracDidonatoMorris.EvaluateIncompleteBeta(System.Double)">
            <summary>
            Evaluate the incomplete beta function.
            </summary>
            <param name="epsilon">The convergence tolerance.</param>
            <returns>The function value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracDidonatoMorris.GetNumerator(System.Int32)">
            <summary>
            Gets the numerator of the nth term of the continued fraction.
            </summary>
            <param name="n">The term index.</param>
            <returns>The numerator of the nth term.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.BetaConFracDidonatoMorris.GetDenominator(System.Int32)">
            <summary>
            Gets the deniminator of the nth term of the continued fraction.
            </summary>
            <param name="n">The term index.</param>
            <returns>The denominator of the nth term.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix">
            <summary>
            Upper triangular matrix class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
            <param name="data">Storage for the matrix elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.CheckUpperTriangular">
            <summary>
            Check that this matrix is upper triangular
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TransposeInPlace(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Transposes a given lower triangular matrix in place.
            </summary>
            <param name="L">Matrix to transpose.  Contents are corrupted on exit.</param>
            <returns>An upper triangular wrapper of L's source array.</returns>
            <remarks>L is no longer a valid lower triangular matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Transpose">
            <summary>
            Return the transpose of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements.
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this upper-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TraceLn">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.LogDeterminant">
            <summary>
            Returns the natural logarithm of the determinant of this upper-triangular matrix.
            </summary>
            <returns>The log-determinant of this.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Sparsity">
            <summary>
            Defines sparsity settings for vectors. The sparsity handling has been designed to
            deal with large dimensional distributions such as Discrete and Dirichlet distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)">
            <summary>
            Static read-only property giving Sparsity settings for approximate vector with the given tolerance.
            </summary>
            <param name="tolerance">At what tolerance are vector values considered equal to the common value.</param>
            <returns></returns>
            <remarks><see cref="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector"/> supports this specification.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.FromSpec(MicrosoftResearch.Infer.Maths.StorageType,System.Double,System.Int32)">
            <summary>
            Static method to create a general sparsity specification
            </summary>
            <param name="storage">The storage method the vector should use</param>
            <param name="tolerance">The tolerance at which vector element values are considered equal to the common value.</param>
            <param name="countTolerance">The maximum allowed count of vector elements not set to the common value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.CreateZeroVector(System.Int32)">
            <summary>
            Creates a vector of all zeros with these sparsity settings
            </summary>
            <param name="count">Size of vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.CreateConstantVector(System.Int32,System.Double)">
            <summary>
            Creates a constant vector with these sparsity settings
            </summary>
            <param name="count">Size of vector</param>
            <param name="value">Constant value</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.ToString">
            <summary>
            Instance description
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.Equals(System.Object)">
            <summary>
            Determines the equality of this instance with another
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.op_Equality(MicrosoftResearch.Infer.Maths.Sparsity,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First sparsity.</param>
            <param name="b">Second sparsity.</param>
            <returns>True if the sparsity specifications are equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.op_Inequality(MicrosoftResearch.Infer.Maths.Sparsity,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First sparsity specification.</param>
            <param name="b">Second sparsity specification.</param>
            <returns>True if sparsity specifications are not equal.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Sparse">
            <summary>
            Static read-only property giving Sparsity settings for sparse, exact vectors.
            </summary>
            <remarks>A vector class which uses this sparsity will maintain a common background
            value. It is expected that only a small percentage of values will differ from this
            common value, and this enables the vector class to be efficient computationally and
            memory-wise. <see cref="T:MicrosoftResearch.Infer.Maths.SparseVector"/> uses this specification.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Piecewise">
            <summary>
            Static read-only property giving Sparsity settings for piecewise, exact vectors.
            </summary>
            <remarks>A vector class which uses this sparsity is expected to have ranges of elements
            that have the same values. <see cref="T:MicrosoftResearch.Infer.Maths.PiecewiseVector"/> uses this specification.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Dense">
            <summary>
            Static read-only property giving Sparsity settings for dense vectors.
            </summary>
            <remarks> <see cref="T:MicrosoftResearch.Infer.Maths.DenseVector"/> uses this specification.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Storage">
            <summary>
            The storage method used by this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsDense">
            <summary>
            True if is the vector is dense
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsSparse">
            <summary>
            True if the vector is sparse (exact or approximate)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsPiecewise">
            <summary>
            True if is the vector is piecewise
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsApproximate">
            <summary>
            True if the sparsity is approximate
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsExact">
            <summary>
            True if the sparsity is exact
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Tolerance">
            <summary>
            The tolerance at which vector element values are considered equal to the common value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.CountTolerance">
            <summary>
            The maximum allowed count of vector elements not set to the common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.StorageType">
            <summary>
            The type of storage used in a vector, which is 
            specified as part of the Sparsity class.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Dense">
            <summary>
            The vector is stored as a dense array with memory allocated
            for each element.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Sparse">
            <summary>
            The vector is stored as a sparse array with memory allocated
            only for elements that do not have a particular common value.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Piecewise">
            <summary>
            The vector is stored as a set of pieces with each piece
            having a constant value, and all elements not in any piece 
            having a particular common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.IGeneratedAlgorithm">
            <summary>
            Interface for running a generated inference algorithm
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Execute(System.Int32)">
            <summary>
            Execute the inference algorithm for the specified number of iterations, starting from the initial state
            </summary>
            <param name="numberOfIterations">The number of iterations to perform from the initial state</param>
            <remarks>
            Sets <c>NumberOfIterationsDone = <paramref name="numberOfIterations"/></c>.
            This method is equivalent to calling <c>Reset()</c> followed by <c>Update(numberOfIterations)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Update(System.Int32)">
            <summary>
            Perform additional iterations of the inference algorithm
            </summary>
            <param name="additionalIterations">The number of additional iterations to perform</param>
            <remarks>
            If no observed values have changed, this method increments <c>NumberOfIterationsDone</c> by <paramref name="additionalIterations"/>,
            and is equivalent to calling <c>Execute(NumberOfIterationsDone + additionalIterations)</c>.
            If some observed values have changed, this method sets <c>NumberOfIterationsDone = <paramref name="additionalIterations"/></c>,
            and is not equivalent to calling <c>Execute</c>, because it will start from the existing message state rather than the initial state.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Reset">
            <summary>
            Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0
            </summary>
            <remarks>
            This method is equivalent to calling <c>Execute(0)</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal(System.String)">
            <summary>
            Get the marginal distribution (computed up to this point) of a variable
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal``1(System.String)">
            <summary>
            Get the marginal distribution (computed up to this point) of a variable, converted to type T
            </summary>
            <typeparam name="T">The distribution type.</typeparam>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            The conversion operation may be costly, even if the marginal already has type T.
            For maximum efficiency, use the non-generic Marginal method when conversion is not needed.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal(System.String,System.String)">
            <summary>
            Get the query-specific marginal distribution of a variable.
            For example, GibbsSampling answers "Marginal", "Samples", and "Conditionals" queries
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="query">Query string</param>
            <returns>The query-specific marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal``1(System.String,System.String)">
            <summary>
            Get the query-specific marginal distribution of a variable, converted to type T
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="query">Query</param>
            <returns>The query-specific marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            The conversion operation may be costly, even if the marginal already has type T.
            For maximum efficiency, use the non-generic Marginal method when conversion is not needed.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.GetObservedValue(System.String)">
            <summary>
            Gets an observed value
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The observed value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.SetObservedValue(System.String,System.Object)">
            <summary>
            Sets an observed value
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="value">The observed value</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.IGeneratedAlgorithm.NumberOfIterationsDone">
            <summary>
            The number of iterations done from the initial state or since the last change of observed values
            </summary>
            <remarks>
            Changing an observed value will reset this to 0.
            </remarks>
        </member>
        <member name="E:MicrosoftResearch.Infer.IGeneratedAlgorithm.ProgressChanged">
            <summary>
            Fired when the progress of inference changes, typically at the
            end of one iteration of the inference algorithm
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabReader">
            <summary>
            Reads the contents of a MAT file.
            </summary>
            <remarks>
            The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.#ctor(System.String)">
            <summary>
            Create a MatlabReader that reads from the given file name.
            </summary>
            <param name="fileName">The MAT file name to read from</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.#ctor(System.IO.Stream)">
            <summary>
            Create a MatlabReader that reads from the given stream.
            </summary>
            <param name="reader">The stream to read from</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Read(System.String)">
            <summary>
            Read all variables from a file and store them in a dictionary
            </summary>
            <param name="fileName">The name of a MAT file</param>
            <returns>A dictionary that maps variable names into values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadAll">
            <summary>
            Read all variables from the current stream and store them in a dictionary
            </summary>
            <returns>A dictionary that maps variable names into values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Matlab5DataElement(System.String@)">
            <summary>
            Read the next data element from the stream
            </summary>
            <param name="name">On exit, the variable name</param>
            <returns>The data value, as a .NET object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.RemoveRfc1950Header(System.Byte[])">
            <summary>
            Removes the header defined by <a href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>
            </summary>
            <param name="bytes"></param>
            <returns>A smaller array of bytes</returns>
            <remarks>
            The header to remove is 2 or 6 bytes at the start, and 4 bytes at the end.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Parse(MicrosoftResearch.Infer.Utils.MatType,System.String@)">
            <summary>
            Read a specific data type from the stream
            </summary>
            <param name="dataType">The type number as documented by the MAT format</param>
            <param name="name">On exit, the variable name</param>
            <returns>The data value, as a .NET object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.SizeOf(MicrosoftResearch.Infer.Utils.MatType)">
            <summary>
            Get the size in bytes of a MatType
            </summary>
            <param name="type"></param>
            <returns>Number of bytes</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Matlab5Header">
            <summary>
            Read a MAT file header from the stream
            </summary>
            <returns>The header as a string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt">
            <summary>
            Read a 32-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt">
            <summary>
            Read an unsigned 32-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt16">
            <summary>
            Read a 16-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt16">
            <summary>
            Read an unsigned 16-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt64">
            <summary>
            Read a 64-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt64">
            <summary>
            Read an unsigned 64-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadSingle">
            <summary>
            Read a single-precision float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadDouble">
            <summary>
            Read a double-precision float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadString(System.Int32)">
            <summary>
            Read a string of known length from the stream
            </summary>
            <param name="length">The number of bytes in the string</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ParseString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an array of bytes into a string
            </summary>
            <param name="bytes">The bytes</param>
            <param name="start">The position of the first character in the string</param>
            <param name="length">An upper bound on the length of the string</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Dispose">
            <summary>
            Release the stream used by this MatlabReader
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabReader.ComplexMatrix">
            <summary>
            Represents a matrix of complex numbers, when reading and writing MAT files.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabWriter">
            <summary>
            Write data objects to a MAT file
            </summary>
            <remarks>
            The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.#ctor(System.String)">
            <summary>
            Create a MatlabWriter to write to a given file name.
            </summary>
            <param name="fileName">The file name to write to (will be created if missing, or truncated if already exists)</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.Byte[])">
            <summary>
            Write an array of bytes to the stream
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Int32)">
            <summary>
            Write a string value with zero padding to write numBytes in total.
            </summary>
            <param name="value"></param>
            <param name="numBytes"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Object)">
            <summary>
            Write a named object to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Write a named bool array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Write a named int array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Double)">
            <summary>
            Write a named scalar to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Double})">
            <summary>
            Write a named vector to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write``1(System.String,System.Collections.Generic.IList{``0})">
            <summary>
            Write a named cell vector to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Write a named Matrix to the stream
            </summary>
            <param name="name">Name of the matrix.</param>
            <param name="matrix">A matrix.</param>
            <param name="imaginary">If writing a complex matrix, the imaginary part of the matrix.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,MicrosoftResearch.Infer.Utils.MatlabReader.ComplexMatrix)">
            <summary>
            Write a named ComplexMatrix to the stream
            </summary>
            <param name="name"></param>
            <param name="matrix"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Write a named struct to the stream
            </summary>
            <param name="name"></param>
            <param name="dict"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.WriteArray(System.String,System.Array)">
            <summary>
            Write a named array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Object[0:,0:])">
            <summary>
            Write a named cell array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.String)">
            <summary>
            Write a named string to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.MakeValidVariableName(System.String)">
            <summary>
            Converts a variable name to a valid variable name by changing all invalid characters to an underscore.
            </summary>
            <param name="name">Variable name</param>
            <returns>A valid MATLAB variable name.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Matlab5Header(System.String)">
            <summary>
            Generate a Matlab V5 compatible header byte array
            </summary>
            <param name="comments">The comments that will go into the header of the Matlab file.</param>
            <returns>The header as a byte array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Dispose">
            <summary>
            Release the stream used by a MatlabWriter
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatType">
            <summary>
            A number type in a MAT file
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.mxClass">
            <summary>
            An object class in a MAT file
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2">
            <summary>
            A multidimensional array of objects where each field is in a CursorArray.
            </summary>
            <typeparam name="CursorType"></typeparam>
            <typeparam name="ArrayType">A cursor-based array type, such as CursorArray or ParallelCursorArray.</typeparam>
            <remarks><para>
            A ParallelCursorArray is meant to behave like an ordinary Array, while 
            being more memory-efficient.  It uses a cursor similar to a CursorArray.
            However, the storage layout is different.  Each field of the cursor
            is stored in a separate ICursorArray, with its own inner cursor.
            By advancing these inner cursors, the outer cursor is automatically
            updated.  Thus <typeparamref name="CursorType"/> does not need to implement <c>ICursor</c>.
            For example, <typeparamref name="CursorType"/> might be <c>Array&lt;ICursor&gt;</c>, holding an array of  
            inner cursors.
            </para><para>
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </para></remarks>
            <example>See CursorArrayTest.cs.</example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2.#ctor(`0,System.Collections.Generic.IList{`1})">
            <summary>
            Create a new ParallelCursorArray.
            </summary>
            <param name="cursor">An object to use as the cursor.</param>
            <param name="members">A list of cursor-based arrays.</param>
            <remarks>
            <paramref name="cursor"/> must already be initialized to contain
            the cursors of the arrays in <paramref name="members"/>.
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.PriorityQueue`1">
            <summary>
            A collection that provides efficient extraction of the minimum element.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},System.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Add(`0)">
            <summary>
            Add a new item to the queue.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add several new items to the queue.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Changed(System.Int32)">
            <summary>
            Reposition node i to restore the heap property.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftUp(System.Int32)">
            <summary>
            Move Items[i] upward until it is greater than or equal to its parent.
            </summary>
            <param name="i">An index into Items.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftDown(System.Int32)">
            <summary>
            Move Items[i] downward until it is less than or equal to its children.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftAll">
            <summary>
            Rearrange all items to satisfy the heap property.
            </summary>
        </member>
        <member name="E:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Moved">
            <summary>
            Raised when an item has changed position.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.QueryType">
            <summary>
            Type of inference query
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QueryType.Name">
            <summary>
            Name of the query type
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.NonSerializedPropertyAttribute">
            <summary>
            Attribute that can be attached to properties to signal
            that the property should not be serialised
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.ConstructionAttribute">
            <summary>
            Attribute that can be attached to a constructor or factory method, to provide information about
            how to set the parameters of the constructor/method to copy an instance of the object.
            For example, it can indicate that the parameters correspond to properties of the object.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.TargetMember">
            <summary>
            The construction method
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.paramMembers">
            <summary>
            The methods/properties to call to get constructor parameters.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.ConstructionAttribute.GetParamValue(System.Int32,System.Object,System.Type@)">
            <summary>
            Gets the value of the constructor parameter at the given index needed to
            reconstruct the supplied instance.
            </summary>
            <param name="instance">The instance</param>
            <param name="paramIndex">The parameter index</param>
            <param name="type">Type of the parameter (output)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.ConstructionAttribute.IsApplicable(System.Object)">
            <summary>
            Whether this construction attribute should be used for the supplied instance.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.cache">
            <summary>
            Cache of construction attributes
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.ConstructionAttribute.Params">
            <summary>
            The names of the properties, fields or methods to call on an object instance
            to get parameter values to construct a duplicate of that instance.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.ConstructionAttribute.UseWhen">
            <summary>
            The name of a boolean property or method on the object instance which
            indicates when this construction method should be used.
            </summary>
            <remarks>
            There are often special case constructors or factory methods which apply
            when an object is in a particular state e.g. when a distribution is uniform.  
            This parameter allows a constructor to be used only when the object is in
            a state, as indicated by a bool property or method e.g. IsUniform().
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Set`1">
            <summary>
            A collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a Dictionary that ensures uniqueness
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains all items in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`2">
            <summary>
            Supports setting an instance to the ratio of
            two values of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToRatio`2.SetToRatio(`0,`1,System.Boolean)">
            <summary>
            Set this to the ratio of a and b
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper">If true, the result is modified to have parameters in a safe range</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`1">
            <summary>
            Supports setting an instance to the ratio of
            two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToWeightedSumExact`1">
            <summary>
            Indicates that a distribution can represent weighted sum
            of distributions of type <typeparamref name="T"/> exactly.
            </summary>
            <typeparam name="T">The type of the distributions which sum can be represented exactly.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Diffable">
            <summary>
            Supports calculating the maximum difference between
            this instance and another object (not necessarily of the same type)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Diffable.MaxDiff(System.Object)">
            <summary>
            The maximum difference between this instance and the given
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SortedSet`1">
            <summary>
            A sorted collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A sorted collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a SortedList, which does the sorting
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Util">
            <summary>
            Helpful methods used throughout the library.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.SetToProduct``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Set result to the product of all items in list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="list">Must have Count > 1.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.CreateArray``1(System.Int32[])">
            <summary>
            Like <see cref="M:System.Array.CreateInstance(System.Type,System.Int32[])"/> but 5x faster.
            </summary>
            <typeparam name="T">Array element type.</typeparam>
            <param name="lengths"></param>
            <returns>A new array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.ChangeElementType(System.Type,System.Type)">
            <summary>
            Change the element type of an array type to another type.
            </summary>
            <param name="arrayType">A scalar, array, multidimensional array, or nested array type.</param>
            <param name="newElementType">Any type.</param>
            <returns>A type with the same structure as <paramref name="arrayType"/> but whose element type is <paramref name="newElementType"/></returns>
            <remarks>
            For example, <c>ChangeElementType(typeof(int[,][]), typeof(double))</c> returns
            <c>typeof(double[,][])</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.GetInnermostElementType(System.Type)">
            <summary>
            Gets the innermost array element type of a given array type.
            </summary>
            <param name="arrayType">The array type.</param>
            <remarks>If the type is not an array, result will be the type itself.</remarks>
            <returns>The innermost array element type.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.GetArrayDepth(System.Type,System.Type)">
            <summary>
            The number of indexing brackets needed to turn arrayType into innermostElementType.
            </summary>
            <param name="arrayType"></param>
            <param name="innermostElementType"></param>
            <returns>An integer between 0 and the full depth of arrayType.</returns>
            <remarks>
            For example, if <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int</c>, the
            result is 2. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[]</c>, the
            result is 1. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[][]</c>, the
            result is 0. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.IArrayFromFunc``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Create an implicit array that calls a delegate whenever an element is read
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="length">The length of the array</param>
            <param name="getItem">The delegate to call on every element read</param>
            <returns>An IArray</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.IArrayFromFunc``1(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Create an implicit 2D array that calls a delegate whenever an element is read
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="length0">The length of the first dimension</param>
            <param name="length1">The length of the second dimension</param>
            <param name="getItem">The delegate to call on every element read</param>
            <returns>An IArray2D</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.CloneInnerException(System.Reflection.TargetInvocationException)">
            <summary>
            Returns a copy of the inner exception of a target invocation exception, preserving the original stack trace.
            </summary>
            <param name="tie"></param>
            <returns>A new Exception</returns>
            <remarks>
            The original stack trace is stored in the InnerException of the returned exception.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.SchemaProvider(System.Xml.Schema.XmlSchemaSet,System.Type,System.Func{System.Xml.Schema.XmlSchemaSet,System.Xml.XmlQualifiedName})">
            <summary>
            Add a schema describing a type to an XmlSchemaSet (for use with XmlSchemaProviderAttribute)
            </summary>
            <param name="xs"></param>
            <param name="type">The name of the XML type to create</param>
            <param name="baseProvider">The SchemaProvider of the base type, if any</param>
            <returns>The qualified name of the XML type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.WriteTypeAttribute(System.Xml.XmlWriter,System.Type)">
            <summary>
            Write attributes describing the type being serialized (for use in ISerializable.WriteXml)
            </summary>
            <param name="writer"></param>
            <param name="type">The type being serialized</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.Swap``1(``0@,``0@)">
            <summary>
            Swaps the values of two given variables.
            </summary>
            <typeparam name="T">The type of the variables.</typeparam>
            <param name="value1">The first variable passed by reference.</param>
            <param name="value2">The second variable passed by reference.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.GetMaxKValues``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the maximum k values from an enumerable (by using a heap).
            </summary>
            <typeparam name="T">The type of an element in the enumerable.</typeparam>
            <param name="values">The enumerable of values.</param>
            <param name="k">The number of values to get.</param>
            <param name="comparer">The comparer to use for ordering.</param>
            <returns>The list of the maximum k values.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.XmlWriterExtensions">
            <summary>
            Provides extension methods for <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.XmlWriterExtensions.WriteFormatString(System.Xml.XmlWriter,System.String,System.Object[])">
            <summary>
            Writes a given text specified via a format string.
            </summary>
            <param name="writer">The writer.</param>
            <param name="format">The format string.</param>
            <param name="args">The format string arguments.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.XmlWriterExtensions.WriteElementFormatString(System.Xml.XmlWriter,System.String,System.String,System.Object[])">
            <summary>
            Writes an element with the specified name and value. The value is specified via a format string.
            </summary>
            <param name="writer">The writer.</param>
            <param name="elementName">The name of the element.</param>
            <param name="format">The value format string.</param>
            <param name="args">The value format string arguments.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.XmlWriterExtensions.WriteElementAttributeString(System.Xml.XmlWriter,System.String,System.String,System.String)">
            <summary>
            Writes an element with the specified name and a single attribute with the specified name and value.
            </summary>
            <param name="writer">The writer.</param>
            <param name="elementName">The name of the element.</param>
            <param name="attributeName">The name of the attribute.</param>
            <param name="attributeValue">The value of the attribute.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath">
            <summary>
            Contains math routines extensively used in weighted automata library.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)">
            <summary>
            Computes the sum of a given geometric series <c>1 + r + r^2 + r^3 + ...</c> in the log-domain.
            </summary>
            <param name="logValue">The logarithm of the common ratio (<c>r</c>) of the series.</param>
            <returns>The computed sum, or <see cref="F:System.Double.PositiveInfinity"/> if the sum diverges.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)">
            <summary>
            Computes the sum of a given geometric series <c>1 + r + r^2 + r^3 + ...</c> in the log-domain.
            If the sum diverges, replaces the infinite sum by a finite sum with a lot of terms.
            </summary>
            <param name="logValue">The logarithm of the common ratio (<c>r</c>) of the series.</param>
            <returns>The computed sum.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5">
            <content>
            Contains the class used to represent a condensation of the automaton graph.
            </content>
            <summary>
            Abstract base class for a weighted finite state automaton.
            It can be viewed as a function that maps arbitrary sequences of elements to real values.
            </summary>
            <remarks>
            <para>
            An automaton represented by this class has the following properties:
            - Its states and transitions form a directed graph rooted at the <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Start"/>;
            - Each state has an associated cost for being an accepting ("end") state;
            - Each transition has an associated cost for using it;
            - A transition can have an associated distribution over elements. In that case an additional cost is being
              paid for using that transition with a specific element. The cost is equal to the log-probability of that element
              under the distribution;
            - If a transition doesn't have an associated distribution over elements, it is an epsilon transition
              which can be used with no element only.
            </para>
            </remarks>
            <typeparam name="TSequence">The type of a sequence.</typeparam>
            <typeparam name="TElement">The type of a sequence element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over sequence elements.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate sequences.</typeparam>
            <typeparam name="TThis">The type of a concrete automaton class.</typeparam>
            <content>
            Contains the class used to represent the epsilon closure of a state of an automaton.
            </content>
            <content>
            Contains classes and methods for automata simplification.
            </content>
            <content>
            Contains the class used to represent a state of an automaton.
            </content>
            <content>
            Contains the class used to represent the condensation of an automaton graph.
            </content>
            <content>
            Contains the class used to represent a transition in an automaton.
            </content>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ComputeCondensation(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Computes a condensation of the underlying automaton graph.
            </summary>
            <param name="root">The root of the condensation.</param>
            <returns>The computed condensation.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ComputeCondensation(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Func{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition,System.Boolean},System.Boolean)">
            <summary>
            Computes a condensation of the underlying automaton graph.
            </summary>
            <param name="root">The root of the condensation.</param>
            <param name="transitionFilter">
            A function specifying whether the transition should be treated as an edge
            of the automaton graph while building the condensation.
            </param>
            <param name="useApproximateClosure">
            Specifies whether <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)"/> should be used
            instead of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)"/> in semiring computations.
            </param>
            <returns>The computed condensation.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.maxStateCount">
            <summary>
            The maximum number of states an automaton can have.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.maxStateCountBeforeSimplification">
            <summary>
            The maximum number of states an automaton can have
            before an attempt to simplify it will be made.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.states">
            <summary>
            The collection of states.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.statesReadOnly">
            <summary>
            A read-only wrapper around the <see cref="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.states"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.startState">
            <summary>
            The start state.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.isDefinitelyEpsilonFree">
            <summary>
            Whether the automaton is known to be free of epsilon transition.
            If the value of this field is false, it means that the presence of epsilon transitions is unknown.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5"/>
            class by setting it to be zero everywhere.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.FromStates(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State},MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Creates an automaton from a given array of states and a start state.
            Used by quoting to embed automata in the generated inference code.
            </summary>
            <remarks>
            Only the index of the <paramref name="startState"/> will be used to determine the start state,
            not the object itself.
            </remarks>
            <param name="states">The array of states.</param>
            <param name="startState">The start state.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Zero">
            <summary>
            Creates an automaton which maps every sequence to zero.
            </summary>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Constant(System.Double)">
            <summary>
            Creates an automaton which maps every sequence to a given value.
            </summary>
            <param name="value">The value to map every sequence to.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Constant(System.Double,`2)">
            <summary>
            Creates an automaton which maps every allowed sequence to a given value and maps all other sequences to zero.
            A sequence is allowed if all its elements have non-zero probability under a given distribution.
            </summary>
            <param name="value">The value to map every sequence to.</param>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantLog(System.Double)">
            <summary>
            Creates an automaton which maps every sequence to a given value.
            </summary>
            <param name="logValue">The logarithm of the value to map every sequence to.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantLog(System.Double,`2)">
            <summary>
            Creates an automaton which maps every allowed sequence to a given value and maps all other sequences to zero.
            A sequence is allowed if all its elements have non-zero probability under a given distribution.
            </summary>
            <param name="logValue">The logarithm of the value to map every sequence to.</param>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnElementLog(System.Double,`1)">
            <summary>
            Creates an automaton which has a given value on the sequence consisting of a given element only
            and is zero everywhere else.
            </summary>
            <param name="logValue">The logarithm of the value of the automaton on the sequence consisting of the given element only.</param>
            <param name="element">The element.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnElementLog(System.Double,`2)">
            <summary>
            Creates an automaton which has a given value on the sequence consisting of a single element from a set of allowed elements
            and is zero everywhere else. An element is allowed if it has non-zero probability under a given distribution.
            </summary>
            <param name="logValue">The logarithm of the value of the automaton on the sequence consisting of the given element only.</param>
            <param name="allowedElements">The distribution representing allowed elements.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnLog(System.Double,`0)">
            <summary>
            Creates an automaton which has a given value on a given sequence and is zero everywhere else.
            </summary>
            <param name="logValue">The logarithm of the value of the automaton on the given sequence.</param>
            <param name="sequence">The sequence.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnLog(System.Double,`0[])">
            <summary>
            Creates an automaton which has a given value on given sequences and is zero everywhere else.
            </summary>
            <param name="logValue">The logarithm of the value of the automaton on the given sequences.</param>
            <param name="sequences">The sequences.</param>
            <remarks>
            If the same sequence is specified multiple times, the value of the created automaton on that sequence
            will be scaled by the number of the sequence occurrences.
            </remarks>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnLog(System.Double,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates an automaton which has a given value on given sequences and is zero everywhere else.
            </summary>
            <param name="logValue">The logarithm of the value of the automaton on the given sequences.</param>
            <param name="sequences">The sequences.</param>
            <remarks>
            If the same sequence is specified multiple times, the value of the created automaton on that sequence
            will be scaled by the number of the sequence occurrences.
            </remarks>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnElement(System.Double,`1)">
            <summary>
            Creates an automaton which has a given value on the sequence consisting of a given element only
            and is zero everywhere else.
            </summary>
            <param name="value">The value of the automaton on the sequence consisting of the given element only.</param>
            <param name="element">The element.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOnElement(System.Double,`2)">
            <summary>
            Creates an automaton which has a given value on the sequence consisting of a single element from a set of allowed elements
            and is zero everywhere else. An element is allowed if it has non-zero probability under a given distribution.
            </summary>
            <param name="value">The value of the automaton on the sequence consisting of the given element only.</param>
            <param name="allowedElements">The distribution representing allowed elements.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOn(System.Double,`0)">
            <summary>
            Creates an automaton which has a given value on a given sequence and is zero everywhere else.
            </summary>
            <param name="value">The value of the automaton on the given sequence.</param>
            <param name="sequence">The sequence.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOn(System.Double,`0[])">
            <summary>
            Creates an automaton which has a given value on given sequences and is zero everywhere else.
            </summary>
            <param name="value">The value of the automaton on the given sequences.</param>
            <param name="sequences">The sequences.</param>
            <remarks>
            If the same sequence is specified multiple times, the value of the created automaton on that sequence
            will be scaled by the number of the sequence occurrences.
            </remarks>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ConstantOn(System.Double,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates an automaton which has a given value on given sequences and is zero everywhere else.
            </summary>
            <param name="value">The value of the automaton on the given sequences.</param>
            <param name="sequences">The sequences.</param>
            <remarks>
            If the same sequence is specified multiple times, the value of the created automaton on that sequence
            will be scaled by the number of the sequence occurrences.
            </remarks>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.WeightedSum(System.Double,`4,System.Double,`4)">
            <summary>
            Creates an automaton which is a weighted sum of a given pair of automata.
            </summary>
            <param name="weight1">The weight of the first automaton.</param>
            <param name="automaton1">The first automaton.</param>
            <param name="weight2">The weight of the second automaton.</param>
            <param name="automaton2">The second automaton.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.WeightedSumLog(System.Double,`4,System.Double,`4)">
            <summary>
            Creates an automaton which is a weighted sum of a given pair of automata.
            </summary>
            <param name="logWeight1">The logarithm of the weight of the first automaton.</param>
            <param name="automaton1">The first automaton.</param>
            <param name="logWeight2">The logarithm of the weight of the second automaton.</param>
            <param name="automaton2">The second automaton.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Sum(`4[])">
            <summary>
            Creates an automaton which is a sum of given automata.
            </summary>
            <param name="automata">The automata to sum.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Sum(System.Collections.Generic.IEnumerable{`4})">
            <summary>
            Creates an automaton which is a sum of given automata.
            </summary>
            <param name="automata">The automata to sum.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.FromValues(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Double}})">
            <summary>
            Creates an automaton which has given values on given sequences and is zero everywhere else.
            </summary>
            <param name="sequenceToValue">The collection of pairs of a sequence and the automaton value on that sequence.</param>
            <remarks>
            If the same sequence is presented in the collection of pairs multiple times,
            the value of the automaton on that sequence will be equal to the sum of the values in the collection.
            </remarks>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Repeat(`4,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates an automaton <c>g(s) = sum_k v(k) sum_{t1 t2 ... tk = s} f(t1)f(t2)...f(tk)</c>,
            where <c>f(t)</c> is the given automaton, and <c>v(k)</c> is a weight function given as a vector.
            </summary>
            <param name="automaton">The automaton.</param>
            <param name="repetitionNumberWeights">The weight vector.</param>
            <returns>The created automaton.</returns>
            <remarks>
            The result is a weighted sum of Cauchy products of the given automaton with itself,
            each product having a different number of factors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Repeat(`4,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates an automaton <c>g(s) = sum_{k=Kmin}^{Kmax} sum_{t1 t2 ... tk = s} f(t1)f(t2)...f(tk)</c>,
            where <c>f(t)</c> is the given automaton, and <c>Kmin</c> and <c>Kmax</c> are the minimum
            and the maximum number of factors in a sum term.
            </summary>
            <param name="automaton">The automaton.</param>
            <param name="minTimes">The minimum number of factors in a sum term. Defaults to 1.</param>
            <param name="maxTimes">An optional maximum number of factors in a sum term.</param>
            <returns>The created automaton.</returns>
            <remarks>
            The result is the sum of Cauchy products of the given automaton with itself,
            each product having a different number of factors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ToString">
            <summary>
            Returns a string that represents the automaton.
            </summary>
            <returns>A string that represents the automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ToString(MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat)">
            <summary>
            Returns a string that represents the automaton.
            </summary>
            <param name="format">The format.</param>
            <returns>A string that represents the automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetLogNormalizer">
            <summary>
            Computes the logarithm of the normalizer (sum of values of the automaton on all sequences).
            </summary>
            <returns>The logarithm of the normalizer.</returns>
            <remarks>Returns <see cref="F:System.Double.PositiveInfinity"/> if the sum diverges.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.NormalizeValues">
            <summary>
            Normalizes the automaton so that the sum of its values over all possible sequences equals to one
            and returns the logarithm of the normalizer.
            </summary>
            <returns>The logarithm of the normalizer.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the automaton cannot be normalized (i.e. if the normalizer is zero or positive infinity).</exception>
            <remarks>The only automaton which cannot be normalized, but has a finite normalizer, is zero.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.TryNormalizeValues(System.Double@)">
            <summary>
            Attempts to normalize the automaton so that sum of its values on all possible sequences equals to one (if it is possible).
            </summary>
            <param name="logNormalizer">When the function returns, contains the logarithm of the normalizer.</param>
            <returns><see langword="true"/> if the automaton was successfully normalized, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.TryNormalizeValues">
            <summary>
            Attempts to normalize the automaton so that sum of its values on all possible sequences equals to one (if it is possible).
            </summary>
            <returns><see langword="true"/> if the automaton was successfully normalized, <see langword="false"/> otherwise.</returns>>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.IsZero">
            <summary>
            Checks whether the automaton is zero on all sequences.
            </summary>
            <returns>
            <see langword="true"/> if the automaton is zero on all sequences,
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            The time complexity of this function is not constant,
            so it should not be used when treating zero specially for performance reasons.
            Use <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.IsCanonicZero"/> instead.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.IsCanonicZero">
            <summary>
            Checks whether the automaton is a canonic representation of zero,
            as produced by <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToZero"/> and <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Zero"/>.
            </summary>
            <returns>
            <see langword="true"/> if the automaton is a canonic representation of zero,
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            The time complexity of this function is O(1), so it can be used to treat zero specially in performance-critical code.
            All the operations on automata resulting in zero produce the canonic representation.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.HasNonTrivialLoops">
            <summary>
            Checks whether the automaton has non-trivial loops (i.e. loops consisting of more than one edge).
            </summary>
            <returns>
            <see langword="true"/> if the automaton has non-trivial loops,
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Clone">
            <summary>
            Creates a copy of the automaton.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Append(`0,System.Byte)">
            <summary>
            Creates an automaton <c>f'(st) = f(s)</c>, where <c>f(s)</c> is the current automaton
            and <c>t</c> is the given sequence.
            </summary>
            <param name="sequence">The sequence.</param>
            <param name="group">The group.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Append(`4,System.Byte)">
            <summary>
            Creates an automaton <c>f'(s) = sum_{tu=s} f(t)g(u)</c>, where <c>f(t)</c> is the current automaton
            and <c>g(u)</c> is the given automaton.
            The resulting automaton is also known as the Cauchy product of two automata.
            </summary>
            <param name="automaton">The automaton to append.</param>
            <param name="group">The group.</param>
            <returns>The created automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AppendInPlace(`0,System.Byte)">
            <summary>
            Replaces the current automaton with an automaton <c>f'(st) = f(s)</c>, where <c>f(s)</c> is the current automaton
            and <c>t</c> is the given sequence.
            </summary>
            <param name="sequence">The sequence.</param>
            <param name="group">The group.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AppendInPlace(`4,System.Byte)">
            <summary>
            Replaces the current automaton with an automaton <c>f'(s) = sum_{tu=s} f(t)g(u)</c>,
            where <c>f(t)</c> is the current automaton and <c>g(u)</c> is the given automaton.
            The resulting automaton is also known as the Cauchy product of two automata.
            </summary>
            <param name="automaton">The automaton to append.</param>
            <param name="group">The group.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Product(`4)">
            <summary>
            Computes the product of the current automaton and a given one.
            </summary>
            <param name="automaton">The automaton to compute the product with.</param>
            <returns>The computed product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToProduct(`4,`4)">
            <summary>
            Replaces the current automaton by the product of a given pair of automata.
            </summary>
            <param name="automaton1">The first automaton.</param>
            <param name="automaton2">The second automaton.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Sum(`4)">
            <summary>
            Computes the sum of the current automaton and a given automaton.
            </summary>
            <param name="automaton">The automaton to compute the sum with.</param>
            <returns>The computed sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToSum(System.Double,`4,System.Double,`4)">
            <summary>
            Replaces the current automaton by the weighted sum of a given pair of automata.
            </summary>
            <param name="weight1">The weight of the first automaton.</param>
            <param name="automaton1">The first automaton.</param>
            <param name="weight2">The weight of the second automaton.</param>
            <param name="automaton2">The second automaton.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToSumLog(System.Double,`4,System.Double,`4)">
            <summary>
            Replaces the current automaton by the weighted sum of a given pair of automata.
            </summary>
            <param name="logWeight1">The logarithm of the weight of the first automaton.</param>
            <param name="automaton1">The first automaton.</param>
            <param name="logWeight2">The logarithm of the weight of the second automaton.</param>
            <param name="automaton2">The second automaton.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Scale(System.Double)">
            <summary>
            Scales the automaton and returns the result.
            </summary>
            <param name="scale">The scale.</param>
            <returns>The scaled automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ScaleLog(System.Double)">
            <summary>
            Scales the automaton and returns the result.
            </summary>
            <param name="logScale">The logarithm of the scale.</param>
            <returns>The scaled automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToScale(`4,System.Double)">
            <summary>
            Replaces the current automaton with a given automaton scaled by a given value.
            </summary>
            <param name="automaton">The automaton to scale.</param>
            <param name="scale">The scale.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToScaleLog(`4,System.Double)">
            <summary>
            Replaces the current automaton with a given automaton scaled by a given value.
            </summary>
            <param name="automaton">The automaton to scale.</param>
            <param name="logScale">The logarithm of the scale.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToZero">
            <summary>
            Replaces the current automaton with an automaton which is zero everywhere.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToConstant(System.Double)">
            <summary>
            Replaces the current automaton with an automaton which maps every sequence to a given value.
            </summary>
            <param name="value">The value to map every sequence to.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToConstant(System.Double,`2)">
            <summary>
            Replaces the current automaton with an automaton which maps every allowed sequence to
            a given value and maps all other sequences to zero.
            A sequence is allowed if all its elements have non-zero probability under a given distribution.
            </summary>
            <param name="value">The value to map every sequence to.</param>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToConstantLog(System.Double)">
            <summary>
            Replaces the current automaton with an automaton which maps every sequence to a given value.
            </summary>
            <param name="logValue">The logarithm of the value to map every sequence to.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToConstantLog(System.Double,`2)">
            <summary>
            Replaces the current automaton with an automaton which maps every allowed sequence to
            a given value and maps all other sequences to zero.
            A sequence is allowed if all its elements have non-zero probability under a given distribution.
            </summary>
            <param name="logValue">The logarithm of the value to map every sequence to.</param>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetTo(`4)">
            <summary>
            Replaces the current automaton with a copy of a given automaton.
            </summary>
            <param name="automaton">The automaton to replace the current automaton with.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToFunction``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4},System.Func{``2,System.Byte,`2})">
            <summary>
            Replaces the current automaton by an automaton obtained by performing a transition transformation
            on a source automaton.
            </summary>
            <typeparam name="TSrcSequence">The type of a source automaton sequence.</typeparam>
            <typeparam name="TSrcElement">The type of a source automaton sequence element.</typeparam>
            <typeparam name="TSrcElementDistribution">The type of a distribution over source automaton sequence elements.</typeparam>
            <typeparam name="TSrcSequenceManipulator">The type providing ways to manipulate source automaton sequences.</typeparam>
            <typeparam name="TSrcAutomaton">The type of a source automaton.</typeparam>
            <param name="sourceAutomaton">The source automaton.</param>
            <param name="transitionTransform">The transition transformation.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetLogValue(`0)">
            <summary>
            Computes the logarithm of the value of the automaton on a given sequence.
            </summary>
            <param name="sequence">The sequence to compute the value on.</param>
            <returns>The logarithm of the value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetValue(`0)">
            <summary>
            Computes the value of the automaton on a given sequence.
            </summary>
            <param name="sequence">The sequence to compute the value on.</param>
            <returns>The computed value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.TryComputePoint">
            <summary>
            Attempts to find the only sequence which has non-zero value under the automaton.
            </summary>
            <returns>
            The only sequence having non-zero value, if found.
            <see langword="null"/>, if the automaton is zero everywhere or is non-zero on more than one sequence.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Equals(System.Object)">
            <summary>
            Checks if <paramref name="obj"/> is an automaton that defines the same weighted regular language.
            </summary>
            <param name="obj">The object to compare this automaton with.</param>
            <returns><see langword="true"/> if this automaton is equal to <paramref name="obj"/>, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetHashCode">
            <summary>
            Gets the hash code of this automaton.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetStates">
            <summary>
            Creates a deep copy of the state collection. Used by quoting.
            </summary>
            <returns>The created state collection copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AddState">
            <summary>
            Adds a new state to the automaton.
            </summary>
            <returns>The added state.</returns>
            <remarks>Indices of the added states are guaranteed to be increasing consecutive.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AddStates(System.Int32)">
            <summary>
            Adds a given number of states to the automaton.
            </summary>
            <param name="stateCount">The number of states to add.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.MakeEpsilonFree">
            <summary>
            Replaces the current automaton with an equal automaton that has no epsilon transitions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetToEpsilonClosureOf(`4)">
            <summary>
            Replaces the current automaton with an epsilon closure of a given automaton.
            </summary>
            <remarks>
            The resulting automaton will be equal to the given one, but may have a simpler structure.
            </remarks>
            <param name="automaton">The automaton which epsilon closure will be used to replace the current automaton.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetLogSimilarity(`4,`4)">
            <summary>
            Gets a value indicating how close two given automata are
            in terms of values they assign to sequences.
            </summary>
            <param name="automaton1">The first automaton.</param>
            <param name="automaton2">The second automaton.</param>
            <returns>A non-negative value, which is close to zero if the two automata assign similar values to all sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GetConverger(`4[])">
            <summary>
            Gets an automaton such that every given automaton, if multiplied by it, becomes normalizable.
            </summary>
            <param name="automata">The automata.</param>
            <returns>An automaton, product with which will make every given automaton normalizable.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.CheckStateConsistency(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State},MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Checks if indices assigned to given states and their transitions are consistent with each other.
            </summary>
            <param name="states">The collection of states to check.</param>
            <param name="startState">The start state to check.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelReachableNodesDfs(System.Int32,System.Boolean[],System.Int32[],System.Int32[])">
            <summary>
            Performs depth-first traversal of a given graph.
            </summary>
            <param name="currentVertex">The index of the currently traversed vertex.</param>
            <param name="visitedVertices">An array to keep track of the visited vertices.</param>
            <param name="edgeDestinationIndices">An array containing destination indices of the graph edges.</param>
            <param name="edgeArrayStarts">An array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AppendInPlaceNoOptimizations(`4)">
            <summary>
            A version of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AppendInPlace(`4,System.Byte)"/> that is guaranteed to preserve
            the states of both the original automaton and the automaton being appended in the result.
            </summary>
            <param name="automaton">The automaton to append.</param>
            <remarks>
            Useful for implementing functions like <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Repeat(`4,MicrosoftResearch.Infer.Maths.Vector)"/>,
            where on-the-fly result optimization creates unnecessary complications.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.ComputeEndStateReachability">
            <summary>
            For each state computes whether any state with non-zero ending weight can be reached from it.
            </summary>
            <returns>An array mapping state indices to end state reachability.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.DoGetLogNormalizer(System.Boolean)">
            <summary>
            Computes the logarithm of the normalizer of the automaton, normalizing it afterwards if requested.
            </summary>
            <param name="normalize">Specifies whether the automaton must be normalized after computing the normalizer.</param>
            <returns>The logarithm of the normalizer.</returns>
            <remarks>The automaton is normalized only if the normalizer has a finite non-zero value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.PushWeights(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Condensation)">
            <summary>
            Re-distributes weights of the states and transitions so that the underlying automaton becomes stochastic
            (i.e. sum of weights of all the outgoing transitions and the ending weight is 1 for every node).
            </summary>
            <param name="condensation">A condensation of the automaton.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.TryComputePointDfs(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Int32,MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Int32},System.Boolean[],System.Collections.Generic.List{`1},System.Nullable{System.Int32}@)">
            <summary>
            Recursively looks for the only sequence which has non-zero value under the automaton.
            </summary>
            <param name="currentState">The state currently being traversed.</param>
            <param name="currentSequencePos">The current position in the sequence.</param>
            <param name="stateSequencePosCache">A lookup table for memoization.</param>
            <param name="isEndNodeReachable">End node reachability table to avoid dead branches.</param>
            <param name="point">The candidate sequence.</param>
            <param name="pointLength">The length of the candidate sequence
            or <see langword="null"/> if the length isn't known yet.</param>
            <returns>
            <see langword="true"/> if the sequence was found, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.BuildProduct(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Distributions.Automata.IntPair,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State})">
            <summary>
            Recursively builds an automaton representing the product of two given automata.
            The second automaton must be epsilon-free.
            </summary>
            <param name="state1">The currently traversed state of the first automaton.</param>
            <param name="state2">The currently traversed state of the second automaton.</param>
            <param name="productStateCache">
            The mapping from a pair of argument state indices to an index of the corresponding product state.
            </param>
            <returns>The index of the product state corresponding to the given pair of state.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.BuildEpsilonClosure(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,MicrosoftResearch.Infer.Collections.ArrayDictionary{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State})">
            <summary>
            Recursively builds an automaton representing the epsilon closure of a given automaton.
            </summary>
            <param name="state">The currently traversed state of the source automaton.</param>
            <param name="oldToNewState">
            The mapping from the indices of the states of the source automaton to the states of the closure.
            </param>
            <returns>The state representing the closure of <paramref name="state"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SwapWith(`4)">
            <summary>
            Swaps the current automaton with a given one.
            </summary>
            <param name="automaton">The automaton to swap the current one with.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SetStates(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State},System.Int32)">
            <summary>
            Replaces the states of this automaton with a given collection of states.
            </summary>
            <param name="newStates">The states to replace the existing states with.</param>
            <param name="newStartStateIndex">The index of the new start state.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AddStates(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State},System.Byte)">
            <summary>
            Adds the states in a given collection to the automaton together with their transitions,
            but without attaching any of them to any of the existing states.
            </summary>
            <param name="statesToAdd">The states to add.</param>
            <param name="group">The group for the transitions of the states being added.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.RemoveState(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Removes the state with a given index from the automaton.
            </summary>
            <param name="index">The index of the state to remove.</param>
            <param name="replaceIndex">
            If specified, all the transitions to the state being removed
            will be redirected to the state with this index.
            </param>
            <remarks>
            The automaton representation we currently use does not allow for fast state removal.
            Ideally we should get rid of this function completely.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SimplifyIfNeeded">
            <summary>
            Attempts to simplify the automaton using <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Simplify"/> if the number of states
            exceeds <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.MaxStateCountBeforeSimplification"/>.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Simplify">
            <summary>
            Attempts to simplify the structure of the automaton, reducing the number of states and transitions.
            </summary>
            <remarks>
            <para>
            The simplification procedure works as follows:
            <list type="number">
            <item><description>
            If a pair of states has more than one transition between them, the transitions get merged.
            </description></item>
            <item><description>
            A part of the automaton that is a tree is found.
            </description></item>
            <item><description>
            States and transitions that don't belong to the found tree part are simply copied to the result.
            </description></item>
            <item><description>
            The found tree part is rebuild from scratch. The new tree is essentially a trie:
            for example, if the original tree has two paths accepting <c>"abc"</c> and one path accepting <c>"ab"</c>,
            the resulting tree has a single path accepting both <c>"ab"</c> and <c>"abc"</c>.
            </description></item>
            </list>
            </para>
            <para>The simplification procedure doesn't support automata with non-trivial loops.</para>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.RemoveDeadStates">
            <summary>
            Optimizes the automaton by removing all states unreachable from the start state.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification">
            <summary>
            Labels each state with a value indicating whether the automaton having that state as the start state is a
            generalized tree (i.e. a tree with self-loops), which is also unreachable from previously traversed states.
            </summary>
            <returns>A dictionary mapping state indices to the computed labels.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.DoLabelStatesForSimplification(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean})">
            <summary>
            Recursively labels each state with a value indicating whether the automaton having that state as the start state
            is a generalized tree (i.e. a tree with self-loops), which is also unreachable from previously traversed states.
            </summary>
            <param name="currentState">The currently traversed state.</param>
            <param name="stateLabels">A dictionary mapping state indices to the computed labels.</param>
            <returns>
            <see langword="true"/> if the automaton having <paramref name="currentState"/> having that state as the start state
            is a generalized tree and it was the first visit to it, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.MergeParallelTransitions">
            <summary>
            Merges outgoing transitions with the same destination state.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.CopyNonSimplifiable(MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean})">
            <summary>
            Creates a copy of the non-simplifiable part of the automaton (states labeled with
            <see langword="false"/> by <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/> and their children).
            </summary>
            <param name="stateLabels">The state labels obtained from <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/>.</param>
            <returns>The copied part of the automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.DoCopyNonSimplifiable(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean},System.Boolean,MicrosoftResearch.Infer.Collections.ArrayDictionary{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State})">
            <summary>
            Recursively creates a copy of the non-simplifiable part of the automaton
            (states labeled with <see langword="false"/> by <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/>).
            </summary>
            <param name="stateToCopy">The currently traversed state that needs to be copied.</param>
            <param name="stateLabels">The state labels obtained from <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/>.</param>
            <param name="lookAtLabels">Whether or not labels should be ignored because one of the ancestors was labeled with <see langword="false"/>.</param>
            <param name="copiedStateCache">Cache of the state copies to avoid creating redundant states when traversing diamond-like structures.</param>
            <returns>The copied part of the automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.BuildAcceptedSequenceList(MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean})">
            <summary>
            Builds a complete list of generalized sequences accepted by the simplifiable part of the automaton.
            </summary>
            <param name="stateLabels">The state labels obtained from <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/>.</param>
            <returns>The list of generalized sequences accepted by the simplifiable part of the automaton.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.DoBuildAcceptedSequenceList(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean},System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.GeneralizedSequence,System.Double}},System.Collections.Generic.List{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.GeneralizedElement},System.Double)">
            <summary>
            Recursively builds a complete list of generalized sequences accepted by the simplifiable part of the automaton.
            </summary>
            <param name="state">The currently traversed state.</param>
            <param name="stateLabels">The state labels obtained from <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.LabelStatesForSimplification"/>.</param>
            <param name="weightedSequences">The sequence list being built.</param>
            <param name="currentSequenceElements">The list of elements of the sequence currently being built.</param>
            <param name="currentWeight">The weight of the sequence currently being built.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.AddGeneralizedSequence(System.Int32,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.GeneralizedSequence,System.Double)">
            <summary>
            Increases the value of this automaton on <paramref name="sequence"/> by <c>exp(<paramref name="logWeight"/>)</c>.
            </summary>
            <param name="firstAllowedStateIndex">The minimum index of an existing state that can be used for the sequence.</param>
            <param name="sequence">The generalized sequence.</param>
            <param name="logWeight">The logarithm of the weight of the sequence.</param>
            <remarks>
            This function attempts to add as few new states and transitions as possible.
            Its implementation is conceptually similar to adding string to a trie.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.DoAddGeneralizedSequence(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Boolean,System.Boolean,System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.GeneralizedSequence,System.Double)">
            <summary>
            Recursively increases the value of this automaton on <paramref name="sequence"/> by <c>exp(<paramref name="logWeight"/>)</c>.
            </summary>
            <param name="state">The currently traversed state.</param>
            <param name="isNewState">Indicates whether <paramref name="state"/> was just created.</param>
            <param name="selfLoopAlreadyMatched">Indicates whether self-loop on <paramref name="state"/> was just matched.</param>
            <param name="firstAllowedStateIndex">The minimum index of an existing state that can be used for the sequence.</param>
            <param name="currentSequencePos">The current position in the generalized sequence.</param>
            <param name="sequence">The generalized sequence.</param>
            <param name="logWeight">The logarithm of the weight of the sequence.</param>
            <returns>
            <see langword="true"/> if the subsequence starting at <paramref name="currentSequencePos"/> has been successfully merged in,
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            This function attempts to add as few new states and transitions as possible.
            Its implementation is conceptually similar to adding string to a trie.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.SequenceManipulator">
            <summary>
            Gets the sequence manipulator.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.MaxStateCount">
            <summary>
            Gets or sets the maximum number of states an automaton can have.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.MaxStateCountBeforeSimplification">
            <summary>
            Gets or sets the maximum number of states an automaton can have
            before an attempt to simplify it will be made.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.States">
            <summary>
            Gets the collection of the states of the automaton.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Start">
            <summary>
            Gets or sets the start state of the automaton.
            </summary>
            <remarks>
            Only a state from <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.States"/> can be specified as the value of this property. 
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation">
            <summary>
            Represents a <a href="http://en.wikipedia.org/wiki/Condensation_(graph_theory)">condensation</a>
            of the graph of an automaton.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.transitionFilter">
            <summary>
            A function specifying whether the transition should be treated as an edge
            of the automaton graph while building the condensation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.useApproximateClosure">
            <summary>
            Specifies whether <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)"/> should be used
            instead of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)"/> in semiring computations.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.components">
            <summary>
            The list of the strongly connected components of the condensation.
            Components are stored in the reverse topological order.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.stateIdToInfo">
            <summary>
            The dictionary containing information associated with every state of the condensation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.weightsToEndComputed">
            <summary>
            Specifies whether the total weights of all paths starting from the states of the component
            have been computed.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.weightsFromRootComputed">
            <summary>
            Specifies whether the total weights of all paths starting in the root and ending in the states of the component
            have been computed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.#ctor(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Func{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition,System.Boolean},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation"/> class.
            </summary>
            <param name="root">The root of the condensation DAG.</param>
            <param name="transitionFilter">
            A function specifying whether the transition should be treated as an edge
            of the automaton graph while building the condensation.
            </param>
            <param name="useApproximateClosure">
            Specifies whether <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)"/> should be used
            instead of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)"/> in semiring computations.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.GetComponent(System.Int32)">
            <summary>
            Gets the strongly connected component by its index.
            Component indices are assigned in the reverse topological order (i.e. <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.Root"/> is in the last component).
            </summary>
            <param name="index">The index. Must be non-negative and less than <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.ComponentCount"/>.</param>
            <returns>The strongly connected component with the given index.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.GetLogWeightToEnd(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Gets the logarithm of the total weight of all paths starting at a given state. 
            Ending weights are taken into account.
            </summary>
            <param name="state">The state.</param>
            <returns>The logarithm of the computed total weight.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.GetLogWeightFromRoot(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Gets the logarithm of the total weight of all paths starting at the root of the condensation
            and ending in a given state. Ending weights are not taken into account.
            </summary>
            <param name="state">The state.</param>
            <returns>The logarithm of the computed total weight.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.FindStronglyConnectedComponents(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Int32@,System.Collections.Generic.Dictionary{System.Int32,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Condensation.TarjanStateInfo},System.Collections.Generic.Stack{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State})">
            <summary>
            Implements <a href="http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm">Tarjan's algorithm</a>
            for finding the strongly connected components of the automaton graph.
            </summary>
            <param name="currentState">The state currently being traversed.</param>
            <param name="traversalIndex">The traversal index (as defined by the Tarjan's algorithm).</param>
            <param name="stateIdToStateInfo">A dictionary mapping state indices to info records maintained by the Tarjan's algorithm.</param>
            <param name="stateIdStack">The traversal stack (as defined by the Tarjan's algorithm).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.ComputeWeightsToEnd">
            <summary>
            For each state of the component, computes the total weight of all paths starting at that state.
            Ending weights are taken into account.
            </summary>
            <remarks>The weights are computed using dynamic programming, going up from leafs to the root.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.ComputeWeightsFromRoot">
            <summary>
            For each state of the component, computes the total weight of all paths starting at the root
            and ending at that state. Ending weights are not taken into account.
            </summary>
            <remarks>The weights are computed using dynamic programming, going down from the root to leafs.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.Root">
            <summary>
            Gets the root of the condensation's DAG.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.ComponentCount">
            <summary>
            Gets the number of strongly connected components in the condensation.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.CondensationStateInfo">
            <summary>
            Stores the information associated with a state of the condensation.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.CondensationStateInfo.Default">
            <summary>
            Gets the default state info with all the weights set to 0.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.CondensationStateInfo.LogWeightToEnd">
            <summary>
            Gets or sets the logarithm of the total weight of all paths starting at the state.
            Ending weights are taken into account.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.CondensationStateInfo.LogWeightFromRoot">
            <summary>
            Gets or sets the logarithm of the total weight of all paths from the root of the condensation
            to the state. Ending weights are not taken into account.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.CondensationStateInfo.LogUpwardWeightFromRoot">
            <summary>
            Gets or sets the logarithm of the total weight of all paths from the root of the condensation
            to the state that don't go through any other states of the same strongly connected component.
            Ending weights are not taken into account.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo">
            <summary>
            Stores the information maintained by the Tarjan's algorithm.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo"/> class.
            </summary>
            <param name="traversalIndex">The current traversal index.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo.InStack">
            <summary>
            Gets or sets a value indicating whether the state is currently in stack.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo.TraversalIndex">
            <summary>
            Gets the traversal index of the state.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Condensation.TarjanStateInfo.Lowlink">
            <summary>
            Gets or sets the lowlink of the state.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure">
            <summary>
            Represents the epsilon closure of a state.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.DefaultStateListCapacity">
            <summary>
            The default capacity of <see cref="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.weightedStates"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.weightedStates">
            <summary>
            The list of the states in the closure.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.#ctor(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure"/> class.
            </summary>
            <param name="state">The state, which epsilon closure this instance will represent.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.GetStateByIndex(System.Int32)">
            <summary>
            Gets a state by its index.
            </summary>
            <param name="index">The index. Must be non-negative and less than <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.Size"/>.</param>
            <returns>The state with the specified index.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.GetStateLogWeightByIndex(System.Int32)">
            <summary>
            Gets the logarithm of the total weight of all the paths from the root to the state with a given index,
            if following epsilon transitions only.
            </summary>
            <param name="index">The index. Must be non-negative and less than <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.Size"/>.</param>
            <returns>The logarithm of the weight.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.EndLogWeight">
            <summary>
            Gets the logarithm of the total weight for ending inside the closure,
            if following epsilon transitions only
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.EpsilonClosure.Size">
            <summary>
            Gets the number of states in the closure.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement">
            <summary>
            Represents an element of a generalized sequence,
            i.e. a distribution over a single symbol or a weighted self-loop.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.#ctor(`2,System.Byte,System.Nullable{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement"/> struct.
            </summary>
            <param name="elementDistribution">The element distribution associated with the generalized element.</param>
            <param name="group">The group associated with the generalized element.</param>
            <param name="loopLogWeight">
            The loop weight associated with the generalized element, <see langword="null"/> if the element does not represent a self-loop.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.ToString">
            <summary>
            Gets the string representation of the generalized element.
            </summary>
            <returns>The string representation of the generalized element.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.ElementDistribution">
            <summary>
            Gets the element distribution associated with the generalized element.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.IsEpsilonSelfLoop">
            <summary>
            Gets a value indicating whether this element corresponds to an epsilon self-loop.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.Group">
            <summary>
            Gets the group associated with the generalized element.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedElement.LoopLogWeight">
            <summary>
            Gets the loop weight associated with the generalized element,
            <see langword="null"/> if the element does not represent a self-loop.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence">
            <summary>
            Represents a sequence of generalized elements.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence.elements">
            <summary>
            The sequence elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence.#ctor(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.GeneralizedElement})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence"/> class.
            </summary>
            <param name="elements">The sequence elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence.ToString">
            <summary>
            Gets the string representation of the sequence.
            </summary>
            <returns>The string representation of the sequence.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence.Count">
            <summary>
            Gets the number of elements in the sequence.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.GeneralizedSequence.Item(System.Int32)">
            <summary>
            Gets the sequence element with the specified index.
            </summary>
            <param name="index">The element index.</param>
            <returns>The element at the given index.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State">
            <summary>
            Represents a state of the automaton.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.DefaultTransitionListCapacity">
            <summary>
            The default capacity of the <see cref="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.transitions"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.transitions">
            <summary>
            The collection of outgoing transitions.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.endLogWeight">
            <summary>
            The logarithm of the state ending weight.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.#ctor(System.Int32,System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition},System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State"/> class.
            </summary>
            <param name="index">The index of the state.</param>
            <param name="transitions">The outgoing transitions.</param>
            <param name="endLogWeight">The logarithm of the ending weight.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.GetTransitions">
            <summary>
            Creates the copy of the array of outgoing transitions. Used by quoting.
            </summary>
            <returns>The copy of the array of outgoing transitions.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddTransitionsForSequence(`0,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Byte)">
            <summary>
            Adds a series of transitions labeled with the elements of a given sequence to the current state,
            as well as the intermediate states. All the added transitions have unit weight.
            </summary>
            <param name="sequence">The sequence.</param>
            <param name="destinationState">
            The last state in the transition series.
            If the value of this parameter is <see langword="null"/>, a new state will be created.
            </param>
            <param name="group">The group of the added transitions.</param>
            <returns>The last state in the added transition series.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddTransition(`1,System.Double,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Byte)">
            <summary>
            Adds a transition labeled with a given element to the current state.
            </summary>
            <param name="element">The element.</param>
            <param name="logWeight">The logarithm of the transition weight.</param>
            <param name="destinationState">
            The destination state of the added transition.
            If the value of this parameter is <see langword="null"/>, a new state will be created.</param>
            <param name="group">The group of the added transition.</param>
            <returns>The destination state of the added transition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddEpsilonTransition(System.Double,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Byte)">
            <summary>
            Adds an epsilon transition to the current state.
            </summary>
            <param name="logWeight">The logarithm of the transition weight.</param>
            <param name="destinationState">
            The destination state of the added transition.
            If the value of this parameter is <see langword="null"/>, a new state will be created.</param>
            <param name="group">The group of the added transition.</param>
            <returns>The destination state of the added transition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddTransition(`2,System.Double,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Byte)">
            <summary>
            Adds a transition to the current state.
            </summary>
            <param name="elementDistribution">
            The element distribution associated with the transition.
            If the value of this parameter is <see langword="null"/>, an epsilon transition will be created.
            </param>
            <param name="logWeight">The logarithm of the transition weight.</param>
            <param name="destinationState">
            The destination state of the added transition.
            If the value of this parameter is <see langword="null"/>, a new state will be created.</param>
            <param name="group">The group of the added transition.</param>
            <returns>The destination state of the added transition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddTransition(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition)">
            <summary>
            Adds a transition to the current state.
            </summary>
            <param name="transition">The transition to add.</param>
            <returns>The destination state of the added transition.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddSelfTransition(`1,System.Double,System.Byte)">
            <summary>
            Adds a self-transition labeled with a given element to the current state.
            </summary>
            <param name="element">The element.</param>
            <param name="logWeight">The logarithm of the transition weight.</param>
            <param name="group">The group of the added transition.</param>
            <returns>The current state.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.AddSelfTransition(`2,System.Double,System.Byte)">
            <summary>
            Adds a self-transition to the current state.
            </summary>
            <param name="elementDistribution">
            The element distribution associated with the transition.
            If the value of this parameter is <see langword="null"/>, an epsilon transition will be created.
            </param>
            <param name="logWeight">The logarithm of the transition weight.</param>
            <param name="group">The group of the added transition.</param>
            <returns>The current state.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.SetTransition(System.Int32,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition)">
            <summary>
            Replaces the transition at a given index with another transition.
            </summary>
            <param name="index">The index of the transition to replace.</param>
            <param name="updatedTransition">The transition to replace with.</param>
            TODO: use TransitionCollection with a custom indexer instead
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.RemoveTransition(System.Int32)">
            <summary>
            Removes the transition with a given index.
            </summary>
            <param name="index">The index of the transition to remove.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.ToString">
            <summary>
            Returns a string that represents the state.
            </summary>
            <returns>A string that represents the state.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.GetLogValue(`0)">
            <summary>
            Computes the logarithm of the value of the automaton
            having this state as the start state on a given sequence.
            </summary>
            <param name="sequence">The sequence.</param>
            <returns>The logarithm of the value on the sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.IsZero">
            <summary>
            Gets whether the automaton having this state as the start state is zero everywhere.
            </summary>
            <returns>A value indicating whether the automaton having this state as the start state is zero everywhere.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.HasNonTrivialLoops">
            <summary>
            Gets whether the automaton having this state as the start state has non-trivial loops.
            </summary>
            <returns>A value indicating whether the automaton having this state as the start state is zero everywhere.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.GetEpsilonClosure">
            <summary>
            Gets the epsilon closure of this state.
            </summary>
            <returns>The epsilon closure of this state.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.DoHasNonTrivialLoops(MicrosoftResearch.Infer.Collections.ArrayDictionary{System.Boolean})">
            <summary>
            Recursively checks if the automaton has non-trivial loops
            (i.e. loops consisting of more than one transition).
            </summary>
            <param name="stateInStack">
            A dictionary, storing for each state whether it has already been visited, and,
            if so, whether the state still is on the traversal stack.</param>
            <returns>
            <see langword="true"/> if a non-trivial loop has been found,
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.DoIsZero(System.Collections.BitArray)">
            <summary>
            Recursively checks if the automaton is zero.
            </summary>
            <param name="visitedStates">For each state stores whether it has been already visited.</param>
            <returns>
            <see langword="false"/> if an accepting path has been found,
            <see langword="true"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.DoGetLogValue(`0,System.Int32,System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Distributions.Automata.IntPair,System.Double})">
            <summary>
            Recursively computes the logarithm of the value of the automaton on a given sequence.
            </summary>
            <param name="sequence">The sequence to compute the value on.</param>
            <param name="sequencePosition">The current position in the sequence.</param>
            <param name="logValueCache">A lookup table for memoization.</param>
            <returns>The logarithm of the value computed from the current state.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.Owner">
            <summary>
            Gets the automaton which owns the state.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.Index">
            <summary>
            Gets the index of the state.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.EndLogWeight">
            <summary>
            Gets or sets the logarithm of the state ending weight.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.EndWeight">
            <summary>
            Gets or sets the state ending weight.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.CanEnd">
            <summary>
            Gets a value indicating whether the ending weight of this state is greater than zero.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.State.Transitions">
            <summary>
            Gets the collection of outgoing transitions.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent">
            <summary>
            Represents a strongly connected component of an automaton graph.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.transitionFilter">
            <summary>
            The transition filter used to build the condensation this component belongs to.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.statesInComponent">
            <summary>
            The list of states in the component.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.useApproximateClosure">
            <summary>
            Specifies whether <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)"/> should be used
            instead of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)"/> in semiring computations.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.stateIdToIndexInComponent">
            <summary>
            The mappings from state indices to indices in the <see cref="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.statesInComponent"/> list.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.logPairwiseWeights">
            <summary>
            The table of logarithms of total weights between pairs of component nodes.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.singleStateLogPairwiseWeight">
            <summary>
            An optimized version of <see cref="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.logPairwiseWeights"/> in case the component consists of a single state.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.#ctor(System.Func{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition,System.Boolean},System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent"/> class.
            </summary>
            <param name="transitionFilter">The transition filter used to build the condensation this component belongs to.</param>
            <param name="statesInComponent">The list of states in the component.</param>
            <param name="useApproximateClosure">
            Specifies whether <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.ApproximateLogGeometricSeries(System.Double)"/> should be used
            instead of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomataMath.LogGeometricSeries(System.Double)"/> in semiring computations.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.GetStateByIndex(System.Int32)">
            <summary>
            Gets the state by its index in the component.
            </summary>
            <param name="indexInComponent">The index of the state in the component. Must be non-negative and less than <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.Size"/>.</param>
            <returns>The state corresponding to the specified index.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.HasState(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Checks whether the given state belongs to this component.
            </summary>
            <param name="state">The state.</param>
            <returns>
            <see langword="true"/> if <paramref name="state"/> belongs to the component,
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.GetIndexByState(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State)">
            <summary>
            Attempts to retrieve the index of a given state in the component.
            </summary>
            <param name="state">The state.</param>
            <returns>
            The index of <paramref name="state"/> in the component, or -1 if it does not belong to the component.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.GetLogWeight(System.Int32,System.Int32)">
            <summary>
            Gets the logarithm of the total weight between two given states in the component.
            </summary>
            <param name="srcStateIndexInComponent">The index of the source state in the component.</param>
            <param name="destStateIndexInComponent">The index of the destination state in the component.</param>
            <returns>The logarithm of the total weight between the given states in the component.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.ComputePairwiseWeightsMatrix">
            <summary>
            Computes the total weights between each pair of states in the component
            using the <a href="http://www.cs.nyu.edu/~mohri/pub/hwa.pdf">generalized Floyd's algorithm</a>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.StronglyConnectedComponent.Size">
            <summary>
            Gets the number of states in the component.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition">
            <summary>
            Represents a transition in an automaton.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.logWeight">
            <summary>
            The logarithm of the weight associated with this transition.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.#ctor(`2,System.Double,System.Int32,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition"/> struct.
            </summary>
            <param name="elementDistribution">The element distribution associated with the transition, or <see langword="null"/> if this is an epsilon transition.</param>
            <param name="logWeight">The logarithm of the weight associated with the transition.</param>
            <param name="destinationStateIndex">The index of the destination state of the transition.</param>
            <param name="group">The group this transition belongs to.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.SetTo(MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.Transition)">
            <summary>
            Replaces the configuration of this transition with the configuration of a given transition.
            </summary>
            <param name="transition">
            The transition which configuration would be used to replace the configuration of the current transition.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.ToString">
            <summary>
            Gets the string representation of this transition.
            </summary>
            <returns>The string representation of this transition.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.DestinationStateIndex">
            <summary>
            Gets or sets the destination state index.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.ElementDistribution">
            <summary>
            Gets or sets the element distribution for this transition.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.LogWeight">
            <summary>
            Gets or sets the logarithm of the weight associated with this transition.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.Weight">
            <summary>
            Gets or sets the weight associated with this transition.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.Group">
            <summary>
            Gets or sets the group this transition belongs to.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Transition.IsEpsilon">
            <summary>
            Gets a value indicating whether this transition is an epsilon transition.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats">
            <summary>
            A collection of automaton formats.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats"/> class.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats.GraphViz">
            <summary>
            Gets a format for converting an automaton to a GraphViz representation.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats.Regexp">
            <summary>
            Gets a format for converting an automaton to a regular expression representing its support.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.AutomatonFormats.Friendly">
            <summary>
            Gets a format for converting an automaton to a friendly regular expression like string representing its support.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase">
            <summary>
            A base class for implementations of <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.ISequenceDistributionFormat"/> that use
            <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat"/>.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.ISequenceDistributionFormat">
            <summary>
            An interface for classes implementing various methods of representing sequence distributions as strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceDistributionFormat.ConvertToString``6(``5)">
            <summary>
            Converts a given sequence distribution to a string.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="sequenceDistribution"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TWeightFunction">The type of weight functions used by <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceDistribution">The concrete type of <paramref name="sequenceDistribution"/>.</typeparam>
            <param name="sequenceDistribution">The sequence distribution to convert to string.</param>
            <returns>The string representation of the <paramref name="sequenceDistribution"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.#ctor(MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase"/> class.
            </summary>
            <param name="automatonFormat">The underlying automaton format.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.ConvertToString``6(``5)">
            <summary>
            Uses <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.AutomatonFormat"/> on the weight function of <paramref name="sequenceDistribution"/>,
            or calls <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.ConvertPointMassToString``6(``5)"/> if the distribution is a point mass.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="sequenceDistribution"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TWeightFunction">The type of weight functions used by <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceDistribution">The concrete type of <paramref name="sequenceDistribution"/>.</typeparam>
            <param name="sequenceDistribution">The sequence distribution to convert to string.</param>
            <returns>The string representation of the <paramref name="sequenceDistribution"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.ConvertPointMassToString``6(``5)">
            <summary>
            Overridden in the derived classes to convert a point mass sequence distribution to a string.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="sequenceDistribution"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TWeightFunction">The type of weight functions used by <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceDistribution">The concrete type of <paramref name="sequenceDistribution"/>.</typeparam>
            <param name="sequenceDistribution">The sequence distribution to convert to string.</param>
            <returns>The string representation of the <paramref name="sequenceDistribution"/>.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase.AutomatonFormat">
            <summary>
            Gets the underlying automaton function format.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Transducer`11">
            <summary>
            A base class for weighted finite state transducers that are defined on sequences of different types.
            </summary>
            <typeparam name="TSrcSequence">The type of the first sequence in a pair.</typeparam>
            <typeparam name="TSrcElement">The type of an element of <typeparamref name="TSrcSequence"/>.</typeparam>
            <typeparam name="TSrcElementDistribution">The type of a distribution over <typeparamref name="TSrcElement"/>.</typeparam>
            <typeparam name="TSrcSequenceManipulator">The type providing ways to manipulate sequences of type <typeparamref name="TSrcSequence"/>.</typeparam>
            <typeparam name="TSrcAutomaton">The type of an automaton defined on <typeparamref name="TSrcSequence"/>.</typeparam> 
            <typeparam name="TDestSequence">The type of the second sequence in a pair.</typeparam>
            <typeparam name="TDestElement">The type of an element of <typeparamref name="TDestSequence"/>.</typeparam>
            <typeparam name="TDestElementDistribution">The type of a distribution over <typeparamref name="TDestElement"/>.</typeparam>
            <typeparam name="TDestSequenceManipulator">The type providing ways to manipulate sequences of type <typeparamref name="TDestSequence"/>.</typeparam> 
            <typeparam name="TDestAutomaton">The type of an automaton defined on <typeparamref name="TDestSequence"/>.</typeparam> 
            <typeparam name="TThis">The type of a concrete transducer class.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12">
            <summary>
            A base class for weighted finite state transducers.
            </summary>
            <typeparam name="TSrcSequence">The type of the first sequence in a pair.</typeparam>
            <typeparam name="TSrcElement">The type of an element of <typeparamref name="TSrcSequence"/>.</typeparam>
            <typeparam name="TSrcElementDistribution">The type of a distribution over <typeparamref name="TSrcElement"/>.</typeparam>
            <typeparam name="TSrcSequenceManipulator">The type providing ways to manipulate sequences of type <typeparamref name="TSrcSequence"/>.</typeparam>
            <typeparam name="TSrcAutomaton">The type of an automaton defined on <typeparamref name="TSrcSequence"/>.</typeparam> 
            <typeparam name="TDestSequence">The type of the second sequence in a pair.</typeparam>
            <typeparam name="TDestElement">The type of an element of <typeparamref name="TDestSequence"/>.</typeparam>
            <typeparam name="TDestElementDistribution">The type of a distribution over <typeparamref name="TDestElement"/>.</typeparam>
            <typeparam name="TDestSequenceManipulator">The type providing ways to manipulate sequences of type <typeparamref name="TDestSequence"/>.</typeparam> 
            <typeparam name="TDestAutomaton">The type of an automaton defined on <typeparamref name="TDestSequence"/>.</typeparam> 
            <typeparam name="TPairDistribution">The type of a distribution over pairs of <typeparamref name="TSrcElement"/> and <typeparamref name="TDestElement"/>.</typeparam>
            <typeparam name="TThis">The type of a concrete transducer class.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.sequencePairToWeight">
            <summary>
            An automaton defined on sequences of element pairs that represents the transducer.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Consume(`4)">
            <summary>
            Creates a transducer <c>T(a, b) = f(a) I[b = ""]</c>, where <c>f(a)</c> is a given automaton.
            </summary>
            <param name="srcAutomaton">The automaton defining weights for the first transducer argument.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Consume(`0)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = A] I[b = ""]</c>, where <c>A</c> is a given sequence.
            </summary>
            <param name="srcSequence">The sequence to constrain the first transducer argument to.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ConsumeElement(`1)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a[0] = c, |a| = 1] I[b = ""]</c>, where <c>c</c> is a given element.
            </summary>
            <param name="srcElement">The element to constrain the first transducer argument to.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Produce(`9)">
            <summary>
            Creates a transducer <c>T(a, b) = g(b) I[a = ""]</c>, where <c>g(b)</c> is a given automaton.
            </summary>
            <param name="destAutomaton">The automaton defining weights for the second transducer argument.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Produce(`5)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = ""] I[b = B]</c>, where <c>B</c> is a given sequence.
            </summary>
            <param name="destSequence">The sequence to constrain the second transducer argument to.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProduceElement(`6)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = ""] I[b[0] = c, |b| = 1]</c>, where <c>c</c> is a given element.
            </summary>
            <param name="destElement">The element to constrain the second transducer argument to.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Replace(`4,`9)">
            <summary>
            Creates a transducer <c>T(a, b) = f(a) g(b)</c>, where <c>f(a)</c> and <c>g(b)</c> are given automata.
            </summary>
            <param name="srcAutomaton">The automaton defining weights for the first transducer argument.</param>
            <param name="destAutomaton">The automaton defining weights for the second transducer argument.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Replace(`0,`5)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = A] I[b = B]</c>, where <c>A</c> and <c>B</c> are given sequences.
            </summary>
            <param name="srcSequence">The sequence to constrain the first transducer argument to.</param>
            <param name="destSequence">The sequence to constrain the second transducer argument to.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Replace(`2,`7)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a[i] is in X for all i] I[b[j] is in Y for all j]</c>, where <c>X</c> and <c>Y</c>
            are the supports of given element distributions.
            </summary>
            <param name="allowedSrcElements">Specifies the elements allowed in the first transducer argument.</param>
            <param name="allowedDestElements">Specifies the elements allowed in the second transducer argument.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Sum(`11[])">
            <summary>
            Creates a transducer <c>T(a, b) = sum_i Ti(a, b)</c>, where <c>Ti(a, b)</c> is an element of a given transducer collection.
            </summary>
            <param name="transducers">The transducers to sum.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Sum(System.Collections.Generic.IEnumerable{`11})">
            <summary>
            Creates a transducer <c>T(a, b) = sum_i Ti(a, b)</c>, where <c>Ti(a, b)</c> is an element of a given transducer collection.
            </summary>
            <param name="transducers">The transducers to sum.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Repeat(`11,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a transducer <c>T'(a, b) = sum_{k=Kmin}^{Kmax} sum_{a1 a2 ... ak = a} sum_{b1 b2 ... bk = b} T(a1, b1)T(a2, b2)...T(ak, bk)</c>,
            where <c>T(a, b)</c> is a given transducer, and <c>Kmin</c> and <c>Kmax</c> are the minimum
            and the maximum number of factors in a sum term.
            </summary>
            <param name="transducer">The transducer.</param>
            <param name="minTimes">The minimum number of factors in a sum term. Defaults to 1.</param>
            <param name="maxTimes">An optional maximum number of factors in a sum term.</param>
            <returns>The created transducer.</returns>
            <remarks>
            The result is the sum of Cauchy products of the given transducer with itself,
            each product having a different number of factors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Optional(`11)">
            <summary>
            Creates a transducer <c>T'(a, b) = T(a, b) + I[a = "", b = ""]</c>, where <c>T(a, b)</c> is a given transducer.
            </summary>
            <param name="transducer">The transducer <c>U(a, b)</c>.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.GetLogValue(`0,`5)">
            <summary>
            Gets the logarithm of the transducer value on a given pair of sequences.
            </summary>
            <param name="sequence1">The first sequence.</param>
            <param name="sequence2">The second sequence.</param>
            <returns>The logarithm of the transducer value on the given pair of sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.GetValue(`0,`5)">
            <summary>
            Gets the transducer value on a given pair of sequences.
            </summary>
            <param name="sequence1">The first sequence.</param>
            <param name="sequence2">The second sequence.</param>
            <returns>The transducer value on the given pair of sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Append(`11)">
            <summary>
            Creates a transducer <c>T'(a, b) = sum_{a1 a2 = a, b1 b2 = b} T(a1, b1) U(a2, b2)</c>,
            where <c>T(a1, b1)</c> is the current transducer and <c>U(a2, b2)</c> is a given transducer.
            The resulting transducer is also known as the Cauchy product of two transducers.
            </summary>
            <param name="transducer">The transducer to append.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.AppendInPlace(`11,System.Byte)">
            <summary>
            Replaces the current transducer with a transducer <c>T'(a, b) = sum_{a1 a2 = a, b1 b2 = b} T(a1, b1) U(a2, b2)</c>,
            where <c>T(a1, b1)</c> is the current transducer and <c>U(a2, b2)</c> is a given transducer.
            The resulting transducer is also known as the Cauchy product of two transducers.
            </summary>
            <param name="transducer">The transducer to append.</param>
            <param name="group">The group.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProjectSource(`4)">
            <summary>
            Computes <c>g(b) = sum_a f(a) T(a, b)</c>, where <c>T(a, b)</c> is the current transducer and <c>f(a)</c> is a given automaton.
            </summary>
            <param name="srcAutomaton">The automaton to project.</param>
            <returns>The projection.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProjectSource(`0)">
            <summary>
            Computes <c>g(b) = f(A) T(A, b)</c>, where <c>T(a, b)</c> is the current transducer and <c>A</c> is a given sequence.
            </summary>
            <param name="srcSequence">The sequence to project.</param>
            <returns>The projection.</returns>
            <remarks>
            Using this method is more efficient than applying <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProjectSource(`4)"/>
            to the automaton representation of a projected sequence.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProjectSource``1(``0)">
            <summary>
            Computes <c>P(b) \propto sum_a P(a) T(a, b)</c>, where <c>T(a, b)</c> is the current transducer and <c>P(a)</c> is a given distribution.
            </summary>
            <typeparam name="TSrcDistribution">The type of a distribution being projected.</typeparam>
            <param name="srcDistribution">The distribution to project.</param>
            <returns>The projection.</returns>
            <remarks>Calls <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.ProjectSource(`0)"/> if the distribution is a point mass.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.Clone">
            <summary>
            Creates a copy of this transducer.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.SetTo(`11)">
            <summary>
            Replaces this transducer with a copy of a given transducer.
            </summary>
            <param name="otherTransducer">The transducer to replace this transducer with.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.IsSrcEpsilon(MicrosoftResearch.Infer.Distributions.Automata.Automaton{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6},`10,MicrosoftResearch.Infer.Distributions.Automata.ListManipulator{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Distributions.Automata.TransducerBase{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11}.PairListAutomaton}.Transition)">
            <summary>
            Checks whether a given transducer transition is either epsilon of has epsilon source element.
            </summary>
            <param name="transition">The transition to check.</param>
            <returns>A value indicating whether a given transducer transition is either epsilon of has epsilon source element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.BuildProjectionOfSequence(`9,MicrosoftResearch.Infer.Distributions.Automata.Automaton{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6},`10,MicrosoftResearch.Infer.Distributions.Automata.ListManipulator{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Distributions.Automata.TransducerBase{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11}.PairListAutomaton}.State,`0,System.Int32,System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Distributions.Automata.IntPair,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`5,`6,`7,`8,`9}.State})">
            <summary>
            Recursively builds the projection of a given sequence onto this transducer.
            </summary>
            <param name="destAutomaton">The projection being built.</param>
            <param name="mappingState">The currently traversed state of the transducer.</param>
            <param name="srcSequence">The sequence being projected.</param>
            <param name="srcSequenceIndex">The current index in the sequence being projected.</param>
            <param name="destStateCache">The cache of the created projection states.</param>
            <returns>The state of the projection corresponding to the given mapping state and the position in the projected sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.BuildProjectionOfAutomaton(`9,MicrosoftResearch.Infer.Distributions.Automata.Automaton{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6},`10,MicrosoftResearch.Infer.Distributions.Automata.ListManipulator{System.Collections.Generic.List{MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Pair{`1,`6}},MicrosoftResearch.Infer.Distributions.Automata.TransducerBase{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11}.PairListAutomaton}.State,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`0,`1,`2,`3,`4}.State,System.Collections.Generic.Dictionary{MicrosoftResearch.Infer.Distributions.Automata.IntPair,MicrosoftResearch.Infer.Distributions.Automata.Automaton{`5,`6,`7,`8,`9}.State})">
            <summary>
            Recursively builds the projection of a given automaton onto this transducer.
            The projected automaton must be epsilon-free.
            </summary>
            <param name="destAutomaton">The projection being built.</param>
            <param name="mappingState">The currently traversed state of the transducer.</param>
            <param name="srcState">The currently traversed state of the automaton being projected.</param>
            <param name="destStateCache">The cache of the created projection states.</param>
            <returns>The state of the projection corresponding to the given mapping state and the position in the projected sequence.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.SequencePairToWeight">
            <summary>
            Gets or sets the automaton defined on sequences of element pairs that represents the transducer.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.TransducerBase`12.PairListAutomaton">
            <summary>
            Represents an automaton that maps lists of element pairs to real values. Such automata are used to represent transducers internally.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.ListAutomaton`4">
            <summary>
            A base class for automata defined on types implementing <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="TList">The type of a list the automaton is defined on.</typeparam>
            <typeparam name="TElement">The type of a list element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over list elements.</typeparam>
            <typeparam name="TThis">The type of a concrete list automaton class.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`11.Transpose``1(`10)">
            <summary>
            Creates a transducer <c>T'(b, a) = T(a, b)</c>, where <c>T(a, b)</c> is a given transducer.
            </summary>
            <typeparam name="TThat">The type of the resulting transducer.</typeparam>
            <param name="transducer">The transducer to transpose.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6">
            <summary>
            A base class for weighted finite state transducers that are defined on sequences of the same type.
            </summary>
            <typeparam name="TSequence">The type of a sequence in a pair.</typeparam>
            <typeparam name="TElement">The type of an element of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over <typeparamref name="TElement"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate sequences of type <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TAutomaton">The type of an automaton defined on <typeparamref name="TSequence"/>.</typeparam> 
            <typeparam name="TThis">The type of a concrete transducer class.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Copy">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = b]</c>.
            </summary>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Copy(`2)">
            <summary>
            Creates a transducer <c>T(a, b) = I[A[i] is in C for all i] I[a = b]</c>,
            where <c>C</c> is the support of a given element distribution.
            </summary>
            <param name="allowedElements">Specifies the elements allowed in the transducer arguments.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Copy(`0)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a = A] I[a = b]</c>, where <c>A</c> is a given sequence.
            </summary>
            <param name="sequence">The sequence to constrain the arguments.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Copy(`4,System.Byte)">
            <summary>
            Creates a transducer <c>T(a, b) = f(a) I[a = b]</c>, where <c>f(a)</c> is a given automaton.
            </summary>
            <param name="automaton">The automaton to weight the sequence.</param>
            <param name="group">The group.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.CopyElement(`1)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a[0] = c, |a| = 1] I[a = b]</c>,
            where <c>c</c> is a given element.
            </summary>
            <param name="element">The element allowed in the transducer arguments.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.CopyElement(`2)">
            <summary>
            Creates a transducer <c>T(a, b) = I[a[0] is in C, |a| = 1] I[a = b]</c>,
            where <c>C</c> is the support of a given element distribution.
            </summary>
            <param name="allowedElements">Specifies the elements allowed in the transducer arguments.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Transpose(`5)">
            <summary>
            Creates a transducer <c>T'(b, a) = T(a, b)</c>, where <c>T(a, b)</c> is a given transducer.
            </summary>
            <param name="transducer">The transducer to transpose.</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.TransposeInPlace">
            <summary>
            Replaces the current transducer with its transpose (see <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Transducer`6.Transpose(`5)"/>).
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.GraphVizAutomatonFormat">
            <summary>
            Converts a given automaton to the GraphViz format, which can be then visualized using, for example,
            <a href="http://graphviz-dev.appspot.com/">this</a> tool.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat">
            <summary>
            An interface for classes implementing various methods of representing automata as strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat.ConvertToString``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4})">
            <summary>
            Converts a given automaton to a string.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="automaton"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TAutomaton">The concrete type of <paramref name="automaton"/>.</typeparam>
            <param name="automaton">The automaton to convert to a string.</param>
            <returns>The string representation of <paramref name="automaton"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.GraphVizAutomatonFormat.ConvertToString``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4})">
            <summary>
            Converts a given automaton to a GraphViz representation.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="automaton"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TAutomaton">The concrete type of <paramref name="automaton"/>.</typeparam>
            <param name="automaton">The automaton to convert to a string.</param>
            <returns>The string representation of <paramref name="automaton"/>.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.IntPair">
            <summary>
            Represents a pair of integers.
            </summary>
            <remarks>
            This structure equipped with the provided equality comparer can be used as an efficient dictionary key.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.IntPair"/> struct.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.IntPair"/> struct.
            </summary>
            <param name="first">The first integer.</param>
            <param name="second">The second integer.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.ToString">
            <summary>
            Gets a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.Equals(System.Object)">
            <summary>
            Checks whether this pair is equal to a given object.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns><see langword="true"/> if this pair is equal to the given one, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.Equals(MicrosoftResearch.Infer.Distributions.Automata.IntPair)">
            <summary>
            Checks whether this object is equal to a given pair.
            </summary>
            <param name="pair">The pair to compare with.</param>
            <returns><see langword="true"/> if this pair is equal to the given one, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.GetHashCode">
            <summary>
            Gets the hash code of this pair.
            </summary>
            <returns>The has code of this pair.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.IntPair.DefaultEqualityComparer">
            <summary>
            Gets the default equality comparer for this class.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.IntPair.First">
            <summary>
            Gets the first integer.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.IntPair.Second">
            <summary>
            Gets the second integer.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.IntPair.EqualityComparer">
            <summary>
            The default equality comparer for the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.IntPair"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.EqualityComparer.Equals(MicrosoftResearch.Infer.Distributions.Automata.IntPair,MicrosoftResearch.Infer.Distributions.Automata.IntPair)">
            <summary>
            Checks whether two given pairs are equal.
            </summary>
            <param name="pair1">The first pair.</param>
            <param name="pair2">The second pair.</param>
            <returns><see langword="true"/> if the given pairs are equal, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.IntPair.EqualityComparer.GetHashCode(MicrosoftResearch.Infer.Distributions.Automata.IntPair)">
            <summary>
            Computes the hash code of a given pair.
            </summary>
            <param name="pair">The pair to compute the hash code of.</param>
            <returns>The computed hash code.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2">
            <summary>
            An interface for classes that provide functionality to manipulate sequences of a certain type.
            </summary>
            <typeparam name="TSequence">The type of a sequence.</typeparam>
            <typeparam name="TElement">The type of a sequence element.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2.ToSequence(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Converts a given collection of elements to a sequence.
            </summary>
            <param name="elements">The collection of elements to convert to a sequence.</param>
            <returns>The sequence containing the elements.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2.GetLength(`0)">
            <summary>
            Gets the length of a given sequence.
            </summary>
            <param name="sequence">The sequence.</param>
            <returns>The length of the sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2.GetElement(`0,System.Int32)">
            <summary>
            Gets the element at a given position in a given sequence.
            </summary>
            <param name="sequence">The sequence.</param>
            <param name="index">The position.</param>
            <returns>The element at the given position in the sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2.SequencesAreEqual(`0,`0)">
            <summary>
            Checks if given sequences are equal.
            Sequences are considered equal if they contain the same elements in the same order.
            </summary>
            <param name="sequence1">The first sequence.</param>
            <param name="sequence2">The second sequence.</param>
            <returns><see langword="true"/> if the sequences are equal, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ISequenceManipulator`2.Concat(`0,`0)">
            <summary>
            Creates a sequence by copying the first sequence and then appending the second sequence to it.
            </summary>
            <param name="sequence1">The first sequence.</param>
            <param name="sequence2">The second sequence.</param>
            <returns>The created sequence.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.ListAutomaton`3">
            <summary>
            An automaton defined on types implementing <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="TList">The type of a list the automaton is defined on.</typeparam>
            <typeparam name="TElement">The type of a list element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over list elements.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2">
            <summary>
            Provides the ability to manipulate lists (classes that implement <see cref="T:System.Collections.Generic.IList`1"/>).
            </summary>
            <typeparam name="TList">The type of a list.</typeparam>
            <typeparam name="TElement">The type of a list element.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2.ToSequence(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Converts a given collection of elements to a list.
            </summary>
            <param name="elements">The collection of elements to convert to a sequence.</param>
            <returns>The list containing the elements.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2.GetLength(`0)">
            <summary>
            Gets the length of a given list.
            </summary>
            <param name="sequence">The list.</param>
            <returns>The length of the list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2.GetElement(`0,System.Int32)">
            <summary>
            Gets the element at a given position in a given list.
            </summary>
            <param name="sequence">The list.</param>
            <param name="index">The position.</param>
            <returns>The element at the given position in the list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2.SequencesAreEqual(`0,`0)">
            <summary>
            Checks if given lists are equal.
            Lists are considered equal if they contain the same elements in the same order.
            </summary>
            <param name="sequence1">The first list.</param>
            <param name="sequence2">The second list.</param>
            <returns><see langword="true"/> if the lists are equal, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.ListManipulator`2.Concat(`0,`0)">
            <summary>
            Creates a list by copying the first list and then appending the second list to it.
            </summary>
            <param name="sequence1">The first list.</param>
            <param name="sequence2">The second list.</param>
            <returns>The created list.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`4">
            <summary>
            Represents a factorized distribution over pairs of elements
            <c>P(x, y) = P(x)P(y)</c>. Pair elements <c>x</c> and <c>y</c> can be of different types.
            </summary>
            <typeparam name="TElement1">The type of a first element of a pair.</typeparam>
            <typeparam name="TElementDistribution1">The type of a distribution over <typeparamref name="TElement1"/>.</typeparam>
            <typeparam name="TElement2">The type of a second element of a pair.</typeparam>
            <typeparam name="TElementDistribution2">The type of a distribution over <typeparamref name="TElement2"/>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5">
            <summary>
            A base class for distributions over pairs of elements used to specify transducers.
            </summary>
            <typeparam name="TElement1">The type of a first element of a pair.</typeparam>
            <typeparam name="TElementDistribution1">The type of a distribution over <typeparamref name="TElement1"/>.</typeparam>
            <typeparam name="TElement2">The type of a second element of a pair.</typeparam>
            <typeparam name="TElementDistribution2">The type of a distribution over <typeparamref name="TElement2"/>.</typeparam>
            <typeparam name="TThis">The type of a concrete pair distribution class.</typeparam>
            <remarks>
            <p>
            Default interface implementations available in this class assume that the distribution is fully factorized:
            <c>P(x, y) = P(x) P(y)</c>, where <c>P(x)</c> is given by <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.First"/> and <c>P(y)</c> is given by second.
            Implementations of another kinds of pair distributions must override the interface implementation to ensure the correct behavior.
            </p>
            <p>
            One of the element distributions can be <see langword="null"/> to encode an epsilon input or an epsilon output
            in a transducer. Both distributions cannot be null at the same time: epsilon transition in transducers are specified by
            setting pair distributions to <see langword="null"/>.
            </p>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IDistribution`1">
            <summary>Distribution interface</summary>
            <typeparam name="T">The type of objects in the domain, e.g. Vector or Matrix.</typeparam>
            <remarks><para>
            T should generally have value semantics, i.e. it should override Equals to use value equality.
            Otherwise it implies a Distribution over references.
            </para><para>
            In addition to this interface, Distributions should override Equals to 
            use value equality.  
            A typical implementation of Equals is: <c>MaxDiff(that) == 0.0</c>
            </para><para>
            To be generally used by message-passing algorithms, a distribution should also implement the
            following interfaces:
            <c>SettableTo, SettableToProduct, SettableToRatio, SettableToPower, SettableToWeightedSum,
            CanGetLogAverageOf, CanGetAverageLog</c>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.HasPoint`1">
            <summary>
            Whether the distribution supports being a point mass
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.Point">
            <summary>
            Access the location of a point mass.
            </summary>
            <remarks><para>
            If the distribution parameters do not represent a point mass, 
            getting this property returns an undefined value (if T is a ValueType) 
            or a storage area with undefined contents (if T is a reference type).
            It should not throw an exception.
            Setting Point will change the distribution into a point mass, overriding any other 
            property settings.
            Note: Point = Point does have an effect!
            </para><para>
            If T is a reference type, then the result is volatile.  
            Its contents expire upon invoking any subsequent distribution method.
            </para><para>
            Point is a property because it is expected that each distribution would have a 
            corresponding data field.  Accessing the Point should take constant time.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.IsPointMass">
            <summary>
            Gets whether the distribution parameters represent a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SettableToUniform">
            <summary>
            Whether the distribution can be set to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.SetToUniform">
            <summary>
            Set the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.IsUniform">
            <summary>
            Ask whether the distribution instance is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1">
            <summary>
            Whether the distribution supports evaluation of its density
            </summary>
            <typeparam name="T">Domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1.GetLogProb(`0)">
            <summary>
            Evaluate the log of the density function at the specified domain value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1">
            <summary>
            Whether the distribution can compute the expectation of another distribution's value.
            </summary>
            <typeparam name="T">The other distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1.GetLogAverageOf(`0)">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SettableToPartialUniform`1">
            <summary>
            Whether the distribution can be set to be uniform over the support of another distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToPartialUniform`1.SetToPartialUniform">
            <summary>
            Sets the distribution to be uniform over its support.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToPartialUniform`1.SetToPartialUniformOf(`0)">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="dist">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToPartialUniform`1.IsPartialUniform">
            <summary>
            Checks whether the distribution is uniform over its support.
            </summary>
            <returns>True if the distribution is uniform over its support, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.FromFirst(`1)">
            <summary>
            Creates a pair distribution for an epsilon output transducer transition.
            </summary>
            <param name="first">The element distribution to weight the input element.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.FromSecond(`3)">
            <summary>
            Creates a pair distribution for an epsilon input transducer transition.
            </summary>
            <param name="second">The element distribution to weight the output element.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.FromFirstSecond(`1,`3)">
            <summary>
            Creates a pair distribution for a transducer transition.
            </summary>
            <param name="first">The element distribution to weight the input element.</param>
            <param name="second">The element distribution to weight the output element.</param>
            <remarks>
            One of <paramref name="first"/> and <paramref name="second"/> can be <see langword="null"/>
            to encode an epsilon input or an epsilon output transducer transition, but not both.
            </remarks>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.ProjectFirst(`0,`3@)">
            <summary>
            Computes <c>P(y) = R(x, y)</c>, where <c>R(x, y)</c> is the current pair distribution,
            and <c>x</c> is a given element.
            </summary>
            <param name="first">The element to project.</param>
            <param name="result">The normalized projection result.</param>
            <returns>The logarithm of the scale for the projection result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.ProjectFirst(`1,`3@)">
            <summary>
            Computes <c>P(y) = sum_x Q(x) R(x, y)</c>, where <c>R(x, y)</c> is the current pair distribution,
            and <c>Q(x)</c> is a given element distribution.
            </summary>
            <param name="first">The element distribution to project.</param>
            <param name="result">The normalized projection result.</param>
            <returns>The logarithm of the scale for the projection result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.IsUniform">
            <summary>
            Checks whether the current distribution is uniform.
            </summary>
            <returns><see langword="true"/> if the current distribution is uniform, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.SetToUniform">
            <summary>
            Replaces the current distribution with a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.ToString">
            <summary>
            Returns a string that represents the distribution.
            </summary>
            <returns>
            A string that represents the distribution.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.Clone">
            <summary>
            Creates a copy of the current distribution.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.MaxDiff(System.Object)">
            <summary>
            Gets the maximum difference between the parameters of this distribution and a given one.
            </summary>
            <param name="that">The other distribution.</param>
            <returns>The maximum difference.</returns>
            <remarks>Not currently implemented.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.GetLogProb(MicrosoftResearch.Infer.Pair{`0,`2})">
            <summary>
            Gets the logarithm of the probability of a given element pair under this distribution.
            </summary>
            <param name="pair">The pair to get the probability for.</param>
            <returns>The logarithm of the probability of the pair.</returns>
            <remarks>Not currently implemented.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.GetLogAverageOf(`4)">
            <summary>
            Returns the logarithm of the probability that the current distribution would draw the same sample
            as a given one.
            </summary>
            <param name="that">The given distribution.</param>
            <returns>The logarithm of the probability that distributions would draw the same sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.SetToProduct(`4,`4)">
            <summary>
            Replaces the current distribution with a product of a given pair of distributions.
            </summary>
            <param name="distribution1">The first distribution.</param>
            <param name="distribution2">The second distribution.</param>
            <remarks>Not currently implemented.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.SetToSum(System.Double,`4,System.Double,`4)">
            <summary>
            Replaces the current distribution with a mixture of a given pair of distributions.
            </summary>
            <param name="weight1">The weight of the first distribution.</param>
            <param name="distribution1">The first distribution.</param>
            <param name="weight2">The weight of the second distribution.</param>
            <param name="distribution2">The second distribution.</param>
            <remarks>Not currently implemented.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.SetToPartialUniform">
            <summary>
            Sets the distribution to be uniform over its support.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.SetToPartialUniformOf(`4)">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="distribution">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.IsPartialUniform">
            <summary>
            Checks whether the distribution is uniform over its support.
            </summary>
            <returns><see langword="true"/> if the distribution is uniform over its support, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.First">
            <summary>
            Gets or sets the marginal distribution over the first element in a pair.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.Second">
            <summary>
            Gets or sets the marginal distribution over the second element in a pair.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.IsPointMass">
            <summary>
            Gets a value indicating whether the current distribution represents a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistributionBase`5.Point">
            <summary>
            Gets or sets the point mass represented by the distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`4.Transpose">
            <summary>
            Creates a distribution <c>Q(y, x) = P(x, y)</c>, where <c>P(x, y)</c> is the current distribution.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2">
            <summary>
            This class can represent distributions over pairs of two types: a factorized <c>P(x, y) = P(x) P(y)</c>,
            and correlated <c>P(x, y) \propto P(x) P(y) I[x=y]</c>. Both elements of a pair must be of the same type.
            </summary>
            <typeparam name="TElement">The type of a pair element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over <typeparamref name="TElement"/>.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.firstTimesSecond">
            <summary>
            Stores the product of distributions over the first and the the second element
            when the equality constraint is enabled.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.Constrained(`1,`1)">
            <summary>
            Creates a distribution <c>P(x, y) \propto Q(x) R(y) I[x=y]</c>, where <c>Q(x)</c> and <c>R(y)</c> are given element distributions.
            </summary>
            <param name="firstElementDistribution">The marginal distribution of the first element of a pair.</param>
            <param name="secondElementDistribution">The marginal distribution of the second element of a pair.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.Constrained(`1)">
            <summary>
            Creates a distribution <c>P(x, y) \propto P(x) P(y) I[x=y]</c>, where <c>P</c> is a given element distribution.
            </summary>
            <param name="elementDistribution">The marginal distribution over pair elements.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.UniformConstrained">
            <summary>
            Creates a distribution <c>P(x, y) \propto I[x=y]</c>.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.ProjectFirst(`0,`1@)">
            <summary>
            Computes <c>P(y) = R(x, y)</c>, where <c>R(x, y)</c> is the current pair distribution,
            and <c>x</c> is a given element.
            </summary>
            <param name="first">The element to project.</param>
            <param name="result">The normalized projection result.</param>
            <returns>The logarithm of the scale for the projection result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.ProjectFirst(`1,`1@)">
            <summary>
            Computes <c>P(y) = sum_x Q(x) R(x, y)</c>, where <c>R(x, y)</c> is the current pair distribution,
            and <c>Q(x)</c> is a given element distribution.
            </summary>
            <param name="first">The element distribution to project.</param>
            <param name="result">The normalized projection result.</param>
            <returns>The logarithm of the scale for the projection result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.IsUniform">
            <summary>
            Checks whether the current distribution is uniform.
            </summary>
            <returns><see langword="true"/> if the current distribution is uniform, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.SetToUniform">
            <summary>
            Replaces the current distribution with a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.Clone">
            <summary>
            Creates a copy of the current distribution.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.ToString">
            <summary>
            Returns a string that represents the distribution.
            </summary>
            <returns>
            A string that represents the distribution.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Automata.PairDistribution{`0,`1})">
            <summary>
            Returns the logarithm of the probability that the current distribution would draw the same sample
            as a given one.
            </summary>
            <param name="that">The given distribution.</param>
            <returns>The logarithm of the probability that distributions would draw the same sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.SetToPartialUniformOf(MicrosoftResearch.Infer.Distributions.Automata.PairDistribution{`0,`1})">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="distribution">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.Transpose">
            <summary>
            Creates a distribution <c>Q(y, x) = P(x, y)</c>, where <c>P(x, y)</c> is the current distribution.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.HasEqualityConstraint">
            <summary>
            Gets a value indicating whether the equality constraint is set on the distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.PairDistribution`2.Point">
            <summary>
            Gets or sets the point mass represented by the distribution.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat">
            <summary>
            Converts a given automaton to a regular expression
            (or a regular expression-like string) corresponding to the support of the automaton.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat.#ctor(MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat"/> class.
            </summary>
            <param name="formattingSettings">The formatting settings used for conversion from an automaton to a string.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat.ConvertToString``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4})">
            <summary>
            Converts a given automaton to a regular expression corresponding to the support of the function.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="automaton"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="automaton"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TAutomaton">The concrete type of <paramref name="automaton"/>.</typeparam>
            <param name="automaton">The automaton to convert to a string.</param>
            <returns>The string representation of <paramref name="automaton"/>.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat.FormattingSettings">
            <summary>
            Gets the formatting settings used for conversion.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings">
            <summary>
            The formatting settings used by the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpAutomatonFormat"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings"/> class.
            </summary>
            <param name="putOptionalInSquareBrackets">
            Whether optional strings should be represented as <c>'[str]'</c> instead of <c>'(str|)'</c>.
            </param>
            <param name="showAnyElementAsQuestionMark">
            Whether languages consisting of a single arbitrary character should be represented
            by '?' instead of '.'.
            </param>
            <param name="ignoreElementDistributionDetails">
            Whether non point mass element distributions should be presented to a user as uniform.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.Equals(System.Object)">
            <summary>
            Compares this object with a given one.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns>
            <see langword="true"/> if this object equals to the given one, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.GetHashCode">
            <summary>
            Computes the hash code of this object.
            </summary>
            <returns>
            The computed hash code.
            </returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.PutOptionalInSquareBrackets">
            <summary>
            Gets a value indicating whether optional strings should be represented as <c>'[str]'</c> instead of <c>'(str|)'</c>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.ShowAnyElementAsQuestionMark">
            <summary>
            Gets a value indicating whether languages consisting of a single arbitrary character should be represented
            by '?' instead of '.'.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings.IgnoreElementDistributionDetails">
            <summary>
            Gets a value indicating whether non point mass element distributions
            should be presented to a user in a detailed form.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeBuilder">
            <summary>
            Contains methods for converting automata into regular expressions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeBuilder.BuildRegexp``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Builds a regular expression tree for the support of a given automaton.
            </summary>
            <typeparam name="TSequence">The type of a sequence.</typeparam>
            <typeparam name="TElement">The type of a sequence element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over sequence elements.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate sequences.</typeparam>
            <typeparam name="TAutomaton">The concrete type of an automaton.</typeparam>
            <param name="automaton">The automaton.</param>
            <param name="collapseAlternatives">
            Specifies whether an attempt to merge identical sub-expressions should be made.
            Setting it to <see langword="false"/> will improve the performance, but produce longer regular expressions.
            Defaults to <see langword="true"/>.
            </param>
            <returns>The built regular expression tree.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeBuilder.BuildStronglyConnectedComponentRegexp``5(MicrosoftResearch.Infer.Distributions.Automata.Automaton{``0,``1,``2,``3,``4}.StronglyConnectedComponent)">
            <summary>
            Computes the regular expression for each pair of states in a given strongly connected component
            by using the generalized Floyd's algorithm on the regular expression semiring
            as described in <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions"/>.
            First state in the pair is treated as the start state, the second one - as the accepting state.
            </summary>
            <typeparam name="TSequence">The type of a sequence.</typeparam>
            <typeparam name="TElement">The type of a sequence element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over sequence elements.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate sequences.</typeparam>
            <typeparam name="TAutomaton">The concrete type of an automaton.</typeparam>
            <param name="component">The strongly connected component to compute the regular expressions for.</param>
            <returns>A table containing the computed regular expressions.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1">
            <summary>
            Represents a node in the tree describing a regular expression.
            </summary>
            <typeparam name="TElement">The type of a character in a language word.</typeparam>
            <remarks>
            Although this class might look immutable, <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Simplify(System.Boolean)"/>
            can change the tree rooted at the node by removing existing children and/or adding new.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.VerboseFormattingSettings">
            <summary>
            The most verbose formatting settings. Used for strong language equivalence check.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.CachedEmptyNode">
            <summary>
            A node instance representing an empty string language. Shared by all regular expression trees.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.CachedNothingNode">
            <summary>
            A node instance representing an empty language. Shared by all regular expression trees.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.children">
            <summary>
            The children of the node.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.elementSet">
            <summary>
            The character set associated with the node (if it is an element set node).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.simplified">
            <summary>
            Whether the node and its children have been simplified.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.toStringVerboseCached">
            <summary>
            Cached results of <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ToString"/> calls on this node (only for simplified nodes).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1"/> class from being created.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Empty">
            <summary>
            Creates a node representing language consisting of an empty string.
            </summary>
            <returns>The created node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Nothing">
            <summary>
            Returns a node representing the empty language.
            </summary>
            <returns>A node representing the empty language.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.FromElementSet``1(``0)">
            <summary>
            Creates a terminal node representing a given set of sequence elements.
            </summary>
            <typeparam name="TElementSet">The type of a sequence element set.</typeparam>
            <param name="elementSet">The distribution over sequence elements.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Or(MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0},MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0})">
            <summary>
            Creates a node representing the union of the languages described by a given pair of nodes.
            </summary>
            <param name="node1">The first node.</param>
            <param name="node2">The second node.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Concat(MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0},MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0})">
            <summary>
            Creates a node representing the concatenation of the languages described by a given pair of nodes.
            </summary>
            <param name="node1">The first node.</param>
            <param name="node2">The second node.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Star(MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0})">
            <summary>
            Creates a node representing the Kleene star of the language described by a given node.
            </summary>
            <param name="node">The node.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ToString">
            <summary>
            Returns a string representation of the language described by the node.
            </summary>
            <returns>A string representation of the language described by the node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ToString(MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings)">
            <summary>
            Returns a string representation of the language described by the node.
            </summary>
            <param name="formattingSettings">The formatting settings used for conversion from an automaton to a string.</param>
            <returns>A string representation of the language described by the node.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Simplify(System.Boolean)">
            <summary>
            Simplifies the regular expression tree rooted at this node.
            </summary>
            <param name="collapseAlternatives">
            Specifies whether an attempt to merge identical sub-expressions should be made.
            Setting it to <see langword="false"/> will improve the performance, but produce longer regular expressions.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ToString(MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings,System.Boolean)">
            <summary>
            Returns a string representation of the language described by the node.
            </summary>
            <param name="formattingSettings">The formatting settings used for conversion from an automaton to a string.</param>
            <param name="useCache">Whether the value caching should be used.</param>
            <returns>A string representation of the language described by the node.</returns>
            <remarks>
            Value caching must be used with care: once cached, a value would never be invalidated.
            That is why this method should be called with value caching only on those nodes that have already been simplified.
            <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SimplifyUnion(System.Boolean)"/> uses this method in exactly this way.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SimplifyUnion(System.Boolean)">
            <summary>
            Simplifies a node representing union.
            </summary>
            <param name="collapseAlternatives">
            Specifies whether an attempt to merge identical sub-expressions should be made.
            Setting it to <see langword="false"/> will improve the performance, but produce longer regular expressions.
            </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SimplifyConcat">
            <summary>
            Simplifies a node representing concatenation.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SimplifyStar">
            <summary>
            Simplifies a node representing Kleene star.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SetTo(MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode{`0})">
            <summary>
            Copies the state of this node from another node.
            </summary>
            <param name="other">The node to copy the state from.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.IsOptional">
            <summary>
            Checks whether this node represents an optional language (union of an empty string and some language).
            </summary>
            <returns>
            <see langword="true"/> if this node represents an optional language, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.AppendRegexpWithBrackets(System.Text.StringBuilder,MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType,MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings,System.Boolean)">
            <summary>
            Appends a regular expression representation of the language described by the node to a given string builder,
            adding brackets if the parent operation has higher priority.
            </summary>
            <param name="resultBuilder">The string builder.</param>
            <param name="parentType">The type of the parent node.</param>
            <param name="formattingSettings">The formatting settings used for conversion from an automaton to a string.</param>
            <param name="useCache">Whether the value caching should be used (see <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ToString(MicrosoftResearch.Infer.Distributions.Automata.RegexpFormattingSettings,System.Boolean)"/>).</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Type">
            <summary>
            Gets the type of the node.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.ElementSet">
            <summary>
            Gets the character set associated with the node.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.Children">
            <summary>
            Gets the children of the node.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1">
            <summary>
            A custom dictionary for mapping strings to values. A key lookup takes linear time.
            </summary>
            <remarks>
            Can be faster than <see cref="T:System.Collections.Generic.Dictionary`2"/> when the number of strings is small, and the strings are long.
            There are two reasons for that. First, the linear search procedure used has almost no overhead.
            Second, <see cref="T:System.Collections.Generic.Dictionary`2"/> needs to look through every string to compute its hash code,
            while the linear search procedure usually looks only at a couple characters in every string,
            so it can work with long strings without much performance loss.
            </remarks>
            <typeparam name="TValue">The type of a value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1.AddIfMissing(System.String,`1)">
            <summary>
            Adds a given key-value pair to the dictionary, if it doesn't yet contain the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1.UniqueKeys">
            <summary>
            Gets the list of unique keys in the dictionary.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1.UniqueValues">
            <summary>
            Gets the list of values corresponding to <see cref="P:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNode`1.SmallStringKeyDictionary`1.UniqueKeys"/>.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType">
            <summary>
            Represents a type of a regular expression tree node.
            The value of an enumeration element corresponds to the priority of the operation it describes.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.Union">
            <summary>
            Represents the union operation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.Concat">
            <summary>
            Represents the concatenation operation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.Star">
            <summary>
            Represents the Kleene star operation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.Empty">
            <summary>
            Represents an empty string.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.ElementSet">
            <summary>
            Represents a set of elements.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Automata.RegexpTreeNodeType.Nothing">
            <summary>
            Represents the empty language, i.e. a language that contains no strings.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.StringAutomaton">
            <summary>
            Represents an automaton defined on <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.StringTransducer">
            <summary>
            Represents a transducer defined on pairs of strings.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator">
            <summary>
            Provides the ability to manipulate strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator.ToSequence(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Converts a given sequence of characters to a string.
            </summary>
            <param name="elements">The sequence of characters.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator.GetLength(System.String)">
            <summary>
            Gets the length of a given string.
            </summary>
            <param name="sequence">The string.</param>
            <returns>The length of the string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator.GetElement(System.String,System.Int32)">
            <summary>
            Gets the character at a given position in a given string.
            </summary>
            <param name="sequence">The string.</param>
            <param name="index">The position.</param>
            <returns>The character at the given position in the string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator.SequencesAreEqual(System.String,System.String)">
            <summary>
            Checks if given strings are equal.
            </summary>
            <param name="sequence1">The first string.</param>
            <param name="sequence2">The second string.</param>
            <returns><see langword="true"/> if the strings are equal, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.StringManipulator.Concat(System.String,System.String)">
            <summary>
            Creates a string by copying the first string and then appending the second string to it.
            </summary>
            <param name="sequence1">The first string.</param>
            <param name="sequence2">The second string.</param>
            <returns>The created string.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6">
            <summary>
            A base class for implementations of distributions over sequences.
            </summary>
            <typeparam name="TSequence">The type of a sequence.</typeparam>
            <typeparam name="TElement">The type of a sequence element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over sequence elements.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate sequences.</typeparam>
            <typeparam name="TWeightFunction">The type of an underlying function mapping sequences to weights. Currently must be a weighted finite state automaton.</typeparam>
            <typeparam name="TThis">The type of a concrete distribution class.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfPower`1">
            <summary>
            Whether the distribution can compute the expectation of another distribution raised to a power.
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfPower`1.GetLogAverageOfPower(`0,System.Double)">
            <summary>
            The log-integral of one distribution times another raised to a power.
            </summary>
            <param name="that">The other distribution</param>
            <param name="power">The exponent</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*Math.Pow(that.Evaluate(x),power))</c></returns>
            <remarks>This is not the same as GetLogAverageOf(that^power) because it includes the normalization constant of that.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1">
            <summary>
            Whether the distribution supports the expected logarithm of one instance under another
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1.GetAverageLog(`0)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer">
            <summary>
            Whether the distribution can compute its normalizer.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer.GetLogNormalizer">
            <summary>
            The logarithm of the distribution's normalizer, i.e. the integral of its minimal exponential-family representation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampleable`1">
            <summary>
            Whether the distribution supports sampling
            </summary>
            <typeparam name="T">The sample type (i.e. the domain type)</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample">
            <summary>
            Sample the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample(`0)">
            <summary>
            Sample the distribution and provide a place to put the result.
            </summary>
            <param name="result">Where to put the result. This is ignored for value-type domains</param>
            <returns></returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SequenceManipulator">
            <summary>
            A sequence manipulator.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.sequenceToWeight">
            <summary>
            A function mapping sequences to weights (non-normalized probabilities).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.isNormalized">
            <summary>
            Specifies whether the <see cref="F:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.sequenceToWeight"/> is normalized.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.point">
            <summary>
            If the distribution is a point mass, stores the point. Otherwise it is set to <see langword="null"/>.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.#ctor">
            <summary>
            Initializes a new instance of the
            <see cref="T:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6"/> class
            by setting the underlying weight function to be zero everywhere.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.PointMass(`0)">
            <summary>
            Creates a point mass distribution.
            </summary>
            <param name="point">The point.</param>
            <returns>The created point mass distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Uniform">
            <summary>
            Creates an improper distribution which assigns the probability of 1 to every sequence.
            </summary>
            <returns>The created uniform distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Zero">
            <summary>
            Creates an improper distribution which assigns zero probability to every sequence.
            </summary>
            <returns>The created zero distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.FromWeightFunction(`4)">
            <summary>
            Creates a distribution from a given weight (non-normalized probability) function.
            </summary>
            <param name="sequenceToWeight">The weight function specifying the distribution.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.FromWorkspace(`4)">
            <summary>
            Creates a distribution which will use a given weight function as a workspace.
            Any modifications to the workspace after the distribution has been created
            would put the distribution into an invalid state.
            </summary>
            <param name="workspace">The workspace to create the distribution from.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Empty">
            <summary>
            Creates a distribution which puts all probability mass on the empty sequence.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SingleElement(`2)">
            <summary>
            Creates a distribution over sequences of length 1 induced by a given distribution over sequence elements.
            </summary>
            <param name="elementDistribution">The distribution over sequence elements.</param>
            <returns>The created distribution.</returns>
            <remarks>
            The distribution created by this method can differ from the result of
            <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`2,System.Int32,System.Nullable{System.Int32})"/> with both min and max number of times to repeat set to 1 since the latter always creates a partial uniform distribution.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SingleElement(`1)">
            <summary>
            Creates a distribution which puts all probability mass on a sequence containing only a given element.
            </summary>
            <param name="element">The element.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(System.Collections.Generic.IEnumerable{`5})">
            <summary>
            Creates a distribution which is a uniform mixture of a given set of distributions.
            </summary>
            <param name="distributions">The set of distributions to create a mixture from.</param>
            <returns>The created mixture distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(`5[])">
            <summary>
            Creates a distribution which is a uniform mixture of a given set of distributions.
            </summary>
            <param name="distributions">The set of distributions to create a mixture from.</param>
            <returns>The created mixture distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(System.Double,`5,System.Double,`5)">
            <summary>
            Creates a mixture of a given pair of distributions.
            </summary>
            <param name="weight1">The weight of the first distribution.</param>
            <param name="dist1">The first distribution.</param>
            <param name="weight2">The weight of the second distribution.</param>
            <param name="dist2">The second distribution.</param>
            <returns>The created mixture distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Double}})">
            <summary>
            Creates a distribution which assigns specified probabilities to given sequences.
            Probabilities do not have to be normalized.
            </summary>
            <param name="sequenceProbPairs">A list of (sequence, probability) pairs.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a distribution which is uniform over a given set of sequences.
            </summary>
            <param name="sequences">The set of sequences to create a distribution from.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOf(`0[])">
            <summary>
            Creates a distribution which is uniform over a given set of sequences.
            </summary>
            <param name="sequences">The set of sequences to create a distribution from.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Any(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over sequences of length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible sequence length.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`1,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over sequences of length within the given bounds.
            Sequence elements are restricted to be equal to a given element.
            If <paramref name="maxTimes"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="element">The element.</param>
            <param name="minTimes">The minimum possible sequence length. Defaults to 1.</param>
            <param name="maxTimes">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`2,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over sequences of length within the given bounds.
            Sequence elements are restricted to be non-zero probability elements from a given distribution.
            If <paramref name="maxTimes"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
            <param name="minTimes">The minimum possible sequence length. Defaults to 1.</param>
            <param name="maxTimes">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`5,System.Int32,System.Nullable{System.Int32})">
            <summary>
            <para>
            Creates a distribution by applying <see cref="M:MicrosoftResearch.Infer.Distributions.Automata.Automaton`5.Repeat(`4,System.Int32,System.Nullable{System.Int32})"/>
            to the weight function of a given distribution,
            which is additionally scaled by the inverse of <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogAverageOf(`5)"/> with itself.
            So, if the given distribution is partial uniform, the result will be partial uniform over the repetitions of
            sequences covered by the distribution.
            </para>
            <para>
            If <paramref name="maxTimes"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </para>
            </summary>
            <param name="dist">The distribution.</param>
            <param name="minTimes">The minimum number of repetitions. Defaults to 1.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.ZeroOrMore(`5,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`5,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 0.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.ZeroOrMore(`1,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`1,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 0.
            </summary>
            <param name="element">The element.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.ZeroOrMore(`2,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`2,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 0.
            </summary>
            <param name="allowedElements">The allowed sequence elements.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOrMore(`5,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`5,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 1.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOrMore(`1,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`1,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 1.
            </summary>
            <param name="element">The element.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.OneOrMore(`2,System.Nullable{System.Int32})">
            <summary>
            An alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`2,System.Int32,System.Nullable{System.Int32})"/> with the minimum number of repetitions set to 0.
            </summary>
            <param name="allowedElements">The allowed sequence elements.</param>
            <param name="maxTimes">
            The maximum number of repetitions, or <see langword="null"/> for no upper bound.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Optional(`5,System.Double)">
            <summary>
            Creates a mixture of a given distribution and a point mass representing an empty sequence.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="prob">The probability of the component corresponding to <paramref name="dist"/>.</param>
            <returns>The created mixture.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Append(`1,System.Byte)">
            <summary>
            Creates a distribution over concatenations of sequences from the current distribution and a given element.
            </summary>
            <param name="element">The element to append.</param>
            <param name="group">The group for the appended element.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Append the given element to the sampled sequence and output the result.
            </description></item>
            </list>
            </remarks>
            <returns>The distribution over the concatenations of sequences and the element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Append(`2,System.Byte)">
            <summary>
            Creates a distribution over concatenations of sequences from the current distribution
            and elements from a given distribution.
            </summary>
            <param name="elementDistribution">The distribution to generate the elements from.</param>
            <param name="group">The group for the appended element.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            2) Sample a random element from <paramref name="elementDistribution"/>.
            </description></item>
            <item><description>
            3) Append the sampled element to the sampled sequence and output the result.
            </description></item>
            </list>
            </remarks>
            <returns>The distribution over the concatenations of sequences and elements.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Append(`0,System.Byte)">
            <summary>
            Creates a distribution over concatenations of sequences from the current distribution and a given sequence.
            </summary>
            <param name="sequence">The sequence to append.</param>
            <param name="group">The group for the appended sequence.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Append <paramref name="sequence"/> to it and output the result.
            </description></item>
            </list>
            </remarks>
            <returns>The distribution over the concatenations of sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Append(`5,System.Byte)">
            <summary>
            Creates a distribution over concatenations of sequences from the current distribution
            and sequences from a given distribution.
            </summary>
            <param name="dist">The distribution over the sequences to append.</param>
            <param name="group">The group for the appended sequence.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Sample a random sequence from <paramref name="dist"/>.
            </description></item>
            <item><description>
            Output the concatenation of the sampled pair of sequences.
            </description></item>
            </list>
            </remarks>
            <returns>The distribution over the concatenations of sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.AppendInPlace(`1,System.Byte)">
            <summary>
            Replaces the current distribution by a distribution over concatenations of sequences
            from the current distribution and a given element.
            </summary>
            <param name="element">The element to append.</param>
            <param name="group">The group for the appended element.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Append the given element to the sampled sequence and output the result.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.AppendInPlace(`2,System.Byte)">
            <summary>
            Replaces the current distribution by a distribution over concatenations of sequences
            from the current distribution and elements from a given distribution.
            </summary>
            <param name="elementDistribution">The distribution to generate the elements from.</param>
            <param name="group">The group for the appended element.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Sample a random element from <paramref name="elementDistribution"/>.
            </description></item>
            <item><description>
            Append the sampled element to the sampled sequence and output the result.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.AppendInPlace(`0,System.Byte)">
            <summary>
            Replaces the current distribution by a distribution over concatenations of sequences
            from the current distribution and a given sequence.
            </summary>
            <param name="sequence">The sequence to append.</param>
            <param name="group">The group for the appended sequence.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Append <paramref name="sequence"/> to it and output the result.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.AppendInPlace(`5,System.Byte)">
            <summary>
            Replaces the current distribution by a distribution over concatenations of sequences
            from the current distribution and sequences from a given distribution.
            </summary>
            <param name="dist">The distribution over the sequences to append.</param>
            <param name="group">The group for the appended sequence.</param>
            <remarks>
            The result is equivalent to the distribution produced by the following sampling procedure:
            <list type="number">
            <item><description>
            Sample a random sequence from the current distribution.
            </description></item>
            <item><description>
            Sample a random sequence from <paramref name="dist"/>.
            </description></item>
            <item><description>
            Output the concatenation of the sampled pair of sequences.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetProbabilityFunction">
            <summary>
            Gets a weight function that maps sequences to their probabilities under this distribution.
            </summary>
            <returns>The function mapping sequences to probabilities.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetWeightFunction(`4)">
            <summary>
            Replaces the current distribution by a distribution induced by a given weight function.
            </summary>
            <param name="newSequenceToWeight">The function mapping sequences to weights.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetWorkspace">
            <summary>
            Returns the underlying weight function, or <see langword="null"/>, if the distribution is a point mass.
            Any modifications of the returned function will put the distribution into an undefined state.
            </summary>
            <returns>The underlying weight function, or <see langword="null"/> if the distribution is a point mass.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetWorkspaceOrPoint">
            <summary>
            Returns the underlying weight function, or, if the distribution is a point mass,
            a functional representation of the corresponding point.
            Any modifications of the returned function will put the distribution into an undefined state.
            </summary>
            <returns>The underlying weight function or a functional representation of the point.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.ToString">
            <summary>
            Returns a string that represents the distribution.
            </summary>
            <returns>
            A string that represents the distribution.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.ToString(MicrosoftResearch.Infer.Distributions.Automata.ISequenceDistributionFormat)">
            <summary>
            Returns a string that represents the distribution.
            </summary>
            <param name="format">The format.</param>
            <returns>A string that represents the distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetTo(`5)">
            <summary>
            Replaces the current distribution by a copy of the given distribution.
            </summary>
            <param name="that">The distribution to set the current distribution to.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToZero">
            <summary>
            Replaces the current distribution by an improper zero distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Product(`5)">
            <summary>
            Returns a product of the current distribution and a given one.
            </summary>
            <param name="that">The distribution to compute the product with.</param>
            <returns>The product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToProduct(`5,`5)">
            <summary>
            Replaces the current distribution with a product of a given pair of distributions.
            </summary>
            <param name="dist1">The first distribution.</param>
            <param name="dist2">The second distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToProductAndReturnLogNormalizer(`5,`5)">
            <summary>
            Replaces the current distribution with a product of a given pair of distributions
            Returns the logarithm of the normalizer for the product (as returned by <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogAverageOf(`5)"/>).
            </summary>
            <param name="dist1">The first distribution.</param>
            <param name="dist2">The second distribution.</param>
            <returns>The logarithm of the normalizer for the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogAverageOf(`5)">
            <summary>
            Returns the logarithm of the probability that the current distribution would draw the same sample
            as a given one.
            </summary>
            <param name="that">The given distribution.</param>
            <returns>The logarithm of the probability that distributions would draw the same sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogAverageOfPower(`5,System.Double)">
            <summary>
            Computes the log-integral of one distribution times another raised to a power.
            </summary>
            <param name="that">The other distribution</param>
            <param name="power">The exponent</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x) * Math.Pow(that.Evaluate(x), power))</c></returns>
            <remarks>
            <para>
            This is not the same as GetLogAverageOf(that^power) because it includes the normalization constant of that.
            </para>
            <para>Powers other than 1 are not currently supported.</para>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetAverageLog(`5)">
            <summary>
            Computes the expected logarithm of a given distribution under this distribution.
            Not currently supported.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogNormalizer">
            <summary>
            Returns the logarithm of the normalizer of the exponential family representation of this distribution.
            Normalizer of an improper distribution is defined to be 1.
            </summary>
            <returns>The logarithm of the normalizer.</returns>
            <remarks>Getting the normalizer is currently supported for improper distributions only.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToSum(System.Double,`5,System.Double,`5)">
            <summary>
            Replaces the current distribution with a mixture of a given pair of distributions.
            </summary>
            <param name="weight1">The weight of the first distribution.</param>
            <param name="dist1">The first distribution.</param>
            <param name="weight2">The weight of the second distribution.</param>
            <param name="dist2">The second distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToSumLog(System.Double,`5,System.Double,`5)">
            <summary>
            Replaces the current distribution with a mixture of a given pair of distributions.
            </summary>
            <param name="logWeight1">The logarithm of the weight of the first distribution.</param>
            <param name="dist1">The first distribution.</param>
            <param name="logWeight2">The logarithm of the weight of the second distribution.</param>
            <param name="dist2">The second distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToPower(`5,System.Double)">
            <summary>
            Replaces the current distribution with a given distribution raised to a given power.
            </summary>
            <param name="that">The distribution to raise to the power.</param>
            <param name="power">The power.</param>
            <remarks>Only 0 and 1 are currently supported as powers.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToRatio(`5,`5,System.Boolean)">
            <summary>
            Replaces the current distribution with the ratio of a given pair of distributions. Not currently supported.
            </summary>
            <param name="numerator">The numerator in the ratio.</param>
            <param name="denominator">The denominator in the ratio.</param>
            <param name="forceProper">Specifies whether the ratio must be proper.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.System#ICloneable#Clone">
            <summary>
            Creates a copy of the current distribution.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Clone">
            <summary>
            Creates a copy of the current distribution.
            </summary>
            <returns>The created copy.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.MaxDiff(System.Object)">
            <summary>
            Gets a value indicating how close this distribution is to a given one
            in terms of probabilities they assign to sequences.
            </summary>
            <param name="that">The other distribution.</param>
            <returns>A non-negative value, which is close to zero if the two distribution assign similar values to all sequences.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetLogProb(`0)">
            <summary>
            Gets the logarithm of the probability of a given sequence under this distribution.
            If the distribution is improper, returns the logarithm of the value of the underlying unnormalized weight function.
            </summary>
            <param name="sequence">The sequence to get the probability for.</param>
            <returns>The logarithm of the probability of the sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Evaluate(`0)">
            <summary>
            Gets the probability of a given sequence under this distribution.
            If the distribution is improper, returns the value of the underlying unnormalized weight function.
            </summary>
            <param name="sequence">The sequence to get the probability for.</param>
            <returns>The probability of the sequence.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Sample(`0)">
            <summary>
            Draws a sample from the distribution.
            </summary>
            <param name="result">A pre-allocated storage for the sample (will be ignored).</param>
            <returns>The drawn sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Sample">
            <summary>
            Draws a sample from the distribution.
            </summary>
            <returns>The drawn sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToUniformOf(`2)">
            <summary>
            Replaces the current distribution with an improper distribution which assigns the probability of 1 to every sequence.
            Sequence elements are restricted to be non-zero probability elements from a given distribution.
            </summary>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToUniform">
            <summary>
            Replaces the current distribution with an improper distribution which assigns the probability of 1 to every sequence.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToPartialUniform">
            <summary>
            Sets the distribution to be uniform over its support.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToPartialUniformOf(`5)">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="dist">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsPartialUniform">
            <summary>
            Checks whether the distribution is uniform over its support.
            </summary>
            <returns><see langword="true"/> if the distribution is uniform over its support, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsProper">
            <summary>
            Checks whether the current distribution is proper.
            </summary>
            <returns><see langword="true"/> if the current distribution is proper, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsUniform">
            <summary>
            Checks whether the current distribution is uniform over all possible sequences.
            </summary>
            <returns><see langword="true"/> if the current distribution is uniform over all possible sequences, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsZero">
            <summary>
            Gets a value indicating whether the current distribution
            is an improper distribution which assigns zero probability to every sequence.
            </summary>
            <returns>
            <see langword="true"/> if the current distribution
            is an improper distribution that assigns zero probability to every sequence, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Equals(System.Object)">
            <summary>
            Checks if <paramref name="obj"/> equals to this distribution (i.e. represents the same distribution over sequences).
            </summary>
            <param name="obj">The object to compare this distribution with.</param>
            <returns><see langword="true"/> if this distribution is equal to <paramref name="obj"/>, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.GetHashCode">
            <summary>
            Gets the hash code of this distribution.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.UniformOf(`2,System.Double)">
            <summary>
            Creates an improper distribution which assigns a given probability to every sequence.
            Sequence elements are restricted to be non-zero probability elements from a given distribution.
            </summary>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
            <param name="uniformLogProb">The logarithm of the probability assigned to every allowed sequence.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetToUniformOf(`2,System.Double)">
            <summary>
            Replaces the current distribution with an improper distribution which assigns a given probability to every sequence.
            Sequence elements are restricted to be non-zero probability elements from a given distribution.
            </summary>
            <param name="allowedElements">The distribution representing allowed sequence elements.</param>
            <param name="uniformLogProb">The logarithm of the probability assigned to every allowed sequence.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.DoSetToProduct(`5,`5,System.Boolean)">
            <summary>
            Replaces the current distribution with a product of a given pair of distributions,
            optionally normalizing the result.
            </summary>
            <param name="dist1">The first distribution.</param>
            <param name="dist2">The second distribution.</param>
            <param name="computeLogNormalizer">Specifies whether the product normalizer should be computed and used to normalize the product.</param>
            <returns>The logarithm of the normalizer for the product if requested, <see langword="null"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.UsesGroups">
            <summary>
            Checks if the distribution uses groups.
            </summary>
            <returns><see langword="true"/> if the distribution uses groups, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SetWorkspace(`4)">
            <summary>
            Replaces the workspace (weight function) of the current distribution with a given one.
            </summary>
            <param name="workspace">The workspace to replace the current one with.</param>
            <remarks>
            If the given workspace represents a point mass, the distribution would be converted to a point mass
            and the workspace would be set to <see langword="null"/>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.EnsureNormalized">
            <summary>
            Normalizes the underlying weight function (if there is one), if it hasn't been normalized before.
            If the distribution is improper, does nothing but marks it as normalized.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.NormalizeStructure">
            <summary>
            Modifies the distribution to be in normalized form e.g. using special
            case structures for point masses.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.TryComputePoint">
            <summary>
            Returns a point mass represented by the current distribution, or <see langword="null"/>,
            if it doesn't represent a point mass.
            </summary>
            <returns>The point mass represented by the distribution, or <see langword="null"/>.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Point">
            <summary>
            Gets or sets the point mass represented by the distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsPointMass">
            <summary>
            Gets a value indicating whether the current distribution represents a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.IsEmpty">
            <summary>
            Gets a value indicating whether the current distribution
            puts all probability mass on the empty sequence.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats">
            <summary>
            A collection of sequence distribution formats.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats"/> class.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats.GraphViz">
            <summary>
            Gets a format for converting a sequence distribution to a GraphViz representation of the underlying automaton.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats.Regexp">
            <summary>
            Gets a format for converting a sequence distribution to a regular expression representing its support.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SequenceDistributionFormats.Friendly">
            <summary>
            Gets a format for converting a sequence distribution to a friendly regular expression like string representing its support.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset">
            <summary>
            Represents a sparse list of Bernoulli distributions considered as a distribution over a variable-sized list of
            integers, which are the indices of elements in the boolean list with value 'true'.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.sparseBernoulliList">
            <summary>
            Embedded <see cref="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SparseBernoulliList"/> instance.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            of the given size, and assigns all elements to the specified common value.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{MicrosoftResearch.Infer.Distributions.Bernoulli}})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is,
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(MicrosoftResearch.Infer.Collections.ISparseList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from a sparse list of <see cref="T:MicrosoftResearch.Infer.Distributions.Bernoulli"/> distributions.
            </summary>
            <param name="bernoullis">The sparse list of Bernoulli distributions.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from an instance of the same type.
            </summary>
            <param name="that">The instance to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from a <see cref="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SparseBernoulliList"/> instance.
            </summary>
            <param name="sparseBernoulliList"><see cref="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SparseBernoulliList"/> instance.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            of the given size, and assigns all elements to the specified common value.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{MicrosoftResearch.Infer.Distributions.Bernoulli}},System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is,
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(MicrosoftResearch.Infer.Collections.ISparseList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from a sparse list of Bernoulli distributions.
            </summary>
            <param name="bernoullis">The sparse list of Bernoulli distributions.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSize(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromBernoulli(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            with the specified number of elements all of which are set to the specified <see cref="T:MicrosoftResearch.Infer.Distributions.Bernoulli"/> instance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{MicrosoftResearch.Infer.Distributions.Bernoulli}},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSparseList(MicrosoftResearch.Infer.Collections.ISparseList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from a sparse list of Bernoulli distributions.
            </summary>
            <param name="bernoullis">The sparse list of Bernoulli distributions.</param>
            <param name="tolerance">The tolerance.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromProbTrue(System.Int32,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            with each element having a given probability of true.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="probTrue">The desired probability of true.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromLogOdds(System.Int32,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            with each element having a given log odds.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logOdds">The desired log odds.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromProbTrue(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            with each element having a given probability of true.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="probTrue">The desired probability of true.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromLogOdds(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            with each element having a given log odds.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logOdds">The desired log odds.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromProbTrue(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            from a sparse list of probability true.
            </summary>
            <param name="probTrue">The sparse list of probability of true.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromLogOdds(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            from a sparse list of log odds
            </summary>
            <param name="logOdds">The sparse list of log odds.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromProbTrue(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            from a sparse list of probability true.
            </summary>
            <param name="probTrue">The sparse list of probability of true.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromLogOdds(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given size
            from a sparse list of log odds.
            </summary>
            <param name="logOdds">The sparse list of log odds.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSize(System.Int32)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromBernoulli(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class with the specified number of elements
            all of which are set to the specified <see cref="T:MicrosoftResearch.Infer.Distributions.Bernoulli"/> instance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{MicrosoftResearch.Infer.Distributions.Bernoulli}})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class of a given length
            and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is,
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.FromSparseList(MicrosoftResearch.Infer.Collections.ISparseList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> class from a sparse list of Bernoulli distributions.
            </summary>
            <param name="bernoullis">The sparse list of Bernoulli distributions.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Samples from a list of Bernoulli distributions with the specified vector of P(true) values.
            </summary>
            <param name="probTrue">the vector of P(true) values.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SubsetToList(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            Converts index subset to a sparse list of boolean values.
            </summary>
            <param name="indices">The indices.</param>
            <param name="length">The length of the boolean list.</param>
            <returns>The equivalent sparse list of boolean values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetLogProb(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Gets the log probability of the given value under this distribution.
            </summary>
            <param name="value">The value.</param>
            <returns>The log probability of the given value under this distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Clone">
            <summary>
            Clones this object.
            </summary>
            <returns>The clone.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample">
            <summary>
            Samples a list of integers from this distribution.
            </summary>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Samples a list of integers from this distribution.
            </summary>
            <param name="result">Where to put the resulting sample.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToProduct(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to a product of two other such distributions.
            </summary>
            <param name="a">The left hand side.</param>
            <param name="b">The right hand side.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetTo(System.Collections.Generic.IEnumerable{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Sets this BernoulliIntegerSubset distribution from an enumerable collection of Bernoulli distribution.
            </summary>
            <param name="value">The (usually sparse) enumerable collection of Bernoulli distributions.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetTo(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to another such distribution.
            </summary>
            <param name="value">The distribution to set.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToPower(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the power another such distribution.
            </summary>
            <param name="value">The distribution to be raised to a power.</param>
            <param name="exponent">The exponent.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToRatio(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Boolean)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the ratio of two other such distributions.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <param name="forceProper">Whether to force the result to be proper.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the weighted sum of two other such distributions.
            </summary>
            <param name="weight1">The first weight.</param>
            <param name="value1">The first distribution.</param>
            <param name="weight2">The second weight.</param>
            <param name="value2">The second distribution.</param>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Gets the log of the integral of the product of this BernoulliIntegerSubset distribution and another such distribution.
            </summary>
            <param name="that">The other distribution.</param>
            <returns>The log average of the other distribution under this distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double)">
            <summary>
            Returns the log of the integral of the product of BernoulliIntegerSubset distribution and another
            BernoulliIntegerSubset distribution raised to a power.
            </summary>
            <param name="that">The other distribution.</param>
            <param name="power">The exponent.</param>
            <returns>The average of the power of the other distribution under this distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetAverageLog(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c>.</returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.MaxDiff(System.Object)">
            <summary>
            The max difference between this distribution and another distribution.
            </summary>
            <param name="thatd">The other distribution.</param>
            <returns>The maximum difference between this distribution and the other.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToUniform">
            <summary>
            Sets this sparse Bernoulli list to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.IsUniform">
            <summary>
            Gets a value indicating whether this distribution is uniform or not.
            </summary>
            <returns>True if uniform, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.op_Multiply(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution which is the product of two others.
            </summary>
            <param name="a">The first distribution.</param>
            <param name="b">The second distribution.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.op_Division(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution which is the ratio of two others.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution which is the power of another.
            </summary>
            <param name="dist">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> distribution.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SparseBernoulliList">
            <summary>
            Gets or sets the embedded <see cref="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SparseBernoulliList"/> instance which maintains the parameters of this distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Point">
            <summary>
            Gets or sets the distribution as a point value integer array. This is a sparse method - the integers specify
            the indices where elements are true - all other elements are false.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.IsPointMass">
            <summary>
            Gets a value indicating whether this is a point mass or not.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Dimension">
            <summary>
            Gets a value representing the size of the discrete domain.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Binomial">
            <summary>
            Binomial distribution over the integers [0,n]
            </summary>
            <remarks>
            The formula for the distribution is <c>p(x) = n!/(n-x)!/x! p^x (1-p)^(n-x)</c>.
            In this implementation, we use a generalization that includes two extra shape parameters (a,b)
            The formula for the generalized distribution is <c>p(x) =propto 1/x!^a 1/(n-x)!^b exp(x*logOdds)</c>.
            With this extension, we can represent a uniform distribution via (logOdds=0,a=0,b=0) and
            a point mass via logOdds=+/-infinity or a=infinity or b=infinity.
            This family is closed under multiplication, while the standard Binomial is not.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMean`1">
            <summary>
            Whether the distribution supports retrieval of a mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMean`1.GetMean">
            <remarks><para>
            </para><para>
            This is not a property because it is not reasonable to expect that distributions
            would generally have their mean as a data member.  Computing the mean could take a long
            time for some distributions.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetVariance`1">
            <summary>
            Whether the distribution supports retrieval of a variance value
            </summary>
            <typeparam name="VarType">Type of the variance value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetVariance`1.GetVariance">
            <summary>
            Method to get the variance
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are returned as 'out' argiments
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2.GetMeanAndVariance(`0@,`1@)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Binomial.SetToRatio(MicrosoftResearch.Infer.Distributions.Binomial,MicrosoftResearch.Infer.Distributions.Binomial,System.Boolean)">
            <summary>
            Set this distribution to equal the ratio of two distributions
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet">
            <summary>
            Represents the distribution proportion to x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint setting of mean and variance
            </summary>
            <typeparam name="MeanType"></typeparam>
            <typeparam name="VarType"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2.SetMeanAndVariance(`0,`1)">
            <summary>
            Set the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>In cases where the given mean and variance cannot be matched exactly, the mean
            should have priority.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.errorMessage">
            <summary>
            Error message for proposal distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.D">
            <summary>
            Parameter D for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.K">
            <summary>
            Parameter K for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMean">
            <summary>
            Gets the expected value E(x) - calculated as shape/rate
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetVariance">
            <summary>
            Gets the variance - calculated as shape/rate^2
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GammaApproximation">
            <summary>
            This is an asymptotic approximation to this distribution, derived from the Rocktaeschel approximation:
            ln Gamma(x) \approx (x-.5)*ln(x) - x +.5*ln(2*pi)
            </summary>
            <returns>A gamma approximation to this distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SmartProposal(System.Double@,System.Double@)">
            <summary>
            Find a Laplace approximation to the density of this distribution under a change of variable x=log(y)
            </summary>
            <param name="mean">Mean of approximation</param>
            <param name="variance">Variance of approximation</param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.approximationMethod">
            <summary>
            Approximation method to use for non-analytic expectations. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance. Note for K!=0 this requires quadrature. 
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetShapeAndRate(System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromShapeAndRate(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetScale">
            <summary>
            Gets the scale (1/rate)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetShapeAndScale(System.Double@,System.Double@)">
            <summary>
            Gets the shape and scale (1/rate)
            </summary>
            <param name="shape">Where to put the shape</param>
            <param name="scale">Where to put the scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetShapeAndScale(System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromShapeAndScale(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution with the given mean and mean logarithm.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Gamma distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromLogMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution with the given log mean and mean logarithm.
            </summary>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetNatural(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution.
            </summary>
            <param name="shapeMinus1">The shape parameter - 1.</param>
            <param name="rate">rate = 1/scale</param>
            <param name="D"></param>
            <param name="K"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanLog">
            <summary>
            Computes E[log(x)] using quadrature if necessary
            </summary>
            <returns>E[log(x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanLogGamma(System.Double)">
            <summary>
             Compute E[log G(factor * x)] using quadrature
            </summary>
            <param name="factor">Multiplier for x</param>
            <returns>E[log G(factor * x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanInverse">
            <summary>
            Computes E[1/x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToUniform">
            <summary>
            Sets this Conjugate Dirichlet instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogProb(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the Conjugate Dirichlet density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <param name="D">D parameter</param>
            <param name="K">K parameter</param>
            <returns>log(Conjugate Dirichlet(x;shape,rate,D,K))</returns>
            <remarks>
            The distribution is <c>x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogProb(System.Double)">
            <summary>
            Logarithm of this Conjugate Dirichlet density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Conjugate Dirichlet(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetAverageLog(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsProper">
            <summary>
            Asks whether this Conjugate Dirichlet instance is proper or not. A Conjugate Dirichlet distribution
            is proper if it's approximating gamma is proper
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Conjugate Dirichlet distribution is proper or not. A Conjugate Dirichlet distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Conjugate Dirichlet</param>
            <param name="rate">rate parameter for the Conjugate Dirichlet</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            The log of the integral of the product of this Conjugate Dirichlet and that Conjugate Dirichlet
            </summary>
            <param name="that">That Conjugate Dirichlet</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample">
            <summary>
            Samples from this Conjugate Dirichlet distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample(System.Double)">
            <summary>
            Samples from this Conjugate Dirichlet distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Conjugate Dirichlet distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Samples from a Conjugate Dirichlet distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetTo(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Sets this Conjugate Dirichlet instance to have the parameter values of that Conjugate Dirichlet instance
            </summary>
            <param name="that">That Conjugate Dirichlet</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToProduct(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Sets the parameters to represent the product of two Gammas.
            </summary>
            <param name="a">The first Conjugate Dirichlet</param>
            <param name="b">The second Conjugate Dirichlet</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Multiply(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Creates a new Conjugate Dirichlet which the product of two other Conjugate Dirichlets
            </summary>
            <param name="a">First Conjugate Dirichlet</param>
            <param name="b">Second Conjugate Dirichlet</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToRatio(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Conjugate Dirichlets.
            </summary>
            <param name="numerator">The numerator Conjugate Dirichlet</param>
            <param name="denominator">The denominator Conjugate Dirichlet</param>
            <param name="forceProper"></param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Division(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Creates a new Conjugate Dirichlet which the ratio of two other Conjugate Dirichlets
            </summary>
            <param name="numerator">numerator Conjugate Dirichlet</param>
            <param name="denominator">denominator Conjugate Dirichlet</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToPower(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Conjugate Dirichlet to some exponent.
            </summary>
            <param name="dist">The source Conjugate Dirichlet</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Set the mean and variance to match a mixture of two Gammas.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first Conjugate Dirichlet</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second Conjugate Dirichlet</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Conjugate Dirichlet
            and that Conjugate Dirichlet
            </summary>
            <param name="thatd">That Conjugate Dirichlet</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Equality(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Inequality(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a Conjugate Dirichlet distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <param name="D"></param>
            <param name="K"></param>
            <remarks>
            The distribution is <c>x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromNatural(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution from its natural parameters.
            </summary>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <param name="D"></param>
            <param name="K"></param>
            <returns>A new Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.#ctor(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Clone">
            <summary>
            Clones this Conjugate Dirichlet. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Conjugate Dirichlet type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Uniform">
            <summary>
            Create a uniform Conjugate Dirichlet distribution.
            </summary>
            <returns>A new uniform Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.PointMass(System.Double)">
            <summary>
            Creates a point mass Conjugate Dirichlet distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod">
            <summary>
            Approximation method to use for non-analytic expectations. 
            Asymptotic: use expectations under the approximating Gamma distribution
            GaussHermiteQuadrature: Use Gauss-Hermite quadrature with 32 quadrature points
            ClenshawCurtisQuadrature: Use Clenshaw Curtis quadrature with an adaptive number of quadrature points
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.Asymptotic">
            <summary>
            Uses the approximation Gamma(Shape+K(D-1)/2,Rate-KDlogD)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussHermiteQuadrature">
            <summary>
            Gaussian Hermite quadrature, using Asymptotic as the proposal distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.ClenshawCurtisQuadrature">
            <summary>
            Clenshaw Curtis Quadrature
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussLaguerreQuadrature">
            <summary>
            Gauss Laguerre Quadrature
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussHermiteQuadratureLaplace">
            <summary>
            Gaussian Hermite quadrature, using Asymptotic as the proposal distribution if shape less than 1 and 
            Laplace approximation as the proposal distribution otherwise
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteChar">
            <summary>
            A discrete distribution over characters.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2">
            <summary>
            A generic base class for discrete distributions over a type T.
            </summary>
            <remarks>
            This class makes it straightforward to implement discrete distributions
            over types other than int.  It is only necessary to make a subclass of
            this abstract class, add a constructor and implement two methods to convert 
            the desired type T to and from an integer. 
            
            Internally, this class wraps a Discrete distribution and uses it to provide
            all functionality.
            </remarks>
            <typeparam name="T">The domain type of this distribution</typeparam>
            <typeparam name="TThis">The type of the subclass (allows factory methods return the correct type)</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a discrete
            </summary>
            <param name="dimension">The dimension of the underlying discrete</param>
            <param name="sparsity">The sparsity of the underlying discrete</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Uniform">
            <summary>
            Creates a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromDiscrete(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a distribution using the probabilities from the given discrete distribution.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromProbs(System.Double[])">
            <summary>
            Creates a distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromVector(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a distribution from the given vector of probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRange(`0,`0)">
            <summary>
            Creates a Discrete distribution which is uniform over values from
            start to end inclusive.
            </summary>
            <param name="start">The first value included in the distribution</param>
            <param name="end">The last value included in the distribution</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(`0[])">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an array whose length must therefore be
            even.
            </summary>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an enumerable whose length must therefore be
            even.
            </summary>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformOver(`0[])">
            <summary>
            Creates a Discrete distribution which is uniform over the specified set of values and zero elsewhere.
            </summary>
            <param name="values">The values.</param>
            <returns>Discrete which is uniform over the specified set of values and zero elsewhere.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformOver(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a Discrete distribution which is uniform over the specified set of values and zero elsewhere.
            </summary>
            <param name="values">The values.</param>
            <returns>Discrete which is uniform over the specified set of values and zero elsewhere.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.PointMass(`0)">
            <summary>
            Creates a point mass distribution.
            </summary>
            <param name="value">The allowed value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogProb(`0)">
            <summary>
            Evaluates the log density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal probs Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetInternalDiscrete">
            <summary>
            Gets the internal discrete distribution that this distribution wraps.
            </summary>
            <returns>The internal discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetProbs">
            <summary>
            Gets the probability at each index.
            </summary>
            <returns>The vector of probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogProbs">
            <summary>
            Gets the log-probability at each index.
            </summary>
            <returns>The vector of log-probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetMode">
            <summary>
            Gets the mode of the distribution
            </summary>
            <returns>The value with the highest probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the probability of each index.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Clone">
            <summary>
            Returns a clone of this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.IsUniform">
            <summary>
            Returns true if the distribution is uniform.
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToUniform">
            <summary>
            Sets this instance to a uniform discrete (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.IsPartialUniform">
            <summary>
            Checks whether the distribution is uniform over its support.
            </summary>
            <returns>True if the distribution is uniform over its support, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToPartialUniform">
            <summary>
            Sets the distribution to be uniform over its support.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToPartialUniformOf(`1)">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="dist">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.MaxDiff(System.Object)">
            <summary>
            Gets the maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ConvertFromInt(System.Int32)">
            <summary>
            Converts an integer to an item of type T.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ConvertToInt(`0)">
            <summary>
            Converts an item of type T to an integer.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ToString(`0)">
            <summary>
            Implements a custom ToString() for items of type T.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.MicrosoftResearch#Infer#Distributions#CanGetLogProb{T}#GetLogProb(`0)">
            <summary>
            Returns the log probability of the value under this distribution.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetTo(`1)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToProduct(`1,`1)">
            <summary>
            Sets the parameters to represent the product of two discrete distributions.
            </summary>
            <param name="a">The first discrete distribution</param>
            <param name="b">The second discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToRatio(`1,`1,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two discrete distributions.
            </summary>
            <param name="numerator">The numerator discrete distribution</param>
            <param name="denominator">The denominator discrete distribution</param>
            <param name="forceProper">Whether to force the returned distribution to be proper</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToPower(`1,System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete distributions.
            </summary>
            <param name="value">The discrete distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToSum(System.Double,`1,System.Double,`1)">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete distributions.
            </summary>
            <param name="value1">The first discrete distribution</param>
            <param name="weight1">The first weight</param>
            <param name="value2">The second discrete distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogAverageOf(`1)">
            <summary>
            The log of the integral of the product of this discrete distribution and that discrete distribution
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogAverageOfPower(`1,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetAverageLog(`1)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ToString(System.String,System.String)">
            <summary>
            Returns a string representation of this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Sample">
            <summary>
            Returns a sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Sample(`0)">
            <summary>
            Returns a sample from the distribution
            </summary>
            <param name="result">Not used</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="obj">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Dimension">
            <summary>
            The dimension of this discrete distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Item(`0)">
            <summary>
            Gets the probability of a given value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Point">
            <summary>
            Point property
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.IsPointMass">
            <summary>
            Returns true if the distribution is a point mass.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.DiscreteChar"/> class with a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Digit">
            <summary>
            Creates a uniform distribution over digits '0'..'9'.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Lower">
            <summary>
            Creates a uniform distribution over lowercase letters 'a'..'z'.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Upper">
            <summary>
            Creates a uniform distribution over uppercase letters 'A'..'Z'.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Letter">
            <summary>
            Creates a uniform distribution over letters in 'a'..'z' and 'A'..'Z'.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.LetterOrDigit">
            <summary>
            Creates a uniform distribution over 'a'..'z', 'A'..'Z' and '0'..'9'.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.WordChar">
            <summary>
            Creates a uniform distribution over word characters ('a'..'z', 'A'..'Z', '0'..'9', '_' and '\'').
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.NonWordChar">
            <summary>
            Creates a uniform distribution over all characters except ('a'..'z', 'A'..'Z', '0'..'9', '_' and '\'').
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Whitespace">
            <summary>
            Creates a uniform distribution over whitespace characters ('\t'..'\r', ' ').
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Any">
            <summary>
            Creates a uniform distribution over all characters.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Uniform"/>.
            </summary>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.InRange(System.Char,System.Char)">
            <summary>
            Creates a uniform distribution over characters in a given range.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRange(`0,`0)"/>.
            </summary>
            <param name="start">The start of the range (inclusive).</param>
            <param name="end">The end of the range (inclusive).</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.InRanges(System.Char[])">
            <summary>
            Creates a distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an array whose length must therefore be even.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(`0[])"/>.
            </summary>
            <param name="startEndPairs">The array of range starts and ends.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.InRanges(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Creates a distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in a sequence whose length must therefore be even.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(System.Collections.Generic.IEnumerable{`0})"/>.
            </summary>
            <param name="startEndPairs">The sequence of range starts and ends.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.OneOf(System.Char[])">
            <summary>
            Creates a distribution which is uniform over the specified set of characters.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformOver(`0[])"/>.
            </summary>
            <param name="chars">The characters.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.OneOf(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Creates a distribution which is uniform over the specified set of characters.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformOver(System.Collections.Generic.IEnumerable{`0})"/>.
            </summary>
            <param name="chars">The characters.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Complement">
            <summary>
            Creates a distribution which is uniform over all characters
            that have zero probability under this distribution
            i.e. that are not 'in' this distribution.
            </summary>
            <remarks>
            This is useful for defining characters that are not in a particular distribution
            e.g. not a letter or not a word character.
            </remarks>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ToString(System.String)">
            <summary>
            Gets a string representing this distribution.
            </summary>
            <param name="format">A format for the underlying probability vector.</param>
            <returns>A string representing this distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ConvertFromInt(System.Int32)">
            <summary>
            Converts an integer to the corresponding character.
            </summary>
            <param name="value">The integer.</param>
            <returns>The character.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ConvertToInt(System.Char)">
            <summary>
            Converts a character to the corresponding integer.
            </summary>
            <param name="value">The character.</param>
            <returns>The integer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ToString(System.Char)">
            <summary>
            Converts a given character to its string representation. Control characters are represented by their codes.
            </summary>
            <param name="ch">The character.</param>
            <returns>The string representing <paramref name="ch"/>.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsDigit">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Digit"/>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsLower">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Lower"/>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsUpper">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Upper"/>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsLetter">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Letter"/>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsLetterOrDigit">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.LetterOrDigit"/>.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteChar.IsWordChar">
            <summary>
            Gets a value indicating whether this distribution equals the distribution created by <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.WordChar"/>.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1">
            <summary>
            A discrete distribution over the values of an enum.
            </summary>
            <typeparam name="TEnum"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor">
            <summary>
            Creates a uniform distribution over the enum values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor(System.Double[])">
            <summary>
            Creates a distribution over the enum values using the specified probs.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.ConvertFromInt(System.Int32)">
            <summary>
            Converts from an integer to an enum value
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.ConvertToInt(`0)">
            <summary>
            Converts the enum value to an integer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4">
            <summary>
            Estimator for a DistributionArray type.
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of DistributionArray element.</typeparam>
            <typeparam name="Sample">Type of a SampleArray element - can be distributions.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Estimator`1">
            <summary>
            Indicates support for retrieving an estimated distribution
            </summary>
            <typeparam name="T">Distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Estimator`1.GetDistribution(`0)">
            <summary>
            Retrieve the estimated distribution
            </summary>
            <param name="result">Where to put the result - ignored if the distribution type is a value type</param>
            <returns>The resulting estimated distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Accumulator`1">
            <summary>
            Indicates support for adding an item to a distribution estimator
            </summary>
            <typeparam name="T">Type of item to add - could be a distribution type or a sample type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Add(`0)">
            <summary>
            Adds an item to the estimator
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length">Length of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.#ctor(`0[])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Add(`3[])">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.SetTo(MicrosoftResearch.Infer.Distributions.ArrayEstimator{`0,`1,`2,`3})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3">
            <summary>
            Estimator for a DistributionArray type where the sample type is a distribution
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of DistributionArray element.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length">Length of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.#ctor(`0[])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Add(`1)">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.SetTo(MicrosoftResearch.Infer.Distributions.ArrayEstimator{`0,`1,`2})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4">
            <summary>
            Estimator for a 2-D DistributionArray type.
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of a DistributionArray element.</typeparam>
            <typeparam name="Sample">Type of a SampleArray element - can be distributions.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length1">Length of first dimension of array</param>
            <param name="length2">Length of second dimension of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.#ctor(`0[0:,0:])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Add(`3[0:,0:])">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.SetTo(MicrosoftResearch.Infer.Distributions.Array2DEstimator{`0,`1,`2,`3})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3">
            <summary>
            Estimator for a 2-D DistributionArray type, where the samples are distributions
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of a DistributionArray element.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length1">Length of first dimension of array</param>
            <param name="length2">Length of second dimension of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.#ctor(`0[0:,0:])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Add(`1)">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.SetTo(MicrosoftResearch.Infer.Distributions.Array2DEstimator{`0,`1,`2})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.AccumulatorList`1">
            <summary>
            Wraps a list of accumulators, adding each sample to all of them.
            </summary>
            <typeparam name="T">The type to accumulate</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Accumulators">
            <summary>
            The list of accumulators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.#ctor(MicrosoftResearch.Infer.Distributions.Accumulator{`0}[])">
            <summary>
            Constructs an accumulator list
            </summary>
            <param name="accumulators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Add(`0)">
            <summary>
            Add an item to all accumulators in the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Clear">
            <summary>
            Clear all accumulators in the list
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1">
            <summary>
            Wraps an accumulator, discarding the first BurnIn samples.
            </summary>
            <typeparam name="T">The type to accumulate</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.BurnIn">
            <summary>
             Burn in
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Thin">
            <summary>
            Thin parameter
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Accumulator">
            <summary>
            Accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.#ctor(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Accumulator{`0})">
            <summary>
            Constructs a burn-in accumulator
            </summary>
            <param name="burnIn"></param>
            <param name="thin"></param>
            <param name="accumulator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Add(`0)">
            <summary>
            Adds a sample to the burn-in accumulator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Clear">
            <summary>
            Clears the burn-in accumulator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator">
            <summary>
            Useful static methods relating to array estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.CreateEstimator``2(``0,System.Boolean)">
            <summary>
            Create an estimator for a given distribution
            </summary>
            <typeparam name="T">Type of distribution</typeparam>
            <typeparam name="TDomain">Type of domain</typeparam>
            <param name="dist">The distribution</param>
            <param name="accumDist">Whether the estimator should accumulate distributions or samples</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.GetEstimatorType(System.Type,System.Boolean)">
            <summary>
            Get the estimator type for a distribution
            </summary>
            <param name="distType">Distribution type</param>
            <param name="accumDist">Accumulate distributions rather than samples</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.FromArray(System.Object,System.Type[],System.Type)">
            <summary>
            Convert an array of element estimators to an estimator over an array variable.
            </summary>
            <param name="arrayOfEstimators">Array of estimators</param>
            <param name="estimatorTypes">Estimator types at each depth</param>
            <param name="distType">Distribution type</param>
            <returns>Estimator over an array variable</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1">
            <summary>
            Static class which implements useful functions on estimator arrays.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[],System.Type[])">
            <summary>
            Creates an estimator over an array domain from an estimator array over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(System.Int32,System.Converter{System.Int32,``1},System.Type[])">
            <summary>
            Creates an estimator over an array domain from an estimator over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="length">The length of the array.</param>
            <param name="init">A function providing the estimator of each array element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[0:,0:],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``1},System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="length1">The first dimension of the array.</param>
            <param name="length2">The second dimension of the array.</param>
            <param name="init">A function providing the estimator of each array element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][0:,0:],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[0:,0:][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Bernoulli">
            <summary>
            Represents a distribution on a binary variable.
            </summary>
            <remarks>
            The most common way to use the distribution is to get and set its ProbTrue property.
            
            The distribution is represented by a single number, the log odds: log p(x=true)/p(x=false).
            If this is 0, then the distribution is uniform.
            If this is infinity, then the distribution is a point mass on x=true.
            If this is -infinity, then the distribution is a point mass on x=false.
            In terms of the log odds, p(x=true) = 1/(1+exp(-logOdds)).
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMean`1">
            <summary>
            Whether the distribution supports setting of its mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMean`1.SetMean(`0)">
            <summary>
            Method to set the mean
            </summary>
            <param name="value">The mean value</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMode`1">
            <summary>
            Whether the distribution supports retrieval of the most probable value
            </summary>
            <typeparam name="ModeType">Type of the most probable value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMode`1.GetMode">
            <summary>
            The most probable value
            </summary>
            <returns>The most probable value</returns>
            <remarks>
            This is not a property because it is not reasonable to expect that distributions
            would generally have their mode as a data member.  Computing the mode could take a long
            time for some distributions.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Bernoulli.LogOdds">
            <summary>
            Log odds parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbTrue">
            <summary>
            Gets the probability of the binary variable being true
            </summary>
            <returns>p(x=true)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbTrue(System.Double)">
            <summary>
            Sets the probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbFalse">
            <summary>
            Gets the probability of the binary variable being false
            </summary>
            <returns>p(x=false)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbFalse(System.Double)">
            <summary>
            Sets the probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbTrue">
            <summary>
            Gets the log probability of the binary variable being true
            </summary>
            <returns>log(p(x=true))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbTrue(System.Double)">
            <summary>
            Sets the log probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbFalse">
            <summary>
            Gets the log probability of the binary variable being false
            </summary>
            <returns>log(p(x=false))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbFalse(System.Double)">
            <summary>
            Sets the log probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToUniform">
            <summary>
            Sets the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProb(System.Boolean)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="x">true or false</param>
            <returns>Log of the probability density for the given event</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns>This equals -log(1-p)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Log of the probability that a draw from this distribution
            is equal to a draw from that distribution.
            </summary>
            <param name="that">That distribution</param>
            <returns>The resulting log probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetAverageLog(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample">
            <summary>
            Samples from a Bernoulli distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample(System.Double)">
            <summary>
            Samples from a Bernoulli distribution with a specified p(true)
            </summary>
            <param name="probTrue">p(true)</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetMode">
            <summary>
            The most probable value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetMean">
            <summary>
            Gets the mean of this Bernoulli distribution
            </summary>
            <returns>The mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetMean(System.Double)">
            <summary>
            Sets the mean of this Bernoulli distribution
            </summary>
            <param name="mean">The mean</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetVariance">
            <summary>
            Gets the variance of this Bernoulli distribution
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(System.Double)">
            <summary>
            Creates a Bernoulli distribution with given probability of being true.
            </summary>
            <param name="probTrue">p(true)</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Uniform">
            <summary>
            Instantiates a uniform Bernoulli distribution
            </summary>
            <returns>A new uniform Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.PointMass(System.Boolean)">
            <summary>
            Instantiates a point-mass Bernoulli distribution
            </summary>
            <param name="value">true of false</param>
            <returns>A new point-mass Bernoulli distribution at the specified value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.FromLogOdds(System.Double)">
            <summary>
            Instantiates a Bernoulli distribution from a log-odds value
            </summary>
            <param name="logOdds">The log-odds</param>
            <returns>A new Bernoulli distribution at the specified log-odds</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToProduct(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to a product of two Bernoulli distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Multiply(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the product of two Bernoulli distribution
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Sets this instance to a ratio of two Bernoulli distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Division(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the ratio of two Bernoulli distribution
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToPower(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Sets this instance to the power of a Bernoulli distributions
            </summary>
            <param name="dist">The distribution to raise to a power</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Raises this distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_LogicalNot(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates the complementary distribution
            </summary>
            <param name="dist">The original distribution</param>
            <returns>The complementary distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is a weighted sum of two Bernoulli distribution
            </summary>
            <param name="weight1">The weight for the first distribution</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The weight for the second distribution</param>
            <param name="dist2">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetTo(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to have the parameters of another instance
            </summary>
            <param name="that">The source Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Clone">
            <summary>
            Clones this Bernoulli. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Bernoulli type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between this instance and that instance.
            This returns the absolute difference between the Log-odds
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>true if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Equality(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Inequality(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of instance - shows distribution type and p(true)</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogitProbEqual(System.Double,System.Double)">
            <summary>
            Computes the logical AreEqual function in the log-odds domain.
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-odds that A == B.</returns>
            <remarks>The logical LogitProbEqual function is defined as p1 EQ p2 = p1*p2 + (1-p1)*(1-p2).
            It is the same as the complement of XOR: !(p1 XOR p2).
            In the log-odds domain, this is:
            LogOdds(Logistic(x) EQ Logistic(y)) = log (1+exp(-x-y))/(exp(-x)+exp(-y)).
            To compute this reliably when x>0 and y>0, factor out min(x,y).
            For other cases, use the identity AE(-x,-y) = AE(x,y) and AE(-x,y) = AE(x,-y) = -AE(x,y).
            Note the result is 0 if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogProbEqual(System.Double,System.Double)">
            <summary>
            Computes the log-probability that A==B where p(A)=Logistic(x), p(B)=Logistic(y).
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-probability that A==B.</returns>
            <remarks>
            The result is Math.Log(0.5) if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Or(System.Double,System.Double)">
            <summary>
            Computes the logical OR function in the log-odds domain.
            </summary>
            <param name="x">Any real number, including infinity.</param>
            <param name="y">Any real number, including infinity.</param>
            <returns>The log odds of (p1 OR p2), where p1 = Logistic(x) and p2 = Logistic(y)</returns>
            <remarks>The logical OR function is defined as p1 OR p2 = 1 - (1-p1)*(1-p2) = p1 + p2 - p1*p2.
            In the log-odds domain, this is:
            LogOdds(Logistic(x) OR Logistic(y)) = log(exp(x) + exp(y) + exp(x+y)).  
            To compute this reliably, factor out max(x,y,x+y).
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Gate(System.Double,System.Double)">
            <summary>
            Computes the Bernoulli gating function in the log-odds domain.
            </summary>
            <param name="x"></param>
            <param name="gate"></param>
            <returns></returns>
            <remarks>
            The Bernoulli gating function is x if gate = -infinity and 0 if gate = infinity.
            It is one of the messages sent by a logical OR factor.
            In the log-odds domain, this is:
            log (1 + exp(-gate))/(1 + exp(-gate-x))
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.IsPointMass">
            <summary>
            Whether the distribution is a point mass (true with probability 1 or false
            with probability 1)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.Point">
            <summary>
            Gets/sets the distribution as a point
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BernoulliEstimator">
            <summary>
            Estimates a Bernoulli distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.NProbTrue">
            <summary>
            Number of samples with value true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">A place to put the resulting distribution. This is ignored because Bernoulli is a struct</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Adds a distribution item to the estimator
            </summary>
            <param name="distribution">A Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(System.Boolean)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="sample">The sample - true or false</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clone">
            <summary>
            Returns a copy of the estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BernoulliEstimator)">
            <summary>
            Sets this estimator's state from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Beta">
            <summary>
            A Beta distribution over the interval [0,1].
            </summary>
            <remarks><para>
            The Beta is often used as a distribution on probability values.
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>
            subject to the constraint 0 &lt;= x &lt;= 1.
            </para><para>
            If trueCount = falseCount = 1, the distribution is uniform.
            If falseCount = infinity, the distribution is redefined to be a point mass on trueCount.
            When trueCount &lt;= 0 or falseCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.TrueCount">
            <summary>
            True count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.FalseCount">
            <summary>
            False count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsProper">
            <summary>
            Whether the distribution is proper or not. It is improper
            when trueCount &lt;= 0 or falseCount &lt;= 0 in which case it
            cannot be normalised
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetProbLessThan(System.Double)">
            <summary>
            Compute the probability that a sample from this distribution is less than x.
            </summary>
            <param name="x">Any real number.</param>
            <returns>The cumulative beta distribution at <paramref name="x"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMode">
            <summary>
            The most probable value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMean">
            <summary>
            The expected value E[p].
            </summary>
            <returns><c>TrueCount/TotalCount</c></returns>
            <remarks>The result must be between 0 and 1.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanSquare">
            <summary>
            The expected square E[p^2].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanCube">
            <summary>
            The expected cube E[p^3].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLog">
            <summary>
            The expected logarithm E[log(p)].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLogs(System.Double@,System.Double@)">
            <summary>
            The expected logarithms E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP"></param>
            <param name="eLogOneMinusP"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetVariance">
            <summary>
            The variance var(p).
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance for this instance
            </summary>
            <param name="mean">Mean value - output</param>
            <param name="variance">Variance - output</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance for this instance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Clone">
            <summary>
            Clones this Beta. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Beta type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between the parameters of this instance and of that instance.
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Equality(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Inequality(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Not Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToUniform">
            <summary>
            Sets this instance to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogProb(System.Double)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="value">Domain value</param>
            <returns>Log of the probability density for the given domain value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.BetaLn(System.Double,System.Double)">
            <summary>
            Computes the log Beta function: <c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c>.
            </summary>
            <param name="trueCount">Any real number.</param>
            <param name="falseCount">Any real number.</param>
            <returns><c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c></returns>
            <remarks>
            If trueCount &lt;= 0 or falseCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetAverageLog(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetTo(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">that instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToProduct(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters to represent the product of two Betas.
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Beta(0.1,0.1) by itself you get Beta(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Multiply(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static product operator. Create a Beta distribution which is the product of
            two Beta distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToRatio(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Betas.
            </summary>
            <param name="numerator">The numerator distribution.  Can be the same object as this.</param>
            <param name="denominator">The denominator distribution.  Can be the same object as this.</param>
            <param name="forceProper">If true, the counts of the result are made >= 1, under the constraint that denominator*result has the same mean as numerator.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Division(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static ratio operator. Create a Beta distribution which is the ratio of 
            two Beta distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToPower(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Sets the parameters to represent the a Beta raised to some power.
            </summary>
            <param name="dist">The distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.AllowImproperSum">
            <summary>
            Property to allow an improper sum
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The log of the integral of the product of this Beta and that Beta
            </summary>
            <param name="that">That beta</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample">
            <summary>
            Sample from this Beta distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample(System.Double,System.Double)">
            <summary>
            Static method to sample from a Beta distribution with the specified true and false counts
            </summary>
            <param name="trueCount">True count</param>
            <param name="falseCount">False count</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Static method to sample from a Beta distribution with the specified mean and variance 
            </summary>
            <param name="mean">The mean of the Beta distribution to sample from</param>
            <param name="variance">The variance of the Beta distribution to sample from</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Beta distribution with the given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <remarks>
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Beta distribution from a specified mean and variance
            </summary>
            <param name="mean">mean</param>
            <param name="variance">variance</param>
            <returns>The new Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanLogs(System.Double,System.Double)">
            <summary>
            Constructs a Beta distribution with the given E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP">Desired expectation E[log(p)].</param>
            <param name="eLogOneMinusP">Desired expectation E[log(1-p)].</param>
            <returns>A new Beta distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Beta distribution
            from data given by sufficient statistics. So we want to maximize
            (a-1)eLogP + (b-1)eLogOneMinusP + Gamma(a+b) - Gamma(a) - Gamma(b)
            with respect to a, b where a=trueCount, b=falseCount.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Uniform">
            <summary>
            Instantiates a uniform Beta distribution
            </summary>
            <returns>A new uniform Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.PointMass(System.Double)">
            <summary>
            Instantiates a point-mass Beta distribution
            </summary>
            <param name="mean">The domain value where the point mass occurs</param>
            <returns>A new point-mass Beta distribution at the specified location</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.ToString">
            <summary>
            Override of the ToString method
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.TotalCount">
            <summary>
            The sum of TrueCount and FalseCount.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.Point">
            <summary>
            Gets/sets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.IsPointMass">
            <summary>
            Whether the instance is a point mass beta distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BetaEstimator">
            <summary>
            Estimates a Beta distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BetaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.#ctor">
            <summary>
            Creates a new Beta estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Adds a Beta item to the estimator
            </summary>
            <param name="distribution">A Beta instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Adds a Beta item to the estimator
            </summary>
            <param name="distribution">A Beta instance</param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BetaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clone">
            <summary>
            Returns a copy of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Dirichlet">
            <summary>
            A Dirichlet distribution on probability vectors.
            </summary>
            <remarks><para>
            The Dirichlet is a distribution on probability vectors.
            The formula for the distribution is p(x) = (Gamma(a)/prod_i Gamma(b_i)) prod_i x_i^{b_i-1}
            subject to the constraints x_i &gt;= 0 and sum_i x_i = 1.
            The parameter a is the "total pseudo-count" and is shorthand for sum_i b_i.
            The vector b contains the pseudo-counts for each case i. The vector b can be sparse
            or dense; in many cases it is useful to give it a <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification of
            <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>.
            </para><para>
            The distribution is represented by the pair (TotalCount, PseudoCount).
            If TotalCount is infinity, the distribution is a point mass.  The Point property gives the mean.
            Otherwise TotalCount is always equal to PseudoCount.Sum().
            If distribution is uniform when all PseudoCounts = 1.
            If any PseudoCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are reference types
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2.GetMeanAndVariance(`0,`1)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.TotalCount">
            <summary>
            Gets the total count. If infinite, the distribution is a point mass.
            Otherwise, this is the sum of pseudo-counts
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.PseudoCount">
            <summary>
            Vector of pseudo-counts
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsProper">
            <summary>
            Whether the the distribution is proprer or not.
            It is proper if all pseudo-counts are > 0.
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMode">
            <summary>
            The most probable vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMode(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            The most probable vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected value E(x). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(x)</param>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog">
            <summary>
            Gets the expected log value E(log(x))
            </summary>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected log value E(log(x)). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(log(x))</param>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLogAt(System.Int32)">
            <summary>
            E[log prob[sample]]
            </summary>
            <param name="sample">a dimension of prob of interest</param>
            <returns>E[log prob[sample]]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanSquare">
            <summary>
            Computes E[p(x)^2] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanCube">
            <summary>
            Computes E[p(x)^3] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetVariance">
            <summary>
            Gets the variance var(p) = m*(1-m)/(1+s)
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean E(p) = m/s and variance var(p) = m*(1-m)/(1+s)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndMeanSquare(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given mean-squares.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="meanSquare">Desired meanSquare in each dimension.  Must be in [0,1].</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the meanSquare, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given variances.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="variance">Desired variance in each dimension.  Must be non-negative.</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the variance, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.FromMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a Dirichlet distribution with the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <returns>A new Dirichlet where GetMeanLog == meanLog</returns>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set the Dirichlet parameters to produce the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other setters since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.EstimateNewton(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Modifies PseudoCount to produce the given expected logarithms.
            </summary>
            <param name="PseudoCount">On input, the initial guess.  On output, the converged solution.</param>
            <param name="meanLog">May be -infinity.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Clone">
            <summary>
            Clones this Dirichlet. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Dirichlet type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Dirichlet
            and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the Dirichlet density function at the given Vector value
            </summary>
            <param name="value">Where to do the evaluation. Must be vector of positive real numbers</param>
            <returns>log(Dir(value;a,b))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.DirichletLn(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Computes the log Dirichlet function: <c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c>
            </summary>
            <param name="pseudoCount">Vector of pseudo-counts.</param>
            <returns><c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c></returns>
            <remarks>
            If any pseudoCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetAverageLog(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetTo(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets this Dirichlet instance to have the parameter values of another Dirichlet instance
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToProduct(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets the parameters to represent the product of two Dirichlets.
            </summary>
            <param name="a">The first Dirichlet.  May refer to <c>this</c>.</param>
            <param name="b">The second Dirichlet.  May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Dirichlet(0.1,0.1) by itself you get Dirichlet(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Multiply(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the product of two Dirichlet distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Dirichlets.
            </summary>
            <param name="numerator">The numerator Dirichlet.  Can be the same object as this.</param>
            <param name="denominator">The denominator Dirichlet.  Can be the same object as this.</param>
            <param name="forceProper">If true, the PseudoCounts of the result are made >= 1, under the constraint that denominator*result has the same mean as numerator.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Division(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the ratio of two Dirichlet distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToPower(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Sets the parameters to represent the raising a Dirichlet to some power.
            </summary>
            <param name="dist">The Dirichlet</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.AllowImproperSum">
            <summary>
            If true, <see cref="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)"/> will use moment matching as described by Minka and Lafferty (2002).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Static weighted sum method for distribution types for which both mean and variance
            can be got/set as Vectors
            </summary>
            <typeparam name="T">The distribution type</typeparam>
            <param name="result">The resulting distribution</param>
            <param name="dimension">The vector dimension</param>
            <param name="weight1">First weight</param>
            <param name="dist1">First distribution instance</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second distribution instance</param>
            <param name="sparsity">Vector sparsity specification</param>
            <returns>Resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToUniform">
            <summary>
            Sets the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsUniform">
            <summary>
            Whether this instance is uniform (i.e. has unit pseudo-counts)
            </summary>
            <returns>true if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The log of the integral of the product of this Dirichlet and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample">
            <summary>
            Samples from this Dirichlet distribution
            </summary>
            <returns>The sample Vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this Dirichlet distribution. Provide a Vector to place the result
            </summary>
            <param name="result">Where to place the resulting sample</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SampleFromPseudoCounts(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Dirichlet with specified pseudo-counts
            </summary>
            <param name="pseudoCount">The pseudo-count vector</param>
            <returns>A new Vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Dirichlet with specified pseudo-counts
            </summary>
            <param name="pseudoCount">The pseudo-count vector</param>
            <param name="result">Where to put the result</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32)">
            <summary>
            Creates a uniform Dirichlet distribution with unit pseudo-counts.
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Dirichlet distribution with unit pseudo-counts and a given dimension
            and <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/>.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification. A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,System.Double)">
            <summary>
            Creates a uniform Dirichlet distribution with the specified initial pseudo-count for each index.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="initialCount">Initial value for each pseudocount</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Dirichlet distribution with the specified dimension, initial pseudo-count
            and <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/>.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="initialCount">Initial value for each pseudocount</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification. A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Dirichlet distribution with the specified pseudo-counts.
            The pseudo-count vector can have any <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification.
            A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems, and the message functions used
            in inference will maintain that sparsity specification.
            </summary>
            <param name="pseudoCount">The vector of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Double[])">
            <summary>
            Creates a Dirichlet distribution with the psecified pseudo-counts
            </summary>
            <param name="pseudoCount">An array of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the Vector must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32)">
            <summary>
            Instantiates a uniform Dirichlet distribution
            </summary>
            <param name="dimension">Dimension</param>
            <returns>A new uniform Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Instantiates a uniform Dirichlet distribution of a given sparsity
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">Sparsity</param>
            <returns>A new uniform Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Symmetric(System.Int32,System.Double)">
            <summary>
            Creates a Dirichlet distribution with all pseudo-counts equal to initialCount.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="pseudoCount">The value for each pseudo-count</param>
            <returns>A new Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Symmetric(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a Dirichlet distribution of a given sparsity with all pseudo-counts equal to initialCount.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="pseudoCount">The value for each pseudo-count</param>
            <param name="sparsity">Sparsity specification</param>
            <returns>A new Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(System.Double[])">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the array must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Dimension">
            <summary>
            Gets the dimension of this Dirichlet
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity">
            <summary>
            Gets the <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification of this Distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Point">
            <summary>
            Sets/gets this distribution as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.IsPointMass">
            <summary>
            Whether this Dirichlet is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DirichletEstimator">
            <summary>
            Estimates a Dirichlet distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum">
            <summary>
            Sum
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum2">
            <summary>
            Sum of squares
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Dirichlet estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Adds a Dirichlet item to the estimator
            </summary>
            <param name="item">A Dirichlet instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a Vector sample to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DirichletEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Dimension">
            <summary>
            Dimension of the Dirichlet
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Discrete">
            <summary>
            An arbitrary distribution over integers [0,D-1].
            </summary>
            <remarks>
            The distribution is represented by a normalized Vector of length D.
            In the case of a point mass, the first element is infinity and the second element holds the point location.
            The probability of value x is available as this[x] or GetLogProb(x).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Discrete.prob">
            <summary>
            Probability of each value (when not a point mass).
            </summary>
            <remarks>
            prob.Length == D.
            prob[i] >= 0.  sum_i prob[i] = 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Clone">
            <summary>
            Clones this discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Discrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.MaxDiff(System.Object)">
            <summary>
            Gets the maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToUniform">
            <summary>
            Sets this instance to a uniform discrete (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.IsUniform">
            <summary>
            Returns whether the discrete distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPartialUniform">
            <summary>
            Sets the distribution to be uniform over its support.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPartialUniformOf(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the distribution to be uniform over the support of a given distribution.
            </summary>
            <param name="dist">The distribution which support will be used to setup the current distribution.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.IsPartialUniform">
            <summary>
            Checks whether the distribution is uniform over its support.
            </summary>
            <returns>True if the distribution is uniform over its support, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetAverageLog(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The log of the integral of the product of this discrete and that discrete
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ProbEqual(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The integral of the product between this discrete and that discrete. This
            is the probability that samples from this instance and that instance are equal
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs">
            <summary>
            Gets the probability at each index.
            </summary>
            <returns>The vector of probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the probability at each index.
            </summary>
            <param name="result">When used internally, can be the same object as prob.</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProbs">
            <summary>
            Gets the vector of log probabilities for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal probs Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the probability of each index.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetTo(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPadded(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Set this distribution to match the given distribution, but possibly over a larger domain
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToProduct(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the product of two discrete distributions.
            </summary>
            <param name="a">The first discrete distribution</param>
            <param name="b">The second discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Multiply(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the product of two Discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Division(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the ratio of two Discrete distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPower(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete distributions.
            </summary>
            <param name="dist">The discrete distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Discrete,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete distributions.
            </summary>
            <param name="dist1">The first discrete distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second discrete distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Normalize">
            <summary>
            Normalizes this distribution - i.e. sets the probabilities to sum to 1.
            This is called internally after product operations, sum operations etc.
            </summary>
            <returns>The normalizing factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(System.Int32)">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <param name="result">This parameter is ignored and is only present to support the Sampleable interface</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a sample from a discrete distribution with the specified probabilities
            </summary>
            <param name="probs">The parameters of the discrete distribution</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution, from 0 to dimension-1.
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Discrete distribution with a specified sparsity, from 0 to dimension-1.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">Sparsity</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Copy constructor
            </summary>
            <param name="that">The discrete instance to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Double[])">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.PointMass(System.Int32,System.Int32)">
            <summary>
            Creates a Discrete distribution which allows only one value.
            </summary>
            <param name="value">The allowed value.</param>
            <param name="numValues">The number of values in the domain.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Uniform(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Discrete distribution with a specified sparsity over the values from 0 to numValues-1
            </summary>
            <param name="numValues">Number of values</param>
            <param name="sparsity">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Discrete distribution which is uniform over values from
            start to end inclusive.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="start">The first value included in the distribution</param>
            <param name="end">The last value included in the distribution</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRanges(System.Int32,System.Int32[])">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an array whose length must therefore be
            even.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified ranges (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRanges(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an enumerable whose length must therefore be
            even.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified ranges (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMean">
            <summary>
            Gets the mean of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMedian">
            <summary>
            Gets the median of the distribution
            </summary>
            <returns>The median</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMode">
            <summary>
            Gets the mode of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Dimension">
            <summary>
            Gets the dimension of this discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Sparsity">
            <summary>
            Gets the <see cref="P:MicrosoftResearch.Infer.Distributions.Discrete.Sparsity"/> specification of this Distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.IsPointMass">
            <summary>
            Indicates whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Item(System.Int32)">
            <summary>
            Gets or sets the probability at the given index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEstimator">
            <summary>
            Estimates a discrete distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.NProb">
            <summary>
            Vector of counts for each domain value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Adds a discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Adds a weighted discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
            <param name="weight">Weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(System.Int32)">
            <summary>
            Adds an discrete sample to the estimator
            </summary>
            <param name="sample">The sample value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new discrete distribution estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DiscreteEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Dimension">
            <summary>
            Dimension of the discrete distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Evaluator`2">
            <summary>
            Delegate type for evaluating log densities. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2"/>, then it can return a delegate of this type
            to do evaluations without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="dist">The distribution instance</param>
            <param name="value">The value at which to evaluate the log density</param>
            <returns>The delegate returns a double</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for density evaluation
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2.GetLogProbPrep">
            <summary>
            Return an evaluator delegate which owns an evaluation workspace
            </summary>
            <returns>An evaluator delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`1">
            <summary>
            Delegate type for sampling
            </summary>
            <typeparam name="T">Domain type</typeparam>
            <param name="result">Where to put the result</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`2">
            <summary>
            Delegate type for sampling a distribution. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2"/>, then it can return a delegate of this type
            to do successive sampling without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="distribution">The distribution instance</param>
            <param name="result">The value at which to evaluate the log density</param>
            <returns>The delegate's return type is the domain type</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for sampling
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2.SamplePrep">
            <summary>
            Return an sampler delegate which owns an sampling workspace
            </summary>
            <returns>An sampler delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ImproperDistributionException">
            <summary>
            Exception thrown when a distribution is improper and its expectations need to be computed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ImproperDistributionException.#ctor(System.Object)">
            <summary>
            Create a new Improper Distribution exception
            </summary>
            <param name="distribution"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.IsDistributionType(System.Type)">
            <summary>
            Determinines if this type is a distribution type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.HasDistributionType(System.Type)">
            <summary>
            Determines whether the type, or any element, or any generic type parameter specification, etc
            is a distribution type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetQualityBand(System.Type)">
            <summary>
            Returns the quality band for the distribution type
            </summary>
            <param name="type">The distribution type</param>
            <returns></returns>
            <remarks>This will throw an exception if there is no distribution associated with this type. Call
            <see cref="M:MicrosoftResearch.Infer.Distributions.Distribution.HasDistributionType(System.Type)"/> to check.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetDomainType(System.Type)">
            <summary>
            Gets the domain type of a distribution type, e.g. the domain type of 'Gaussian' is 'double'.
            </summary>
            <param name="distributionType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ChangeType``1(System.Object)">
            <summary>
            Convert a distribution from one type to another
            </summary>
            <typeparam name="TReturn">The desired distribution type</typeparam>
            <param name="distribution">The object to convert</param>
            <returns>The converted distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MakeDistributionArrayType(System.Type,System.Int32)">
            <summary>
            Makes a distribution array of a specified type and size
            </summary>
            <param name="elementType">Distribution type</param>
            <param name="rank">Number of dimensions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ToArray``1(System.Object)">
            <summary>
            Convert a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="ArrayType">A .NET array type, such as <c>Bernoulli[]</c> or <c>Gaussian[,][]</c>.  The array structure should match the domain of the distribution.</typeparam>
            <param name="distributionArray">A distribution over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c> or <c>IDistribution&lt;double[,][]&gt;</c>.</param>
            <returns>An array of element distributions.</returns>
            <remarks>
            <typeparamref name="ArrayType"/> should match the array structure of the domain.  For example, if the input
            is <c>IDistribution&lt;bool[,]&gt;</c> then <typeparamref name="ArrayType"/> should be
            <c>Bernoulli[,]</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ToArray``2(``0)">
            <summary>
            Convert a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="DistributionType">The concrete type of distributionArray</typeparam>
            <typeparam name="ArrayType">A .NET array type, such as <c>Bernoulli[]</c> or <c>Gaussian[,][]</c>.  The array structure should match the domain of the distribution.</typeparam>
            <param name="distributionArray">A distribution over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c> or <c>IDistribution&lt;double[,][]&gt;</c>.</param>
            <returns>An array of element distributions.</returns>
            <remarks>
            <typeparamref name="ArrayType"/> should match the array structure of the domain.  For example, if the input
            is <c>IDistribution&lt;bool[,]&gt;</c> then <typeparamref name="ArrayType"/> should be
            <c>Bernoulli[,]</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetArrayConverter``2">
            <summary>
            Get a converter from a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="TInput">A distribution type over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c></typeparam>
            <typeparam name="TOutput">An array type such as <c>Bernoulli[]</c></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.FromArray(System.Object)">
            <summary>
            Convert an array of element distributions to a distribution over an array variable.
            </summary>
            <param name="arrayOfDistributions">Array of distributions</param>
            <returns>Distribution over an array variable</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.CreateUniform``1">
            <summary>
            Creates a uniform distribution of a specified type.
            </summary>
            <typeparam name="TDistribution">The distribution type.</typeparam>
            <returns>The created uniform distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.CreatePartialUniform``1(``0)">
            <summary>
            Creates a distribution which is uniform over the support of a specified distribution.
            </summary>
            <typeparam name="TDistribution">The distribution type.</typeparam>
            <param name="distribution">The distribution, which support will be used to create the result distribution.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``2(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``3(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <typeparam name="TDomain">Domain</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Product of all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,``1[])">
            <summary>
            Sets a distribution to the product of an array of ditributions
            </summary>
            <typeparam name="T">Domain type of the result distribution</typeparam>
            <typeparam name="U">Domain type of the array of distributions</typeparam>
            <param name="result">The result distribution</param>
            <param name="dists">The array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,``1[],System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,``1[])">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``3(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``3(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32,System.Int32)">
            <summary>
            Product of distributions in an array.
            </summary>
            <param name="result">A reference in which to place the results.</param>
            <param name="dists">An array of distributions.</param>
            <param name="count">The number of distributions in the array to multiply (starting from index 0).</param>
            <param name="index">An array index to omit in the multiplication.  If index == count, no index is omitted and all distributions are multiplied.</param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.LogInnerProduct``1(System.Collections.Generic.IList{``0})">
            <summary>
            Log-probability that all distributions in the list would produce the same value.
            </summary>
            <param name="dists"></param>
            <returns><c>sum_x prod_i dists[i](x)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MaxDiff``2(``0[],``1[])">
            <summary>
            Max difference between two arrays of distributions
            </summary>
            <typeparam name="T">Domain type for fisrt array of distributions</typeparam>
            <typeparam name="U">Domain type for second array of distributions</typeparam>
            <param name="a">First array of distributions</param>
            <param name="b">Second array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``2(``0[],``1[],``1[])">
            <summary>
            Sets each element of result to the product of the corresponding distributions in two given
            arrays
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two distribution arrays</typeparam>
            <param name="result">Result</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the product of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``2(``0[],``1[],``1[],System.Boolean)">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator and denominator distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T1.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPower``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPowerLazy``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSum``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSumLazy``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOf``2(``1,``1,``1@)">
            <summary>
            Computes the log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T">The distribution domain.</typeparam>
            <typeparam name="TDistribution">The type of a distribution.</typeparam>
            <param name="distribution1">The first distribution.</param>
            <param name="distribution2">The second distribution.</param>
            <param name="product">The product of the distributions will be returned in this argument. If the product is zero, the value is undefined.</param>
            <returns>
            The log-probability that two distributions would draw the same sample.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOf``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOfLazy``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLog``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T">Type of this distribution</typeparam>
            <typeparam name="TValue">Type of the distribution to take the logarithm of</typeparam>
            <param name="thisDist">This distribution</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLogLazy``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of thatd istribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.PointMass``1(``0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The point at which to place the point mass</param>
            <returns>The PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetPoint``2(``0,``1)">
            <summary>
            Set a distribution to a point mass
            </summary>
            <typeparam name="TDist">The distribution type</typeparam>
            <typeparam name="T">The domain type</typeparam>
            <param name="result">Where to put the result (for reference types)</param>
            <param name="point">The location of the point mass</param>
            <returns>A point mass distribution of the specified type and location</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution`1">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.GetLogAverageOf``1(``0,``0,``0@)">
            <summary>
            Computes the log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="TDistribution">The type of a distribution.</typeparam>
            <param name="distribution1">The first distribution.</param>
            <param name="distribution2">The second distribution.</param>
            <param name="product">The product of the distributions will be returned in this argument. If the product is zero, the value is undefined.</param>
            <returns>
            The log-probability that two distributions would draw the same sample.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length">The length of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length1">The first dimension of the array.</param>
            <param name="length2">The second dimension of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`1">
            <summary>
            A distribution over an array, where each element is independent and has distribution type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The distribution type of an element</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.SetToUniform">
            <summary>
            Set the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns>True if uniform, otherwise false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameter values between this distribution and that distribution
            </summary>
            <param name="that">That distribution</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that implements IDistribution and Sampleable.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.GetLogProb(`1[])">
            <summary>
            Logarithm of the probability density function
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample">
            <summary>
            Get a sample from the distribution array
            </summary>
            <returns>An array of samples</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution array
            </summary>
            <param name="result">Where to put the results</param>
            <returns>An array of samples</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.IsPointMass">
            <summary>
            True if the distribution is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32)">
            <summary>
            Create a new distribution struct array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a new distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0,System.Int32)">
            <summary>
            Create a new distribution struct array of a specified value and length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0[])">
            <summary>
            Create a new distribution struct array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameters between
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array given a length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0,System.Int32)">
            <summary>
            Creates a new distribution array given a value and a length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0[])">
            <summary>
            Creates a new distribution array given an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0[])">
            <summary>
            Initialise the elements of this distribution array to clones of the given distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(`0[])">
            <summary>
            Set the parameters of this distribution so that the marginals match the given distributions (by value)
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0)">
            <summary>
            Initialise all the values in this array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetAllElementsTo(`0)">
            <summary>
            Set the parameters of this distribution so that all marginals equal the given distribution (by value)
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[])">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null
            </summary>
            <param name="array">Array to write into</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[])">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the results</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1">
            <summary>
            A distribution over a 2D array, where each element is independent and has distribution type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The distribution type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.SetToUniform">
            <summary>
            Set the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns>True if all uniform, otherwise false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference the parameters of this distribution and that distribution
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that implements IDistribution and Sampleable.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.GetLogProb(`1[0:,0:])">
            <summary>
            Gets the log probability density at a point
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Where to put the results</param>
            <returns>A sample</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Point">
            <summary>
            Sets/gets the 2-D distribution array as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.IsPointMass">
            <summary>
            True if the distribution is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2">
            <summary>
            A distribution over a 2D array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameters between
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Sample from the distribution 
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2">
            <summary>
            A distribution over a 2D array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0[0:,0:])">
            <summary>
            Initialise the values in this 2-D distribution array to clones of the values in a given 2-D array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(`0[0:,0:])">
            <summary>
            Set the parameters of this distribution so that the marginals match the given distributions (by value)
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0)">
            <summary>
            Initialises all the values in this 2-D distribution array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetAllElementsTo(`0)">
            <summary>
            Set the parameters of this distribution so that all marginals equal the given distribution (by value)
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[0:,0:])">
            <summary>
            Set the parameters of array[i,j] to match the marginal distribution of element (i,j), creating a new distribution if array[i,j] was null
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[0:,0:])">
            <summary>
            Set the parameters of array[i,j] to match the marginal distribution of element (i,j)
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ReducibleTo`1.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Remove dimensions via multiplication.
            </summary>
            <param name="keep">The dimensions to keep.</param>
            <param name="result">A distribution or distribution array.</param>
            <returns>An action which will perform the reduction.</returns>
            <remarks>Each element of result will be a product over the dimensions not kept.
            Result must already be the correct size.
            If keep is empty, no dimensions are kept so the result is a single distribution.
            Otherwise, result is a distribution array whose dimensions are the kept dimensions.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2">
            <summary>
            The distribution of an array of independent variables, or equivalently
            an array of distributions.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            This class supports all of the IDistribution methods, as well as 
            being a CursorArray<typeparamref name="DistributionType"/>.
            To support plates, it implements a ReduceTo method which removes 
            dimensions via multiplication.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Apply a reduction action to produce a smaller array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(`0)">
            <summary>
            Apply a reduction action to produce a single element distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Replicate(System.Int32[],System.Int32[])">
            <summary>
            Add dimensions to an array by replication.
            </summary>
            <param name="lengths">The result array dimensions.</param>
            <param name="newPosition">For each original dimension d, newPosition[d] is its index in the 
            result dimensions.  Length == this.Rank.</param>
            <returns>A new array which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Split(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Make a jagged array from a multidimensional array.
            </summary>
            <param name="isOuterDimension">For each original dimension d, 
            indicates whether it will be in the outer array. Length == this.Rank.</param>
            <returns>A jagged array [outer][inner] which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ToString">
            <summary>
            Overrides ToString method
            </summary>
            <returns>String representation of instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.IsPointMass">
            <summary>
            True if all elements are constant.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionFileArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>, all stored in a file.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="DomainType"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.EstimatorFactory">
            <summary>
            Estimator factor. Given a distribution instance, create a compatible estimator instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.RegisterEstimator(System.Type,System.Type,MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod)">
            <summary>
            Registers an estimator. The factory is primed with stock
            stock estimators. This function allows clients to add in custom
            estimators
            </summary>
            <param name="distType">Distribution type</param>
            <param name="estType">Estimator type</param>
            <param name="c">Method for creating the estimator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.CreateEstimator``2(``0)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TDomain"></typeparam>
            <param name="distProto">Distribution prototype</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.EstimatorType(System.Type)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <param name="distType">Distribution type</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.EstimatorFactory.Instance">
            <summary>
            Estimator factory singleton instance
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gamma">
            <summary>
            A Gamma distribution on positive reals.
            </summary>
            <remarks><para>
            The distribution is 
            <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>b</c> parameter
            is called the "Rate".  The distribution is sometimes also parameterized by (shape,scale)
            where scale = 1/rate.
            The mean of the distribution is <c>shape/rate</c> and the variance is 
            <c>shape/rate^2</c>.
            </para><para>
            Special cases:
            When the shape is 1 and rate is 0, the distribution is uniform.
            When the shape is infinity, the distribution is a point mass and the density is delta(x-Point)
            where the Point property gives the mean.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMode">
            <summary>
            The most probable value
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMean">
            <summary>
            Gets the expected value E(x) - calculated as shape/rate
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetVariance">
            <summary>
            Gets the variance - calculated as shape/rate^2
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean (shape/rate) and variance (shape/rate^2)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndRate(System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndRate(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetScale">
            <summary>
            Gets the scale (1/rate)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetShapeAndScale(System.Double@,System.Double@)">
            <summary>
            Gets the shape and scale (1/rate)
            </summary>
            <param name="shape">Where to put the shape</param>
            <param name="scale">Where to put the scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndScale(System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndScale(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given mean and mean logarithm.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Gamma distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromLogMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given log mean and mean logarithm.
            </summary>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromDerivatives(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Construct a Gamma distribution whose pdf has the given derivatives at a point.
            </summary>
            <param name="x">Must be positive</param>
            <param name="dlogp"></param>
            <param name="ddlogp"></param>
            <param name="forceProper">If true and both derivatives cannot be matched, match only the first.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution.
            </summary>
            <param name="shapeMinus1">The shape parameter - 1.</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanLog">
            <summary>
            Computes E[log(x)]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanInverse">
            <summary>
            Computes E[1/x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetProbLessThan(System.Double)">
            <summary>
            Compute the probability that a sample from this distribution is less than x.
            </summary>
            <param name="x">Any real number.</param>
            <returns>The cumulative gamma distribution at <paramref name="x"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToUniform">
            <summary>
            Sets this Gamma instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <returns>log(Gamma(x;shape,rate))</returns>
            <remarks>
            The distribution is <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            Thus if shape = 1 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double)">
            <summary>
            Logarithm of this Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Gamma(x;shape,rate))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper">
            <summary>
            Asks whether this Gamma instance is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Gamma distribution is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Gamma</param>
            <param name="rate">rate parameter for the Gamma</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The log of the integral of the product of this Gamma and that Gamma
            </summary>
            <param name="that">That Gamma</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double)">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetTo(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets this Gamma instance to have the parameter values of that Gamma instance
            </summary>
            <param name="that">That Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToProduct(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the parameters to represent the product of two Gammas.
            </summary>
            <param name="a">The first Gamma</param>
            <param name="b">The second Gamma</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Multiply(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the product of two other Gammas
            </summary>
            <param name="a">First Gamma</param>
            <param name="b">Second Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Gammas
            </summary>
            <param name="numerator">The numerator Gamma.  Can be the same object as this.</param>
            <param name="denominator">The denominator Gamma.  Can be the same object as this.</param>
            <param name="forceProper">If true, the result has shape >= 1 and rate >= 0, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Division(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the ratio of two other Gammas
            </summary>
            <param name="numerator">numerator Gamma</param>
            <param name="denominator">denominator Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPower(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gamma to some exponent.
            </summary>
            <param name="dist">The source Gamma</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Set the mean and variance to match the moments of a mixture of two Gammas.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first Gamma</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gamma
            and that Gamma
            </summary>
            <param name="thatd">That Gamma</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Equality(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Inequality(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gamma distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <remarks>
            The distribution is <c>p(x) = x^(shape-1)*exp(-x/scale)/(scale^shape * Gamma(shape))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromNatural(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution from its natural parameters.
            </summary>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Clone">
            <summary>
            Clones this Gamma. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gamma type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Uniform">
            <summary>
            Create a uniform Gamma distribution.
            </summary>
            <returns>A new uniform Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.PointMass(System.Double)">
            <summary>
            Creates a point mass Gamma distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GammaEstimator">
            <summary>
            Estimates a Gamma distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            In the one-dimensional case,
            E[x] = (a+1)/b
            var(x) = (a+1)/b^2
            b = E[x]/var(x)
            a = E[x]^2/var(x) - 1
            </code></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.#ctor">
            <summary>
            Creates a new Gamma estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Retrieves the Gamma estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Adds a Gamma distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample with a given weight to the estimator
            </summary>
            <param name="value">The sample to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GammaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clone">
            <summary>
            Returns a clone of this Gamma estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GammaPower">
            <summary>
            The distribution of a Gamma variable raised to a power.  The Weibull distribution is a special case.
            </summary>
            <remarks><para>
            The Gamma-power distribution is defined as the distribution of a Gamma(a,b) variable raised to the power c.  
            Thus it has three parameters (a,b,c) and probability density function
            <c>p(x) = x^(a/c-1)*exp(-b*x^(1/c))*b^a/Gamma(a)/abs(c)</c>.
            In this implementation, the <c>a</c> parameter is called the "Shape", the <c>b</c> parameter
            is called the "Rate", and the <c>c</c> parameter is called the "Power".  
            The power can be any real number, positive or negative.
            The distribution is sometimes also parameterized by (shape,scale,power) where scale = 1/rate.
            </para><para>
            Special cases:
            When the power is 1 it reduces to a Gamma distribution.
            When the shape is 1 it reduces to a Weibull distribution.
            When the shape equals the power and rate is 0, the distribution is uniform.
            When the shape is infinity, the distribution is a point mass and the density is delta(x-Point)
            where the Point property gives the mean.
            When the power is zero, the distribution is a point mass at one.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)/abs(c)</c> term is dropped.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Power">
            <summary>
            Power parameter for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMean">
            <summary>
            Get the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetVariance">
            <summary>
            Get the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Set the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromMeanAndVariance(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <param name="power"></param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetShapeAndRate(System.Double,System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
            <param name="power"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromShapeAndRate(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <param name="power"></param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetShapeAndScale(System.Double,System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
            <param name="power"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromShapeAndScale(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <param name="power"></param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanLog">
            <summary>
            Computes E[log(x)]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToUniform">
            <summary>
            Set shape and rate to be a uniform distribution, without changing the power.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogProb(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <param name="power">Power parameter</param>
            <returns>log(GammaPower(x;shape,rate,power))</returns>
            <remarks>
            The distribution is <c>p(x) = x^(a/c-1)*exp(-b*x^(1/c))*b^a/Gamma(a)/abs(c)</c>.
            When a &lt;= 0 or b &lt;= 0 or c = 0 the <c>b^a/Gamma(a)/abs(c)</c> term is dropped.
            Thus if shape = 1 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogProb(System.Double)">
            <summary>
            Logarithm of the density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Gamma(x;shape,rate,power))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetAverageLog(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsProper">
            <summary>
            Asks whether this Gamma instance is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Gamma distribution is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Gamma</param>
            <param name="rate">rate parameter for the Gamma</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            The log of the integral of the product of this Gamma and that Gamma
            </summary>
            <param name="that">That Gamma</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample">
            <summary>
            Draw a sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample(System.Double)">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample(System.Double,System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <param name="power"></param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SampleFromMeanAndVariance(System.Double,System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <param name="power"></param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetTo(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Set this distribution to have the same parameter values as that
            </summary>
            <param name="that">the source parameters</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToProduct(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Set the parameters so that the density function equals the product of two given GammaPower density functions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution.  Must have the same power parameter as <paramref name="a"/></param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Multiply(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Creates a new GammaPower distribution whose density function equals the product of two other GammaPower density functions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution.  Must have the same power parameter as <paramref name="a"/></param>
            <returns>Result.  May not be proper.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToRatio(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower,System.Boolean)">
            <summary>
            Sets the parameters so that the density function equals the ratio of two given GammaPower density functions
            </summary>
            <param name="numerator">The numerator distribution. Can be the same object as this.</param>
            <param name="denominator">The denominator distribution.  Must have the same power parameter as <paramref name="numerator"/></param>
            <param name="forceProper">If true, the result has shape >= power and rate >= 0</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Division(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Creates a new GammaPower distribution whose density function equals the ratio of two other GammaPower density functions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution.  Must have the same power parameter as <paramref name="numerator"/></param>
            <returns>Result. May not be proper.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToPower(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source distribution to some exponent.
            </summary>
            <param name="dist">The source distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.GammaPower,System.Double,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Sets the mean and variance to match a mixture of two GammaPower distributions.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that distribution
            </summary>
            <param name="thatd">distribution to compare to</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Equality(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Inequality(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a GammaPower distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <param name="power"></param>
            <remarks>
            The distribution is <c>p(x) = x^(shape-1)*exp(-x/scale)/(scale^shape * Gamma(shape))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.#ctor(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Clone">
            <summary>
            Clones this object. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a GammaPower type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Uniform(System.Double)">
            <summary>
            Create a uniform GammaPower distribution.
            </summary>
            <returns>A new uniform GammaPower distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.PointMass(System.Double,System.Double)">
            <summary>
            Creates a point mass Gamma distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <param name="power"></param>
            <returns>A new point mass Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GammaPower.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GammaPower.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gaussian">
            <summary>
            Represents a one-dimensional Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is represented by two parameters: MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = 1/v, MeanTimesPrecision = m/v.
            </para><para>
            Some special cases:
            If the Precision is zero, then the distribution is uniform.
            If the Precision is infinite, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.MeanTimesPrecision">
            <summary>
            Mean times precision
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVarianceImproper(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance, even if the distribution is improper
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndPrecision(System.Double@,System.Double@)">
            <summary>
            Gets the mean and precision
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Sets the mean and precision
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetNatural(System.Double@,System.Double@)">
            <summary>
            Gets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Where to put the mean times precision</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMode">
            <summary>
            The most probable value
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToUniform">
            <summary>
            Sets this Gaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsProper">
            <summary>
            Asks whether this Gaussian instance is proper or not. A Gaussian distribution
            is proper only if Precision > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the log of one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <param name="mean">Must be finite.</param>
            <param name="variance">Any real number.  May be zero or negative.</param>
            <remarks>
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double)">
            <summary>
            Evaluates the log of this one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogNormalizer">
            <summary>
            Gets the log of the normalizer for the Gaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample">
            <summary>
            Samples from this Gaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double)">
            <summary>
            Samples from this Gaussian distribution. This override is only
            present to support the Sampleable interface
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetTo(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets this Gaussian instance to have the parameter values of that Gaussian instance
            </summary>
            <param name="that">That Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the parameters to represent the product of two Gaussians.
            </summary>
            <param name="a">The first Gaussian</param>
            <param name="b">The second Gaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the product of two other Gaussians
            </summary>
            <param name="a">First Gaussian</param>
            <param name="b">Second Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Gaussians, optionally forcing the precision to be non-negative.
            </summary>
            <param name="numerator">The numerator Gaussian</param>
            <param name="denominator">The denominator Gaussian</param>
            <param name="forceProper">If true, the result will have non-negative precision, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Division(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the ratio of two other Gaussians
            </summary>
            <param name="numerator">numerator Gaussian</param>
            <param name="denominator">denominator Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPower(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gaussian to some exponent.
            </summary>
            <param name="dist">The source Gaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the mean and variance to match a Gaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="g1">First Gaussian</param>
            <param name="weight2">Second weight</param>
            <param name="g2">Second Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.WeightedSum``1(``0,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matches the mean and variance
            of a Gaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2"/>,
            </summary>
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>, and <see cref="T:MicrosoftResearch.Infer.Distributions.SettableToUniform"/>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the integral of the product of two Gaussians.
            </summary>
            <param name="that"></param>
            <remarks>
            <c>this = N(x;m1,v1)</c>.
            <c>that = N(x;m2,v2)</c>.
            <c>int_(-infinity)^(infinity) N(x;m1,v1) N(x;m2,v2) dx = N(m1; m2, v1+v2)</c>.
            When improper, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns>log(N(m1;m2,v1+v2)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gaussian
            and that Gaussian
            </summary>
            <param name="thatd">That Gaussian</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Equality(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Clone">
            <summary>
            Clones this Gaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and variance.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and precision.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">precision = 1/variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromNatural(System.Double,System.Double)">
            <summary>
            Creates a new Gaussian distribution from its natural parameters
            (Mean times precision, and Precision)
            </summary>
            <param name="meanTimesPrecision">Mean time precision</param>
            <param name="precision">Precision</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromDerivatives(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Construct a Gaussian distribution whose pdf has the given derivatives at a point.
            </summary>
            <param name="x"></param>
            <param name="dlogp"></param>
            <param name="ddlogp"></param>
            <param name="forceProper">If true and both derivatives cannot be matched, match only the first.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Uniform">
            <summary>
            Creates a new uniform Gaussian distribution
            </summary>
            <returns>A new uniform Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.PointMass(System.Double)">
            <summary>
            Create a new point mass Gaussian distribution at a specified location
            </summary>
            <param name="mean">The location for the point mass</param>
            <returns>A new point mass Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.ToString(System.String)">
            <summary>
            Get a string representation of the distribution with a given number format
            </summary>
            <param name="format">Format string to use for each number</param>
            <returns>A string</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.#ctor">
            <summary>
            Creates a new Gaussian estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Adds a Gaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Adds a Gaussian distribution with given weight to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
            <param name="weight">The weight of the distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double)">
            <summary>
            Adds an sample to the estimator
            </summary>
            <param name="sample">The sample add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample with a given weight to the estimator
            </summary>
            <param name="sample">The sample to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result"></param>
            <returns>Returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IFunction">
            <summary>
            Function interface - used for distributions over a function domain
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate a function
            </summary>
            <param name="X">Input</param>
            <returns>Output</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConstantFunction">
            <summary>
            Class implementing the constant function. Used as a domain prototype
            for distributions over functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the function
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor">
            <summary>
            Constructor for constant function - default value is 0.0
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor(System.Double)">
            <summary>
            Constructor for constant function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConstantFunction.ConstantValue">
            <summary>
            The constant value of the function
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IGaussianProcess">
            <summary>
            Basic GP interface
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>E[f(x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>E[f(x_i)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Variance of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>var(f(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Covariance of f at two points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>cov(f(x),f(y))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Covariance matrix of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>cov(f(x_1),f(x_2),...)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Marginal distribution of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>p(f(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Joint distribution of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>p(f(x_1),f(x_2),...)</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Rank1Pot">
            <summary>
            Rank 1 potential for a sparse GP. This low rank parameterisation
            is used for messages flowing from a SparseGP evaluation factor to
            a function variable.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Xi">
            <summary>
            Xi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Yi">
            <summary>
            Yi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.LambdaInv">
            <summary>
            Lambda inverse
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kBx">
            <summary>
            Field for K_B_x property
            </summary>
            
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_B_x(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.pvec">
            <summary>
            Field for P property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.P(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            p = Inv(K(B,B)) * K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kxx">
            <summary>
            Field for K_x_x property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_x_x(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            k(x)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.ClearCachedValues">
            <summary>
            Flag recalculation of the calculated properties
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGP">
            <summary>
            A Gaussian Process distribution over functions, represented by a GP prior times a set of regression likelihoods on basis points.
            </summary>
            <remarks>
            <para>
            This distribution family comes from the paper "Sparse-posterior Gaussian Processes for general likelihoods"
            by Qi et al (2010), http://event.cwi.nl/uai2010/papers/UAI2010_0283.pdf
            </para><para>
            The state of the distribution is represented by (FixedParameters, IncludePrior, InducingDist, pointFunc).
            The GP prior and basis point locations are stored in FixedParameters.
            The regression likelihoods are stored as a single VectorGaussian called InducingDist.
            IncludePrior=false does not include the prior in the distribution (i.e. the distribution is degenerate).
            If pointFunc != null, the distribution is a point mass.
            If InducingDist is uniform and IncludePrior is false, the distribution is uniform.
            The GP prior is assumed to be non-uniform.
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.fixedParameters">
            <summary>
            Field for FixedParameters property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.InducingDist">
            <summary>
            The regression likelihoods that modify the prior.
            </summary>
            <remarks>
            If this field is changed, ClearCachedValues() must be called before accessing any other property.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.IncludePrior">
            <summary>
            Whether this sparse GP includes the prior
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.pointFunc">
            <summary>
            Use for setting point distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.alpha">
            <summary>
            Field for Alpha property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.beta">
            <summary>
            Field for Beta property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.meanB">
            <summary>
            Field for Mean_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.varBB">
            <summary>
            Field for Var_B_B property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ClearCachedValues">
            <summary>
            Function to signal recalculation of calculated parameters.
            This is called automatically if the fixed parameter
            class is swapped out, or if the kernel is changed, or
            if parameters are changed. It should also be called
            by any external program modifies the kernel or other
            fixed parameters in place
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean at a given point
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive covariance at a given pair of points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive coariance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Constructs sparse GP, given basis etc
            </summary>
            <param name="spgf">The fixed parameters</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,System.Boolean)">
            <summary>
            
            </summary>
            <param name="spgf">Fixed parameters</param>
            <param name="includePrior">Whether this instance includes the prior</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,System.Boolean,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Constructor from full specification
            </summary>
            <param name="spgf">Fixed parameters</param>
            <param name="includePrior">Whether this instance includes the prior</param>
            <param name="InducingDist">Inducing distribution</param>
            <param name="pointFunc">If not null, set this as a point distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Uniform(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Creates a uniform sparse GP
            </summary>
            <param name="sgpf"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.PointMass(MicrosoftResearch.Infer.Distributions.SparseGPFixed,MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Creates a sparse GP point mass - i.e. all the mass is at a given function
            </summary>
            <param name="sgpf"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Clone">
            <summary>
            Clone. Note that the fixed parameters and the rank1 list
            are just referenced
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetTo(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets one sparse GP to another. Everything is copied
            except the FixedParameters and the lsit of rank 1 potentials
            which are referenced.
            </summary>
            <param name="that">The sparse GP to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this instance to the product of two sparse GPs.
            </summary>
            <param name="a">Sparse GP</param>
            <param name="b">Sparse GP</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the product of two other SparseGPs
            </summary>
            <param name="a">First SparseGP</param>
            <param name="b">Second SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP,System.Boolean)">
            <summary>
            Sets this instance to the ratio of two sparse GPs.
            </summary>
            <param name="numerator">Sparse GP</param>
            <param name="denominator">Sparse GP</param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Division(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the ratio of two other SparseGPs
            </summary>
            <param name="numerator">numerator SparseGP</param>
            <param name="denominator">denominator SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToPower(MicrosoftResearch.Infer.Distributions.SparseGP,System.Double)">
            <summary>
            Sets this sparse GP the the power of another sparse GP
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogProb(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Gets the log density for a given value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.EvaluateMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the mean function of the GP
            </summary>
            <param name="X">Input variable</param>
            <returns>Evaulated function value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToUniform">
            <summary>
            Sets to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.IsUniform">
            <summary>
            Asks the distribution whether it is uniform
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.MaxDiff(System.Object)">
            <summary>
            Max difference between two sparse GPs - used for
            convergence testing
            </summary>
            <param name="thatd">That sparse GP which will be compared to this sparse GP</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetMean">
            <summary>
            Gets the mean function for the Sparse GP
            </summary>
            <returns>The mean function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function 
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function. result is ignored
            <param name="result">This argument is ignored</param>
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,System.Double,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this SparseGP distribution to the weighted sum of two other such distributions
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Gets the log of the integral of the product of this SparseGP and that SparseGP
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.SparseGP,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            The expected logarithm of that distribution under this distribution
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.FixedParameters">
            <summary>
            Sets and gets the fixed sparse parameters - parameters
            which are not changed by inference
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Alpha">
            <summary>
            Alpha - along with beta, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Beta">
            <summary>
            Beta - along with alpha, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Mean_B">
            <summary>
            m(B). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Var_B_B">
            <summary>
            var(B, B). This is a calculated matrix maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Point">
            <summary>
            Sets or Gets a point. If not a point function,
            the get returns the mean function of the sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.IsPointMass">
            <summary>
            Asks the distribution whether it is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.LinearSpline">
            <summary>
            Very simple 1-D linear spline class which implements IFunction.
            Assumes knots at regular positions - given by a start and increment.
            The vector of knot values defines how many knots.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.LinearSpline.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the linear spline at a given point. Only
            1-D input spaces are supported - so only the first element
            of X is considered
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotStart">
            <summary>
            Knot start position
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotIncrem">
            <summary>
            Knot position increment
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.YPoints">
            <summary>
            Y points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GaussianProcess">
            <summary>
            A base class for Gaussian process distributions
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianProcess.mean">
            <summary>
            Mean function
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianProcess.kernel">
            <summary>
            Covariance function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.#ctor(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction)">
            <summary>
            Constructor
            </summary>
            <param name="mean">Mean function</param>
            <param name="kernel">Kernel function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Sample">
            <summary>
            This base class just returns the mean function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Sample(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            This base class just returns the mean function
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean at a given point
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive covariance at a given pair of points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive coariance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGPFixed">
            <summary>
            This class maintains all the fixed parameters for a sparse GP
            - i.e. parameters which the inference does not change.
            All SparseGP messages can refer to a single SparseGPFixed
            class, and cloning of SparseGP instances will just copy the
            reference
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.prior">
            <summary>
            field for Prior property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.basis">
            <summary>
            Field for basis property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.kBB">
            <summary>
            Field for calculated KernelOf_B_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.invKBB">
            <summary>
            Field for calculated InvKernelOf_B_B property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.ClearCachedValues">
            <summary>
            Function to signal recalculation of KBB and InvKBB.
            This is be called by the basis and kernel
            function property set functions, and should
            also be called by any external program
            which directly modifies the kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Recalculate">
            <summary>
            Function to recalulate KBB and InvKBB
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_X_B(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel of a point against the basis
            </summary>
            <param name="x">Input</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_X_B(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Evaluates the kernel of a list of points against the basis
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Constructor from kernel function and basis
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor(MicrosoftResearch.Infer.Distributions.IGaussianProcess,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Constructor from prior and basis
            </summary>
            <param name="prior"></param>
            <param name="basis"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Prior">
            <summary>
            Prior distribution to which basis points are added.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Basis">
            <summary>
            List of basis vectors
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_B_B">
            <summary>
            Kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.InvKernelOf_B_B">
            <summary>
            Inverse of the kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberFeatures">
            <summary>
            Number of features - i.e. the dimension of the
            GP index space
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberBasisPoints">
            <summary>
            Number of basis points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IsDistributionWrapper">
            <summary>
            Marker interface for classes which wrap distributions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.AccumulateIntoCollection`1">
            <summary>
            An Accumulator that adds each element to a collection.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SampleList`1">
            <summary>
            Sample List
            </summary>
            <typeparam name="T">Domain type for sample list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SampleList`1.Samples">
            <summary>
            Samples
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConditionalList`1">
            <summary>
            Conditional List
            </summary>
            <typeparam name="TDist">Distribution type for conditional list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Conditionals">
            <summary>
            Samples
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2">
            <summary>
            Gibbs marginal - wraps underlying estimator, provides burn-in and thinning,
            and maintains thinned samples and conditionals
            </summary>
            <typeparam name="TDist">The distribution type</typeparam>
            <typeparam name="T">The domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(`0,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor from a distribution prototype, and burn in and thin parameters
            </summary>
            <param name="distPrototype">Prototype distribution</param>
            <param name="burnIn">Burn in - number of sample discarded initially</param>
            <param name="thin">Thinning parameter - only every 'thin' samples returned</param>
            <param name="estimateMarginal"></param>
            <param name="collectSamples"></param>
            <param name="collectDistributions"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
            <remarks>This does a soft copy of the estimator and sample and conditional lists</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastSample">
            <summary>
            Last sample added. If no samples, returns default(T)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastConditional">
            <summary>
            Last conditional distribution added. If no conditionals, returns uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Clear">
            <summary>
            Clears out all the samples and clears the accumulators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.GetDistribution(`0)">
            <summary>
            Get the estimated distribution from the samples
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.PostUpdate">
            <summary>
            Perform an update by adding a sample from the last conditional
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.ToString">
            <summary>
            Shows the GibbsMarginal in string form
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Estimator">
            <summary>
            The embedded estimator
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Samples">
            <summary>
            Thinned samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Conditionals">
            <summary>
            Thinned conditionals
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Distribution">
            <summary>
            The marginal
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.ARD">
            <summary>
            Automatic Relevance Determination Kernel
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction">
            <summary>
            Base class for all kernel functions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams">
            <summary>
            Interface for Kernel functions with parameters
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction">
            <summary>
            Interface for all Kernel functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.IndexToName(System.Int32)">
            <summary>
            Gets the name of a specified hyperparameter index
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The name</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">String Writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">String Reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Item(System.String)">
            <summary>
            Sets or gets a log hyper-parameter by name
            </summary>
            <param name="name">Name of the hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.TypeVersion">
            <summary>
            The version for the derived class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaNames">
            <summary>
            Hyper-parameter names
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaValues">
            <summary>
            Hyper-parameter values
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaName2Index">
            <summary>
            Dictionary that allows look-up of index from hype-parameter name
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor(System.Collections.Generic.IList{System.String})">
            <summary>
            Protected constructor - derived classes pass down their list
            of hyper-parameter names
            </summary>
            <param name="hyperNames"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.IndexToName(System.Int32)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Write(System.IO.StreamWriter)">
            <summary>
            Writes the parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Read(System.IO.StreamReader)">
            <summary>
            Read the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Cholesky(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.Dictionary{System.Int32,MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Cholesky of Kernel matrix
            </summary>
            <param name="kf">Kernel function</param>
            <param name="xData">Data with which to build the matrix</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.HyperNames">
            <summary>
            Sets the names of the hyper-parameters. Note that this destroys any values
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.String)">
            <summary>
            Sets or gets hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logLengths">Log of the lengths</param>
            <param name="logSigVar">Log of the signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an ARD kernel from a vector of log lengths, and a log signal variance
            </summary>
            <param name="logLengths"></param>
            <param name="logSigVar"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises lengths</param>
            <param name="y">y data - initialises signal standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory">
            <summary>
            Kernel Factory - singleton class. It maintains a list
            of Kernel names and their types
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.RegisterKernelFunction(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Registers a kernel function. The factory is primed with stock
            kernel functions. This function allows clients to add in custom
            kernel functions
            </summary>
            <param name="ikf">Type instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.CreateKernelFunction(System.String)">
            <summary>
            Creates a kernel function by specifying the kernel function name
            </summary>
            <param name="name">Name of the kernel function</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.Instance">
            <summary>
            Kernel function factory singleton instance
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel">
            <summary>
            Linear kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.SetupParams(System.Double[])">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor(System.Double[])">
            <summary>
            Constructs a linear kernel from vector of log variances
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data. The variance is
            set as the square of the inverse of the 'length' of the
            input feature. Note that the variance we are trying to set
            up here corresponds to the variance of the weight parameters
            in a linear model, not to the variance of the input feature.
            </summary>
            <param name="X">X data - initialises variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel">
            <summary>
            Neural Net kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogWeightVariances">
            <summary>
            Gets the log weight variances from this Neural Net kernel instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogBiasWeightVariance">
            <summary>
            Gets the log bias variances from this Neural Net kernel instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an neural net kernel from vector of log lweight variances
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential">
            <summary>
            Squared Exponential kernel function: k(x,y) = exp(-0.5*(x-y)^2/exp(2*logLength))
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor(System.Double,System.Double)">
            <summary>
            Constructs the kernel k(x,y) = exp(2*logSignalSD - 0.5*(x-y)^2/exp(2*logLength))
            </summary>
            <param name="logLengthScale">Log length</param>
            <param name="logSignalSD">Log signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor(System.Double)">
            <summary>
            Constructs the kernel k(x,y) = exp(- 0.5*(x-y)^2/exp(2*logLength))
            </summary>
            <param name="logLengthScale"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor">
            <summary>
            Constructs the kernel k(x,y) = exp(- 0.5*(x-y)^2)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.LogLengthScale">
            <summary>
            Sets/gets log of the length scale
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.LogSignalSD">
            <summary>
            Gets/sets log of the signal variance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel">
            <summary>
            Summation kernel. This provides the management layer for adding
            together different kernels
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.kernels">
            <summary>
            List of kernels in the summation
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexInKernel">
            <summary>
            Index of a hyper-parameter within a participating kernel
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexOfKernel">
            <summary>
            Index of the kernel to which the hyper-parameter belongs
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.thetaCount">
            <summary>
            Parameter counts of the individual kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.clearMaps">
            <summary>
            Clear maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.initialise">
            <summary>
            (Re-)initialise a summation kernel. This clears
            all participating kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.buildMaps">
            <summary>
            Helper method for building maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Constructs summation kernel from an initial kernel function
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.op_Addition(MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel,MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Adds two kernel functions
            </summary>
            <param name="kernelA"></param>
            <param name="kernelB"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Kernels">
            <summary>
            The participating kernels
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.ThetaCount">
            <summary>
            Number of theta parameters
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">parameter index</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.String)">
            <summary>
            Set or get hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise">
            <summary>
            White noise kernel function. This can be added to other kernels using the
            SummationKernel class to provide measurement noise
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor">
            <summary>
            Default constructor for white noise kernel function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor(System.Double)">
            <summary>
            Construct white noise kernel function from log noise standard deviation
            </summary>
            <param name="logNoiseSD">Log noise standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ListDistribution`4">
            <summary>
            A base class for distributions over lists that use a weighted finite state automaton as the underlying weight function.
            </summary>
            <typeparam name="TList">The type of a list.</typeparam>
            <typeparam name="TElement">The type of a list element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over list elements.</typeparam>
            <typeparam name="TThis">The type of a concrete distribution class.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ListDistribution`3">
            <summary>
            Represents a distribution over lists that use a weighted finite state automaton as the underlying weight function.
            </summary>
            <typeparam name="TList">The type of a list.</typeparam>
            <typeparam name="TElement">The type of a list element.</typeparam>
            <typeparam name="TElementDistribution">The type of a distribution over list elements.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy matrix observations,
            and computing sample count, mean matrix, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Mean">
            <summary>
            Mean matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Variance">
            <summary>
            Covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Adds a weighted observation
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
            <remarks>The contents of noiseVariance are modified.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an accumulator for matrix observations
            </summary>
            <param name="rows"></param>
            <param name="cols"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Rows">
            <summary>
            The number of rows in the matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Cols">
            <summary>
            The number of columns in the matrix
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Mixture`1">
            <summary>
            A mixture of distributions of the same type 
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Components">
            <summary>
            The components
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Weights">
            <summary>
            The mixing weight of each component.  Does not necessarily sum to 1.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0,System.Double)">
            <summary>
            Add a component to the mixture with a given weight
            </summary>
            <param name="item">The component to add</param>
            <param name="weight">The weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0)">
            <summary>
            Add a component to the mixture. A weight of 1 is assumed
            </summary>
            <param name="item">The component to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.WeightSum">
            <summary>
            The sum of the component weights
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Normalize">
            <summary>
            Normalize the weights to add to 1
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.GetDistribution(MicrosoftResearch.Infer.Distributions.Mixture{`0})">
            <summary>
            The the resulting mixture
            </summary>
            <param name="result">Where to put the resulting mixture</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.#ctor">
            <summary>
            Create a mixture model
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian">
            <summary>
            Nonconjugate Gaussian messages for VMP. The mean has a Gaussian distribution and the variance a Gamma distribution. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MeanTimesPrecision">
            <summary>
            Mean times precision for the mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Precision">
            <summary>
            Precision for the mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Shape">
            <summary>
            Shape parameter for the variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Rate">
            <summary>
            Rate parameter for the variance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetGaussian">
            <summary>
            Convert to the optimal Gaussian
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetGaussian(System.Boolean)">
            <summary>
            Convert to the optimal Gaussian
            </summary>
            <param name="addEntropy">Whether to include an entropy term</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Constructs a non-conjugate Gaussian from a Gaussian
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a non-conjugate Gaussian distribution its parameters 
            </summary>
            <param name="meanTimesPrecision">Mean times precision for the mean</param>
            <param name="precision">Precision for the mean</param>
            <param name="shape">Shape parameter for the variance</param>
            <param name="rate">Rate parameter for the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.IsProper">
            <summary>
            Returns true if the distribution is proper
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToUniform">
            <summary>
            Sets this to a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.IsUniform">
            <summary>
            Returns true if distribution is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#CanGetLogProb{System#Double}#GetLogProb(System.Double)">
            <summary>
            Gets the log probability of the given value
            </summary>
            <param name="value"></param>
            <returns>Not yet implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetTo(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets this non-congugate Gaussian to a Gaussian
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetTo(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Sets this non-conjugate Gaussian to another non-conjugate Gaussian
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the product of two others.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Product operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Boolean)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the ratio of two others.
            </summary>
            <param name="numerator">Numerator</param>
            <param name="denominator">Denominator</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the power of another.
            </summary>
            <param name="value">The </param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#Sampleable{System#Double}#Sample">
            <summary>
            Samples from a non-conjugate Gaussian distribution
            </summary>
            <returns>Not yet implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#Sampleable{System#Double}#Sample(System.Double)">
            <summary>
            Samples from a non-conjugate Gaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Uniform">
            <summary>
            Create a uniform non-conjugate Gaussian distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance of this distribution
            </summary>
            <param name="mean">Output mean</param>
            <param name="variance">Output variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.ToString">
            <summary>
            Print details as as string
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Pareto">
            <summary>
            A Pareto distribution over the real numbers from lowerBound to infinity.
            </summary>
            <remarks>
            The distribution has two parameters (shape, lowerBound) which must be positive for the distribution to be proper.  
            Its density function is
            <c>p(x) = s L^s / x^(s+1)</c> for <c>x &gt;= L</c>.
            If shape = -1, the distribution is uniform.
            If shape = infinity, the distribution is a point mass on the lowerBound.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Pareto.Shape">
            <summary>
            The shape parameter
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Pareto.LowerBound">
            <summary>
            The lower bound
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Pareto.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Pareto distribution with the given parameters.
            </summary>
            <param name="lowerBound"></param>
            <param name="shape"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Pareto.#ctor(MicrosoftResearch.Infer.Distributions.Pareto)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Pareto.Uniform">
            <summary>
            Creates a uniform Pareto distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Pareto.op_Multiply(MicrosoftResearch.Infer.Distributions.Pareto,MicrosoftResearch.Infer.Distributions.Pareto)">
            <summary>
            Static product operator. Create a Pareto distribution which is the product of
            two Pareto distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.PointMass`1">
            <summary>
            A point mass, which is the 'distribution' you get for an observed variable.
            All the probability mass is at the point given by observed value.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.#ctor(`0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The location of the point mass.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Create(`0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The location of the point mass.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Clone">
            <summary>
            Creates a copy of the point mass.
            </summary>
            <returns>The new PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.MaxDiff(System.Object)">
            <summary>
            Returns 0 if the two distributions are the same, positive infinity otherwise.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToUniform">
            <summary>
            Always throws an exception, since a PointMass cannot be set to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.IsUniform">
            <summary>
            Always returns false
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetLogProb(`0)">
            <summary>
            Returns 0 if the value is at the point mass and negative infinity elsewhere.
            </summary>
            <param name="value">The value at which to compute the log probability.</param>
            <returns>0 or negative infinity</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Sample">
            <summary>
            Returns the location of the point mass
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Sample(`0)">
            <summary>
            Returns the location of the point mass
            </summary>
            <param name="result">Where to put the result</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetMean">
            <summary>
            Returns the location of the point mass
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetTo(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Sets this point mass to that point mass
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToProduct(MicrosoftResearch.Infer.Distributions.PointMass{`0},MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Throws an exception unless the two point masses are equal 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToRatio(MicrosoftResearch.Infer.Distributions.PointMass{`0},MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Boolean)">
            <summary>
            Not supported
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToPower(MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Double)">
            <summary>
            Sets to the value of the given point mass
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Double,MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Throws an exception unless the point masses are equal
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Returns 0 if the this and that point mass are equal, negative infinity otherwise
            </summary>
            <param name="that"></param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetAverageLog(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Returns 0 if the this and that point mass are equal, negative infinity otherwise
            </summary>
            <param name="that"></param>
            <returns>Not implemented</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.Point">
            <summary>
            The location of the point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.IsPointMass">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsAutomaton">
            <summary>
            An implementation of <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase"/>, which works on a given distribution as follows:
            <list type="bullet">
            <item><description>
            If the distribution is not a point mass, applies the underlying automaton format to the probability function.
            </description></item>
            <item><description>
            If the distribution is a point mass, applies the underlying automaton format to the automaton representation of the point.
            </description></item>
            </list>
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsAutomaton.#ctor(MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsAutomaton"/> class.
            </summary>
            <param name="automatonFormat">The underlying automaton format. </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsAutomaton.ConvertPointMassToString``6(``5)">
            <summary>
            Converts a point mass distribution to a string by first converting the point to an automaton function and
            then using the underlying automaton function format on that function.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="sequenceDistribution"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TWeightFunction">The type of weight functions used by <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceDistribution">The concrete type of <paramref name="sequenceDistribution"/>.</typeparam>
            <param name="sequenceDistribution">The sequence distribution to convert to string.</param>
            <returns>The string representation of the <paramref name="sequenceDistribution"/>.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsString">
            <summary>
            An implementation of <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.AutomatonBasedSequenceDistributionFormatBase"/>, which works on a given distribution as follows:
            <list type="bullet">
            <item><description>
            If the distribution is not a point mass, applies the underlying automaton format to the probability function.
            </description></item>
            <item><description>
            If the distribution is a point mass, simply calls <see cref="M:System.Object.ToString"/> on the point.
            </description></item>
            </list>
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsString.#ctor(MicrosoftResearch.Infer.Distributions.Automata.IAutomatonFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsString"/> class.
            </summary>
            <param name="automatonFormat">The underlying automaton format. </param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Automata.SequenceDistributionFormatPointMassAsString.ConvertPointMassToString``6(``5)">
            <summary>
            Converts a point mass distribution to a string by calling <see cref="M:System.Object.ToString"/> on the point.
            </summary>
            <typeparam name="TSequence">The type of sequences <paramref name="sequenceDistribution"/> is defined on.</typeparam>
            <typeparam name="TElement">The type of sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TElementDistribution">The type of distributions over sequence elements of <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceManipulator">The type providing ways to manipulate instances of <typeparamref name="TSequence"/>.</typeparam>
            <typeparam name="TWeightFunction">The type of weight functions used by <paramref name="sequenceDistribution"/>.</typeparam>
            <typeparam name="TSequenceDistribution">The concrete type of <paramref name="sequenceDistribution"/>.</typeparam>
            <param name="sequenceDistribution">The sequence distribution to convert to string.</param>
            <returns>The string representation of the <paramref name="sequenceDistribution"/>.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Poisson">
            <summary>
            A Poisson distribution over the integers [0,infinity).
            </summary>
            <remarks><para>
            The Poisson is often used as a distribution on counts.
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            where rate is the rate parameter.
            In this implementation, we use a generalization called the Conway-Maxwell Poisson or "Com-Poisson", which
            has an extra precision parameter nu.  
            The formula for the distribution is <c>p(x) =propto rate^x / x!^nu</c>.
            With this extension, we can represent a uniform distribution via (rate=1,nu=0) and 
            a point mass via rate=0 or nu=infinity.  
            This family is closed under multiplication, while the standard Poisson is not.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Rate">
            <summary>
            The rate parameter of the COM-Poisson distribution, always >= 0.
            </summary>
            <remarks>
            The natural parameter of the distribution is log(rate).  
            However, since rate remains >= 0 under multiplication, there
            is no harm in using rate as the parameter.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Precision">
            <summary>
            The precision parameter of the COM-Poisson distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Clone">
            <summary>
            Clones this COM-Poisson. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Poisson type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.MaxDiff(System.Object)">
            <summary>
            Returns the maximum difference between the parameters of this COM-Poisson
            and another COM-Poisson
            </summary>
            <param name="that">The other COM-Poisson</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Equality(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Inequality(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToUniform">
            <summary>
            Sets this COM-Poisson instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsProper">
            <summary>
            Asks whether this instance is proper or not. A COM-Poisson distribution
            is proper if Rate >= 0 and (Precision > 0 or (Precision == 0 and Rate &lt; 1)).
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of of the density function of this COM-Poisson at the given value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>log p(x=value)</returns>
            <remarks>
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            when nu=1.  In the general case, it is <c>p(x) =propto rate^x / x!^nu</c>.
            If the distribution is improper, the normalizer is omitted.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetTo(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets this COM-Poisson instance to have the parameter values of another COM-Poisson instance
            </summary>
            <param name="value">The other COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToProduct(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets the parameters to represent the product of two COM-Poissons.
            </summary>
            <param name="a">The first COM-Poisson</param>
            <param name="b">The second COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Multiply(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new COM-Poisson which is the product of two other COM-Poissons
            </summary>
            <param name="a">The first COM-Poisson</param>
            <param name="b">The second COM-Poisson</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToRatio(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two COM-Poisson distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <param name="forceProper">If true, the result has precision >= 0 and rate &lt;= 1</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Division(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new Poisson which is the ratio of two other COM-Poissons
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToPower(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Sets the parameters to represent the power of a COM-Poisson to some exponent.
            </summary>
            <param name="dist">The source Poisson</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Raises a COM-Poisson to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Poisson,System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the log of the integral of the product of this COM-Poisson with another COM-Poisson.
            </summary>
            <param name="that">The other COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetAverageLog(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the expected logarithm of a COM-Poisson under this COM-Poisson.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.FromMeanAndMeanLogFactorial(System.Double,System.Double)">
            <summary>
            Create a COM-Poisson distribution with the given sufficient statistics.
            </summary>
            <param name="mean">E[x]</param>
            <param name="meanLogFactorial">E[log(x!)]</param>
            <returns>A new COM-Poisson distribution</returns>
            <remarks>
            This routine implements maximum-likelihood estimation of a COM-Poisson distribution, as described by
            Thomas P. Minka, Galit Shmueli, Joseph B. Kadane, Sharad Borle, and Peter Boatwright,
            "Computing with the COM-Poisson distribution", CMU Tech Report 776.
            http://www.stat.cmu.edu/tr/tr776/tr776.html
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMeanLogFactorial">
            <summary>
            Computes (sum_{x=0..infinity} log(x!) Rate^x / x!^Precision) / (sum_{x=0..infinity} Rate^x / x!^Precision )
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumLogFactorial(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} log(x!) lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumLogFactorial2(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} log(x!)^2 lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumXLogFactorial(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} x log(x!) lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogNormalizer(System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} lambda^x / x!^nu)
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogPowerSum(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} x^p lambda^x / x!^nu)
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <param name="p">Exponent.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample">
            <summary>
            Samples from a Poisson distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Int32)">
            <summary>
            Sample from a Poisson - use <see cref="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample"/> instead
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Double)">
            <summary>
            Samples from a Poisson distribution with given mean
            </summary>
            <param name="mean">Must be >= 0</param>
            <returns>An integer in [0,infinity)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Double,System.Double)">
            <summary>
            Samples from a COM-Poisson distribution
            </summary>
            <param name="rate">Rate.</param>
            <param name="precision">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double)">
            <summary>
            Creates a Poisson distribution with the given mean.
            </summary>
            <param name="mean"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double,System.Double)">
            <summary>
            Create a Com-Poisson distribution with the given rate and precision.
            </summary>
            <param name="rate"></param>
            <param name="precision"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Uniform">
            <summary>
            Instantiates a uniform Com-Poisson distribution
            </summary>
            <returns>A new uniform Com-Poisson distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.PointMass(System.Int32)">
            <summary>
            Creates a Com-Poisson distribution which only allows one value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.PoissonEstimator">
            <summary>
            Estimates a Poisson distribution from samples.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Retrieves an estimation of the distribution
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Add(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Add a distribution sample to the estimator
            </summary>
            <param name="item">The item to add</param>
            <remarks>Assumes a Com-Poisson precision of 1.0</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Clear">
            <summary>
            Clear the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Add(System.Double)">
            <summary>
            Add a domain sample to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.SetTo(MicrosoftResearch.Infer.Distributions.PoissonEstimator)">
            <summary>
            Set this estimator to another
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Clone">
            <summary>
            Clone this estimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList">
            <summary>
            Represents a sparse list of Bernoulli distributions, optimized for the case where many share 
            the same parameter value. The class supports
            an approximation tolerance which allows elements close to the common value to be
            automatically reset to the common value. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3">
            <summary>
            Abstract base class for a homogeneous sparse list of distributions. The class supports
            an approximation tolerance which allows elements close to the common value to be
            automatically reset to the common value. The list implements the
            interfaces which allow these distributions to participate in message passing.
            </summary>
            <typeparam name="TDist">The distribution type for the elements of the sparse list.</typeparam>
            <typeparam name="TDomain">The domain type for the distribution elements.</typeparam>
            <typeparam name="TThis">The type of a specialized class derived from this class.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSize(System.Int32,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Constant(System.Int32,`0,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class with the specified number of elements
            all of which are set to the specified value.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class of a given length
            and assigns all elements the given value, except for the specified list of sparse values.
            This list is stored internally as is, so MUST be sorted by index and must not be modified
            externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSparseList(MicrosoftResearch.Infer.Collections.ISparseList{`0},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class from a sparse list of distributions.
            </summary>
            <param name="distributions">The sparse list of distributions.</param>
            <param name="tolerance">The tolerance.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSize(System.Int32)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class
            with the specified number of elements all of which are set to uniform.
            </summary>
            <param name="size">The size of the list.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Constant(System.Int32,`0)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class
            with the specified number of elements all of which are set to the specified value.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.ValueAtIndex{`0}})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class
            of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="commonValue">The common value.</param>
            <param name="sortedSparseValues">The sorted list of non-common values.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.FromSparseList(MicrosoftResearch.Infer.Collections.ISparseList{`0})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/> class from a sparse list of distributions.
            </summary>
            <param name="distributions">The sparse list of distributions.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Clone">
            <summary>
            Clones this <see cref="T:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3"/>.
            </summary>
            <returns>The clone returned as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.MaxDiff(System.Object)">
            <summary>
            Returns the maximum difference between the parameters of this sparse distribution list
            and another.
            </summary>
            <param name="thatd">The other sparse distribution list.</param>
            <returns>The maximum difference.</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetToUniform">
            <summary>
            Sets this sparse distribution list to be a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.IsUniform">
            <summary>
            Asks whether this sparse distribution list is uniform.
            </summary>
            <returns>True if all elements of the list are uniform, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetLogProb(MicrosoftResearch.Infer.Collections.ISparseList{`1})">
            <summary>
            Evaluates the log of the density function.
            </summary>
            <param name="value">The point at which to evaluate the density.</param>
            <returns>The log probability of the given value>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Sample">
            <summary>
            Samples from this sparse distribution list.
            </summary>
            <returns>A sample from this distribution.</returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Sample(MicrosoftResearch.Infer.Collections.ISparseList{`1})">
            <summary>
            Samples from this sparse distribution list.
            </summary>
            <param name="result">Where to put the result.</param>
            <returns>A sample from this distribution.</returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetTo(`2)">
            <summary>
            Sets this sparse distribution list to another sparse distribution list.
            </summary>
            <param name="value">The other sparse distribution list.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetToProduct(`2,`2)">
            <summary>
            Sets this sparse distribution list to the product of two other sparse distribution lists.
            </summary>
            <param name="a">Left hand side.</param>
            <param name="b">Right hand side.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetToPower(`2,System.Double)">
            <summary>
            Sets this sparse distribution list to the power of another sparse distribution list.
            </summary>
            <param name="value">The value.</param>
            <param name="exponent">The exponent.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetToRatio(`2,`2,System.Boolean)">
            <summary>
            Sets this sparse distribution list to the ratio of two other sparse Gaussian lists.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <param name="forceProper">Whether to force the result to be proper.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.SetToSum(System.Double,`2,System.Double,`2)">
            <summary>
            Creates a sparse distribution list to the weighted sums of the elements of two other sparse distribution lists.
            </summary>
            <param name="weight1">The first weight.</param>
            <param name="value1">The first sparse distribution list.</param>
            <param name="weight2">The second weight.</param>
            <param name="value2">The second sparse distribution list.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetLogAverageOf(`2)">
            <summary>
            Returns the log probability that this distribution and another draw the same sample.
            </summary>
            <param name="that">The other distribution.</param>
            <returns>The log probability that this distribution and another draw the same sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetLogAverageOfPower(`2,System.Double)">
            <summary>
            Returns the log of the integral of the product of this sparse distribution list and another sparse distribution list raised to a power.
            </summary>
            <param name="that">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The log average of the power of the second distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetAverageLog(`2)">
            <summary>
            Returns the expected logarithm of that sparse distribution list under this sparse distribution list.
            </summary>
            <param name="that">The other distribution.</param>
            <returns>The expected logarithm of the other distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetMean">
            <summary>
            Gets the mean as a sparse list.
            </summary>
            <returns>The mean of this distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.GetVariance">
            <summary>
            Gets the variance as a sparse list.
            </summary>
            <returns>The variance of this distribution.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Dimension">
            <summary>
            Gets the dimension of the sparse distribution list.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.Point">
            <summary>
            Gets or sets the instance as a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseDistributionList`3.IsPointMass">
            <summary>
            Gets a value indicating whether the instance is a point mass.
            </summary>
            <returns>True if all elements of the list are point masses, false otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromProbTrue(System.Int32,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class of a given size, with each
            element having a given probability of true.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="probTrue">The desired probability of true.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromLogOdds(System.Int32,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class of a given size, with each
            element having a given log odds.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logOdds">The desired log odds.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromProbTrue(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class, with each
            element having a given probability of true.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="probTrue">The desired probability of true.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromLogOdds(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class of a given size, with each
            element having a given log odds.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logOdds">The desired log odds.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromProbTrue(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class of a given size
            from a sparse list of probability true.
            </summary>
            <param name="probTrue">The sparse list of probability of true.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromLogOdds(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class of a given size
            from a sparse list of log odds.
            </summary>
            <param name="logOdds">The sparse list of log odds.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromProbTrue(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class
            of a given size from a sparse list of probability true.
            </summary>
            <param name="probTrue">The sparse list of probability of true.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.FromLogOdds(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> class
            of a given size from a sparse list of log odds.
            </summary>
            <param name="logOdds">The sparse list of log odds.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Samples from a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> with the specified probability of true.
            </summary>
            <param name="probTrue">Probability of true.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution which is the product of two others.
            </summary>
            <param name="a">The first distribution.</param>
            <param name="b">The second distribution.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.op_Division(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution which is the ratio of two others.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,System.Double)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution which is the power of another.
            </summary>
            <param name="dist">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/> distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseBetaList">
            <summary>
            Represents a sparse list of Beta distributions, optimized for the case where many share 
            the same parameter value. The class supports
            an approximation tolerance which allows elements close to the common value to be
            automatically reset to the common value. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.FromCounts(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class of a given size, with each
            element having given true and false counts.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="trueCount">The true count.</param>
            <param name="falseCount">The false count.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>A new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.FromCounts(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class
            from sparse lists of true and false counts.
            </summary>
            <param name="trueCounts">The true counts.</param>
            <param name="falseCounts">The false counts.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>A new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.FromCounts(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class
            of a given size, with each element having given true and false counts.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="trueCount">The true count.</param>
            <param name="falseCount">The false count.</param>
            <returns>A new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.FromCounts(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class
            from sparse lists of true and false counts.
            </summary>
            <param name="trueCounts">The true counts.</param>
            <param name="falseCounts">The false counts.</param>
            <returns>A new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> class.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Samples from a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> with the specified sparse lists
            of true counts and false counts.
            </summary>
            <param name="trueCounts">The true counts.</param>
            <param name="falseCounts">The false counts.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution which is the product of two others
            </summary>
            <param name="a">The first distribution.</param>
            <param name="b">The second distribution.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.op_Division(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution which is the ratio of two others
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.SparseBetaList,System.Double)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution which is the power of another.
            </summary>
            <param name="dist">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBetaList"/> distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGammaList">
            <summary>
            Represents a sparse list of Gamma distributions, optimized for the case where many share 
            the same parameter value. The class supports
            an approximation tolerance which allows elements close to the common value to be
            automatically reset to the common value. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndVariance(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given mean and variance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndMeanLog(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given mean and mean log.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromLogMeanAndMeanLog(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given log mean and mean log.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given shape and rate.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shape">The shape value.</param>
            <param name="rate">The rate value (= 1/scale).</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size with given shape and rate Vectors.
            </summary>
            <param name="shape">The shape vector.</param>
            <param name="rate">The rate vector (= 1/scale).</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given shape and scale.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shape">The shape value.</param>
            <param name="scale">The scale value.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            CReturns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            from sparse lists of shapes and scales.
            </summary>
            <param name="shape">The shape values.</param>
            <param name="scale">The scale values.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromNatural(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having the specified natural parameters.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shapeMinus1">shape - 1.</param>
            <param name="rate">rate = 1/scale.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndVariance(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given mean and variance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndMeanLog(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given mean and mean log.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromLogMeanAndMeanLog(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given log mean and mean log.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given shape and rate.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shape">The shape value.</param>
            <param name="rate">The rate value (= 1/scale).</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class of a given size with given shape and rate Vectors.
            </summary>
            <param name="shape">The shape vector.</param>
            <param name="rate">The rate vector (= 1/scale).</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having a given shape and scale.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shape">The shape value.</param>
            <param name="scale">The scale value.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class from sparse lists of shapes and scales.
            </summary>
            <param name="shape">The shape values.</param>
            <param name="scale">The scale values.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromNatural(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> class
            of a given size, with each element having the specified natural parameters.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="shapeMinus1">shape - 1.</param>
            <param name="rate">rate = 1/scale.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Samples from a list of Gamma distributions with the specified vectors.
            of shapes and rates
            </summary>
            <param name="shapes">Vector of shapes.</param>
            <param name="rates">Vector of rates.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution which is the product of two others.
            </summary>
            <param name="a">The first distribution.</param>
            <param name="b">The second distribution.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.op_Division(MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution which is the ratio of two others.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.SparseGammaList,System.Double)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution which is the power of another.
            </summary>
            <param name="dist">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGammaList"/> distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList">
            <summary>
            Represents a sparse list of Gaussian distributions, optimized for the case where many share 
            the same parameter value. The class supports
            an approximation tolerance which allows elements close to the common value to be
            automatically reset to the common value. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndVariance(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class
            of a given size, with each element having a given mean and variance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class
            of a given size, with each element having a given mean and precision.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class from sparse mean and precision lists.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromNatural(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class
            of a given size, with each element having the specified natural parameters.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="meanTimesPrecision">The mean times precision value.</param>
            <param name="precision">The precision value.</param>
            <param name="tolerance">The tolerance for the approximation.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndVariance(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> 
            class of a given size, with each element having a given mean and variance.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class
            of a given size, with each element having a given mean and precision.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Returns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class from sparse mean and precision lists.
            </summary>
            <param name="mean">The desired mean values.</param>
            <param name="precision">The desired precision values.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromNatural(System.Int32,System.Double,System.Double)">
            <summary>
            CReturns a new instance of the <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> class
            of a given size, with each element having the specified natural parameters.
            </summary>
            <param name="size">The size of the list.</param>
            <param name="meanTimesPrecision">The mean times precision value.</param>
            <param name="precision">The precision value.</param>
            <returns>The new <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> instance.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>
            Samples from a list of Gaussian distributions with the specified vectors.
            of means and precisions
            </summary>
            <param name="means">Vector of means.</param>
            <param name="precs">Vector of precisions.</param>
            <returns>The sample.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution which is the product of two others.
            </summary>
            <param name="a">The first distribution.</param>
            <param name="b">The second distribution.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.op_Division(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution which is the ratio of two others.
            </summary>
            <param name="numerator">The numerator.</param>
            <param name="denominator">The denominator.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Double)">
            <summary>
            Creates a <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution which is the power of another.
            </summary>
            <param name="dist">The other distribution.</param>
            <param name="exponent">The exponent.</param>
            <returns>The resulting <see cref="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList"/> distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.StringDistribution">
            <summary>
            Represents a distribution over strings that uses a weighted finite state automaton as the underlying weight function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.op_Addition(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>
            Concatenates the weighted regular languages defined by given distributions
            (see <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Append(`5,System.Byte)"/>).
            </summary>
            <param name="first">The first distribution.</param>
            <param name="second">The second distribution.</param>
            <returns>The concatenation result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.String(System.String)">
            <summary>
            Creates a point mass distribution.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.PointMass(`0)"/>.
            </summary>
            <param name="str">The point.</param>
            <returns>The created point mass distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Char(System.Char)">
            <summary>
            Creates a distribution which puts all mass on a string containing only a given character.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SingleElement(`1)"/>.
            </summary>
            <param name="ch">The character.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Char(MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>
            Creates a distribution over strings of length 1 induced by a given distribution over characters.
            This method is an alias for <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.SingleElement(`2)"/>.
            </summary>
            <param name="characterDist">The distribution over characters.</param>
            <returns>The created distribution.</returns>
            <remarks>
            The distribution created by this method can differ from the result of
            <see cref="M:MicrosoftResearch.Infer.Distributions.SequenceDistribution`6.Repeat(`5,System.Int32,System.Nullable{System.Int32})"/>
            with both min and max length set to 1 since the latter always creates a partial uniform distribution.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.CaseInvariant(System.String)">
            <summary>
            Creates a uniform distribution over all strings that are case-invariant matches of the specified string.
            </summary>
            <param name="template">The string to match.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Lower(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of lowercase letters, with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Upper(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of uppercase letters, with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Letters(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of lowercase and uppercase letters, with length in given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Digits(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of digits, with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.LettersOrDigits(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of digits, lowercase and uppercase letters, with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.WordChars(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of word characters (see <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.WordChar"/>),
            with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Whitespace(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings of whitespace characters (see <see cref="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Whitespace"/>),
            with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 1.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Capitalized(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a uniform distribution over strings that start with an upper case letter followed by
            one or more lower case letters, with length within the given bounds.
            If <paramref name="maxLength"/> is set to <see langword="null"/>,
            there will be no upper bound on the length, and the resulting distribution will thus be improper.
            </summary>
            <param name="minLength">The minimum possible string length. Defaults to 2.</param>
            <param name="maxLength">
            The maximum possible sequence length, or <see langword="null"/> for no upper bound on length.
            Defaults to <see langword="null"/>.
            </param>
            <returns>The created distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.TruncatedGaussian">
            <summary>
            A distribution over real numbers between an upper and lower bound.  If both bounds are infinite, it reduces to an ordinary Gaussian distribution.
            </summary>
            <remarks>
            The distribution is parameterized by a Gaussian and two real numbers (LowerBound, UpperBound).
            Between the bounds, the density is proportional to the Gaussian.  Outside of the bounds, the density is zero.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Gaussian">
            <summary>
            Untruncated Gaussian
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.LowerBound">
            <summary>
            Lower bound
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.UpperBound">
            <summary>
            Upper bound
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Create a new TruncatedGaussian distribution equal to that
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Create a truncated Gaussian equivalent to a Gaussian, i.e. with no truncation.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.FromGaussian(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Create a truncated Gaussian equivalent to a Gaussian, i.e. with no truncation.
            </summary>
            <param name="gaussian"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Create a truncated Gaussian from a Gaussian and bounds
            </summary>
            <param name="gaussian"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a truncated Gaussian from untruncated (mean, variance) and bounds
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Uniform">
            <summary>
            Construct a uniform truncated Gaussian. This is mathematically equivalent to
            a uniform Gaussian. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.PointMass(System.Double)">
            <summary>
            Create a point mass distribution.
            </summary>
            <param name="point">The location of the point mass</param>
            <returns>A new TruncatedGaussian with all probability concentrated on the given point.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.ToGaussian">
            <summary>
            Get the Gaussian with the same moments as this truncated Gaussian. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that
            </summary>
            <param name="thatd"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Equals(System.Object)">
            <summary>
            True if this distribution has the same parameters as that
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetHashCode">
            <summary>
            A hash of the distribution parameter values
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Equality(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Clone">
            <summary>
            Make a deep copy of this distribution. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogProb(System.Double)">
            <summary>
            Get the log probability density at value. 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogNormalizer">
            <summary>
            Gets the log of the normalizer for the Gaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsProper">
            <summary>
            Returns true if this distribution is proper
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetTo(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set this distribution equal to value. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set this distribution equal to the product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Operator overload for product. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToUniform">
            <summary>
            Set the distribution to uniform with infinite bounds
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform. If the upper and lower bounds are finite the distribution
            is not uniform. 
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Boolean)">
            <summary>
            Set this equal to numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Division(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Operator overload for division
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Set this equal to (dist)^exponent
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Operator overload for exponentation
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sample from a TruncatedGaussian distribution with the specified parameters
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample(System.Double)">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetMean">
            <summary>
            Returns the mean (first moment) of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Get the mean and variance after truncation.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetVariance">
            <summary>
            Get the variance of this distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Get the logarithm of the average value of that distribution under this distribution, i.e. log(int this(x) that(x) dx)
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.ToString">
            <summary>
            A human-readable string containing the parameters of the distribution
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Get the average logarithm of that distribution under this distribution, i.e. int this(x) log( that(x) ) dx
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Point">
            <summary>
            Set this distribution to a point mass, or get its location
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsPointMass">
            <summary>
            True if the distribution is a point mass. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator">
            <summary>
            Estimates a TruncatedGaussian distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.#ctor">
            <summary>
            Creates a new TruncatedGaussian estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Adds a TruncatedGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Computes the maximum-likelihood TruncatedGaussian from the samples.
            </summary>
            <param name="result"></param>
            <returns>Returns a new TruncatedGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete">
            <summary>
            Represents a discrete distribution in the log domain without explicit normalization.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.logProb">
            <summary>
            Log probability of each value (when not a point mass).  Since the distribution is unnormalized, these may be shifted by an arbitrary constant.
            </summary>
            <remarks>
            logprob.Length == D.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Clone">
            <summary>
            Clones this unnormalised discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a UnnormalizedDiscrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromLogProbs(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Creates an unnormalized discrete distribution from a vector of log probabilities.
            </summary>
            <param name="logProb"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromDiscrete(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates an unnormalized discrete distribution from a normal discrete distribution.
            </summary>
            <param name="d">The discrete distribution</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform unnormalized discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToUniform">
            <summary>
            Sets this instance to a uniform distribution (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsUniform">
            <summary>
            Returns whether the distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of the unnormalized density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log unnormalized density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the unnormalized probability at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The unnormalized probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal log prob Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetLogProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetLogProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetLogProbs(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets the log probability vector for this distribution.
            </summary>
            <param name="logProbs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetTo(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToProduct(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters to represent the product of two unnormalized discrete distributions.
            </summary>
            <param name="a">The first unnormalized discrete distribution</param>
            <param name="b">The second unnormalized discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.op_Multiply(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Creates an unnormalized discrete distribution which is the product of two unnormalized discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting unnormalized discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToRatio(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two unnormalized discrete distributions.
            </summary>
            <param name="numerator">The first unnormalized discrete distribution</param>
            <param name="denominator">The second unnormalized discrete distribution</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.op_Division(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Creates an unnormalized discrete distribution which is the ratio of two unnormalized discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting unnormalized discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString(System.String)">
            <summary>
            Override of ToString method which allows custom number formatting
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetProbs">
            <summary>
            Gets the unnormalized probability vector for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetMaxToZero">
            <summary>
            Rescales the unnormalised distribution, so that the max log prob is zero i.e. the max unnormalised prob is 1.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Dimension">
            <summary>
            Dimension of the unnormalised discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsPointMass">
            <summary>
            Whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussian">
            <summary>
            Represents a multivariate Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is parameterized by MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = inv(v), MeanTimesPrecision = inv(v)*m.
            </para><para>
            Some special cases:
            If the precision is zero, then the distribution is uniform.
            If the precision is infinite along the diagonal, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            If precision[i,i] is infinite, then the distribution is a point mass along dimension i.  Point[i] gives the mean.
            The rest of the row and column of precision must be zero.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = |2*pi*v|^(-d/2) * exp(-0.5 (x-m)' inv(v) (x-m))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v is singular, the density is redefined to be <c>exp(-0.5 x' inv(v) x + x' inv(v) m)</c>, 
            i.e. we drop the terms <c>|2*pi*v|^(-d/2) * exp(-0.5 m' inv(v) m)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance of the distribution.
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="variance">Modified to contain the covariance matrix.  Must already be the correct size.</param>
            <remarks>Because the Gaussian stored its parameters in exponential form, it is more efficient
            to compute the mean and variance at the same time rather than separately.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean vector and precsion matrix of the distribution
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="precision">Modified to contain the precision matrix.  Must already be the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and variance of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="variance">The covariance matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and precision of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the natural parameters of the distribution (mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMode">
            <summary>
            The most likely value
            </summary>
            <returns>A new Vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new Vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean of the distribution
            </summary>
            <param name="result">Where to place the mean value</param>
            <returns>mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Get the mean of the distribution
            </summary>
            <param name="result">Where to place the mean vector</param>
            <param name="variance">The pre-computed inverse of this.Precision</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <param name="variance">Where to place the variance-covariance</param>
            <returns>variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean vector
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToUniform">
            <summary>
            Sets this VectorGaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluate the log of multivariate Gaussian density with specified mean vector
            and covariance matrix
            </summary>
            <param name="x">Where to evaluate the density function</param>
            <param name="mean">The mean vector</param>
            <param name="variance">A non-singular covariance matrix.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogNormalizer">
            <summary>
            Gets the normalizer for the VectorGaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="meanTimesPrecision">Precision matrix times the mean vector.</param>
            <param name="precision">A non-singular precision matrix (inverse of covariance matrix).</param>
            <param name="L">Same size as precision.</param>
            <param name="iLb">Same size as x.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="L">Work matrix - same size as Precision</param>
            <param name="iLb">Work vector - same size as x</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProbPrep">
            <summary>
            Returns an Evaluator delegate which has a pre-allocated workspace
            for efficient evaluation calculation. If you are generating many
            evaluations, call this method to get an Evaluator, then use the Evaluator
            delegate to calculate the evaluations
            </summary>
            <returns>Evaluator delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Log-integral of the product of this VectorGaussian with that VectorGaussian
            </summary>
            <param name="that">That VectorGaussian</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples from a VectorGaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SampleFromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples from a VectorGaussian distribution with the specified mean and variance
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <param name="precL">A DxD workspace</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample">
            <summary>
            Sample from this VectorGaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SamplePrep">
            <summary>
            Returns a sampler delegate which has a pre-allocated workspace
            for efficient sample calculation. If you are generating many
            samples, call this method to get a sampler, then use the sampler
            delegate to generate samples.
            </summary>
            <returns>Sampler delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets this VectorGaussian instance to have the parameter values of that VectorGaussian instance
            </summary>
            <param name="that">That VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="g1">The first VectorGaussian.  May refer to <c>this</c>.</param>
            <param name="g2">The second VectorGaussian.  May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the product of two other VectorGaussians
            </summary>
            <param name="a">First VectorGaussian</param>
            <param name="b">Second VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Boolean)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="numerator">The numerator VectorGaussian.  Can be the same object as <c>this</c>.</param>
            <param name="denominator">The denominator VectorGaussian</param>
            <param name="forceProper">If true, the precision of the result is made non-negative definite, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Division(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the ratio of two other VectorGaussians
            </summary>
            <param name="numerator">numerator VectorGaussian</param>
            <param name="denominator">denominator VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source VectorGaussian to some exponent.
            </summary>
            <param name="dist">The source VectorGaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the mean and covariance to match a VectorGaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First VectorGaussian</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matchs the mean and variance/covariance
            of a VectorGaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this VectorGaussian
            and that VectorGaussian
            </summary>
            <param name="thatd">That VectorGaussian</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Clone">
            <summary>
            Clones this VectorGaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a VectorGaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor">
            <summary>
            Constructs a new VectorGaussian
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets this VectorGaussian to the value of another
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Copy(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a copy of a given VectorGaussian
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Uniform(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromCursors(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian from Cursor objects.
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
            <remarks>The cursors will use their existing source array.
            The Gaussian will reference the given cursors.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a VectorGaussian point mass at the specified location
            </summary>
            <param name="mean">Where to position the point mass</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(System.Double)">
            <summary>
            Creates a VectorGaussian point mass where the location is a
            vector of identical values
            </summary>
            <param name="mean">The value for the mean vector</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a new VectorGaussian from its natural parameters (Mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision matrix</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and precision.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a VectorGaussian with given mean and precision matrix.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsProper">
            <summary>
            Asks whether this VectorGaussian instance is proper or not. A VectorGaussian distribution
            is proper only if its precision matrix is positive definite.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMarginal(System.Int32)">
            <summary>
            The marginal distribution of one dimension.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMarginal(System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            The marginal distribution of a subvector.
            </summary>
            <param name="firstDim">The first dimension of the subvector</param>
            <param name="result">A VectorGaussian receiving the result, whose Dimension specifies the length of the subvector.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.MeanTimesPrecision">
            <summary>
            Gets/Sets Mean times precision
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Precision">
            <summary>
            Gets/sets precision value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Dimension">
            <summary>
            The dimension of the VectorGaussian domain
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new VectorGaussian estimator of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Adds a VectorGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Adds a weighted VectorGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
            <param name="weight">The weight of the distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a sample item to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a sample item with a given weight to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result">May be null.</param>
            <returns>If result is not null, modifies and returns result.  
            Otherwise returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Dimension">
            <summary>
            Dimension of the VectorGaussian
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy vector observations,
            and computing sample count, mean vector, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds an observation 
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.#ctor(System.Int32)">
            <summary>
            Constructs an accumulator for vector observations
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Mean">
            <summary>
            Mean
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Variance">
            <summary>
            Covariance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Dimension">
            <summary>
            The dimensionality of the vector
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Wishart">
            <summary>
            A Wishart distribution on positive definite matrices.
            </summary>
            <remarks><para>
             In the matrix case, the distribution is
              <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>B</c> parameter
            is called the "Rate".  The
            mean of the distribution is <c>a/B</c> and the diagonal variance is 
            <c>var(X_ii) = a*C_ii^2</c> where <c>C=inv(B)</c>.  The non-diagonal variances are
            <c>var(X_ij) = a*0.5*(C_ij^2 + C_ii*C_jj)</c> where <c>C=inv(B)</c>.
            </para><para>
            The distribution is represented by a one-dimensional Vector for <c>a</c> and 
            a PositiveDefiniteMatrix for <c>B</c>.  Because both are Cursors, any Wishart instance
            can be used as a cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetScale">
            <summary>
            Gets the scale matrix
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <param name="mean">Where to put the mean matrix</param>
            <returns>The mean matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance of the distribution
            </summary>
            <param name="variance">Where to put the variance</param>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance matrices.
            </summary>
            <param name="mean">Where to put the mean - assumed to be of the correct size</param>
            <param name="variance">Where to put the variance - assumed to be of the correct size</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>
            The mean is always matched, but the variance may not match exactly, since the distribution
            has only one scalar parameter for variance.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the scale matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the rate matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanLogDeterminant">
            <summary>
            Gets the mean log determinant
            </summary>
            <returns>The mean log determinant</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing rate matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToUniform">
            <summary>
            Sets this instance to have uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper">
            <summary>
            Asks whether this instance is proper
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Asks whether a Wishart distribution of the specified shape and rate is proper
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of a Wishart density function at a given point
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>The log density</returns>
            <remarks>
            The distribution is <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            When a &lt;= (d-1)/2 the <c>Gamma_d(a)</c> term is dropped.
            When B &lt;= 0 the <c>|B|^a</c> term is dropped.
            Thus if shape = (d+1)/2 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of this Wishart density function at a given point
            </summary>
            <param name="X">Where to evaluate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the normalizer for a Wishart density function specified by shape and rate matrix
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">rate matrix</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer">
            <summary>
            Gets the normalizer for the density function of this Wishart distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetAverageLog(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Gets the log-integral of the product of this Wishart with another Wishart
            </summary>
            <param name="that">The other Wishart</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Samples this Wishart distribution
            </summary>
            <param name="result">Where to put the sample</param>
            <param name="cholB">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholX">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholXt">A workspace matrix of the same dimension as the distribution</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples this Wishart distribution. Workspaces are allocated behind the scenes
            </summary>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample">
            <summary>
            Samples this Wishart distribution. Workspaces and sample matrix are allocated
            behind the scenes
            </summary>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and scale.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <param name="result">Receives the sample</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetTo(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets this Wishart instance to have the parameter values of another Wishart instance
            </summary>
            <param name="that">The other Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToProduct(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets the parameters to represent the product of two Wisharts.
            </summary>
            <param name="g1">The first Wishart. May refer to <c>this</c>.</param>
            <param name="g2">The second Wishart. May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Multiply(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which the product of two other Wisharts
            </summary>
            <param name="a">First Wishart</param>
            <param name="b">Second Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToRatio(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Wisharts.
            </summary>
            <param name="numerator">The numerator Wishart</param>
            <param name="denominator">The denominator Wishart</param>
            <param name="forceProper">If true, the result shape >= (dimension+1)/2 and rate is non-negative definite</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Division(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which is the ratio of two other Wishart
            </summary>
            <param name="numerator">numerator Wishart</param>
            <param name="denominator">denominator Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPower(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Wishart to some exponent.
            </summary>
            <param name="dist">The source Wishart</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Weighted mixture distribution for two Wisharts
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First Wishart</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a weighted mixture distribution for distributions whose mean and variance are both
            of type PositiveDefiniteMatrix. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Wishart
            and that Wishart
            </summary>
            <param name="thatd">That Wishart</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Clone">
            <summary>
            Clones this Wishart. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Wishart type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Uniform(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,System.Double)">
            <summary>
            Creates a one-dimensional Wishart with given shape and scale
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The one-dimesional scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a new multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and rate matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a rate matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="rate">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromMeanAndMeanLogDeterminant(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Constructs a Wishart distribution with the given mean and mean log determinant.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLogDet">Desired expected log determinant.</param>
            <param name="result"></param>
            <returns>A new Wishart distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Wishart distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetDerivatives(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,System.Boolean,System.Double)">
            <summary>
            Modify the parameters so that the pdf has the given derivatives at a point.
            </summary>
            <param name="xChol">Cholesky factor of the point X</param>
            <param name="invX">Inverse of X.  Can be the same object as <c>this.Rate</c></param>
            <param name="dlogp">Desired derivative.  Can be the same object as <c>this.Rate</c></param>
            <param name="xxddlogp">tr(x tr(x dlogp')/dx)</param>
            <param name="forceProper">If true and both derivatives cannot be matched, match only the first.</param>
            <param name="shapeOffset"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(System.Double)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass is a vector where every element equals this value</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Rate">
            <summary>
            Sets/gets the rate matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Shape">
            <summary>
            Sets/gets the shape value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Point">
            <summary>
            Sets/gets this instance as a point-mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Dimension">
            <summary>
            Dimension of this distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray">
            <summary>
            Gets/sets the source array for the Wishart parameters. These are stored
            contiguously in the SourceArray as Rate matrix followed by shape
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.StringUtil">
            <summary>
            Helpful methods for converting objects to strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.TypeToString(System.Type)">
            <summary>
            Get a C# style string describing a .NET type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.AppendTypes(System.Text.StringBuilder,System.Type[])">
            <summary>
            Append type strings to a StringBuilder
            </summary>
            <param name="s"></param>
            <param name="types"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.AppendTypes(System.Text.StringBuilder,System.Type[],System.Boolean,MicrosoftResearch.Infer.Collections.Set{System.Type})">
            <summary>
            Append type strings to a StringBuilder
            </summary>
            <param name="s"></param>
            <param name="types"></param>
            <param name="showConstraints"></param>
            <param name="constrained"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodFullNameToString(System.Reflection.MethodBase)">
            <summary>
            Get a string of the form "typeName.methodName&lt;types&gt;".
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodNameToString(System.Reflection.MethodBase)">
            <summary>
            Get a string of the form "methodName&lt;types&gt;"
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodSignatureToString(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Get a short string describing the signature of a method.
            </summary>
            <param name="method">The method to get the signature for.</param>
            <param name="useFullName">Specifies whether the name of the method should be prepended with the name of the class.</param>
            <param name="omitParameterNames">Specifies whether the parameter names should be omitted from the result.</param>
            <returns>A string of the form "methodName&lt;types&gt;(parameters)"</returns>
            <remarks>From the C# 3.0 specification sec 1.6.6: 
            The signature of a method consists of the name of the method, 
            the number of type parameters and the number, modifiers, and types of its parameters. 
            The signature of a method does not include the return type.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.CollectionToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Get a string of list elements separated by a delimiter
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.ArrayToString(System.Array)">
            <summary>
            Get a string listing all elements of an array on a separate line
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.ArrayToString(System.Collections.IEnumerable,System.Int32[],System.Int32[])">
            <summary>
            Get a string listing all elements of an array, one per line
            </summary>
            <param name="a"></param>
            <param name="strides"></param>
            <param name="lowerBounds"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.ToString(System.Object)">
            <summary>
            Get a verbose string describing an object, or invoke the object's custom ToString method if it exists
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.VerboseToString(System.Object)">
            <summary>
            Get a string describing the contents of an object by enumerating its items and properties.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.DictionaryToString``2(System.Collections.Generic.IDictionary{``0,``1},System.String)">
            <summary>
            Get a string listing the entries of a dictionary, one per line.
            </summary>
            <typeparam name="KeyType"></typeparam>
            <typeparam name="ValueType"></typeparam>
            <param name="dict"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.DictionaryToString(System.Collections.IDictionary,System.String)">
            <summary>
            Get a string listing the entries of a dictionary, one per line.
            </summary>
            <param name="dict"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.EnumerableToString(System.Collections.IEnumerable,System.String)">
            <summary>
            Get a string listing the elements of an enumerable, one per line.
            </summary>
            <param name="a"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.IndexerToString(System.Object,System.String)">
            <summary>
            Get a string listing the elements of an indexable object, one per line
            </summary>
            <param name="o"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.JoinColumns(System.String[][])">
            <summary>
            Create a string denoting a multi-line table with multiple columns.
            </summary>
            <param name="lines">lines[column][line] is a single text line in the column.</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.WishartEstimator">
            <summary>
            Estimates a Wishart distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            E[X] = (a+(d+1)/2)/B
            var(X_ii) = (a+(d+1)/2)*diag(inv(B))^2
            because X_ii ~ Gamma(a+(d+1)/2, 1/diag(inv(B))).
            Therefore: 
            a = E[X_ii]^2/var(X_ii) - (d+1)/2
            B = (a+(d+1)/2)/E[X]
            </code></remarks>
            In the one-dimensional case,
            E[log(x)] = -log(b) + digamma(a+1) 
                      =approx -log(b) + log(a+1) - 1/2/(a+1) 
                      = log(E[x]) - 1/2/(a+1)
            In the Wishart case,
            E[logdet(X)] = -logdet(B) + sum_{i=0..d-1} digamma(a + (d+1-i)/2)
                         =approx -logdet(B) + d*digamma(a+(d+1)/2)
                         =approx -logdet(B) + d*log(a+(d+1)/2) - d/2/(a+(d+1)/2) 
                         = log(E[X}) - d/2/(a+(d+1)/2)
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WishartEstimator.mva">
            <summary>
            Where to accumulate mean and variance matrices
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Wishart estimator
            </summary>
            <param name="dimension">The dimension of the Wishart distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Retrieves the Wishart estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Adds a Wishart distribution item to the estimator
            </summary>
            <param name="item">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="item">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.SetTo(MicrosoftResearch.Infer.Distributions.WishartEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WishartEstimator.Dimension">
            <summary>
            The dimension of the Wishart distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.WrappedGaussian">
            <summary>
            A Gaussian distribution on a periodic domain, such as angles between 0 and 2*pi.
            </summary>
            <remarks>
            The distribution is represented by a unwrapped Gaussian and a period length L.
            To get the wrapped density, the unwrapped density is summed over all shifts by L, i.e.
            p(x) = sum_k N(x + Lk; m, v)  over all integers k
            The wrapped density is automatically normalized over the range [0,L) because it 
            simply moves the probability mass that was previously distributed over the real line 
            to all lie in the interval [0,L).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Gaussian">
            <summary>
            The unwrapped Gaussian, with mean in [0,L)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Period">
            <summary>
            The period length, greater than zero
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Create a WrappedGaussian distribution
            </summary>
            <param name="unwrapped"></param>
            <param name="period"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a WrappedGaussian distribution
            </summary>
            <param name="unwrappedMean"></param>
            <param name="unwrappedVariance"></param>
            <param name="period"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Uniform(System.Double)">
            <summary>
            Create a uniform WrappedGaussian distribution
            </summary>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.PointMass(System.Double,System.Double)">
            <summary>
            Create a WrappedGaussian distribution with all mass on a single point
            </summary>
            <param name="point"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Mod(System.Double)">
            <summary>
            Return x modulo the period
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Mod(System.Double,System.Double)">
            <summary>
            Return x modulo the period
            </summary>
            <param name="x"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Clone">
            <summary>
            Make a deep copy of this distribution. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that
            </summary>
            <param name="thatd"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Equals(System.Object)">
            <summary>
            True if this distribution has the same parameters as that
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetHashCode">
            <summary>
            A hash of the distribution parameter values
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.ToString">
            <summary>
            A human-readable string containing the parameters of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Equality(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToUniform">
            <summary>
            Set the distribution to uniform, keeping the same period
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogProb(System.Double)">
            <summary>
            Get the log probability density at value. 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetTo(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set this distribution equal to value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set this distribution equal to the approximate product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <remarks>
            Since WrappedGaussians are not closed under multiplication, the result is approximate.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Creates a new WrappedGaussian which is the product of two other WrappedGaussians
            </summary>
            <param name="a">First WrappedGaussian</param>
            <param name="b">Second WrappedGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Boolean)">
            <summary>
            Set this equal to numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="value1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="value2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Sample(System.Double)">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Get the logarithm of the average value of that distribution under this distribution, i.e. log(int this(x) that(x) dx)
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Get the average logarithm of that distribution under this distribution, i.e. int this(x) log( that(x) ) dx
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>
            The result is approximate.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>
            Set this equal to (dist)^exponent
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Point">
            <summary>
            Set this distribution to a point mass, or get its location
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WrappedGaussian.IsPointMass">
            <summary>
            True if the distribution is a point mass. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllTrueOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>Evidence message for EP.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(allTrue,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>Evidence message for EP.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(allTrue,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AverageLogFactor(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>Evidence message for VMP.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(allTrue,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="allTrue">Incoming message from <c>allTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_allTrue">Outgoing message to <c>allTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(allTrue) p(allTrue) factor(allTrue,array))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="allTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>Evidence message for EP.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(allTrue,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="allTrue">Incoming message from <c>allTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(allTrue) p(allTrue) factor(allTrue,array) / sum_allTrue p(allTrue) messageTo(allTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>Evidence message for EP.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(allTrue,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>EP message to <c>allTrue</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>The outgoing EP message to the <c>allTrue</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>allTrue</c> as the random arguments are varied. The formula is <c>proj[p(allTrue) sum_(array) p(array) factor(allTrue,array)]/p(allTrue)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageConditional(System.Collections.Generic.IList{System.Boolean})">
            <summary>EP message to <c>allTrue</c>.</summary><param name="array">Constant value for <c>array</c>.</param><returns>The outgoing EP message to the <c>allTrue</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>allTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="allTrue">Incoming message from <c>allTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(allTrue) p(allTrue) factor(allTrue,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="allTrue"/> is not a proper distribution.</exception>
            <typeparam name="BernoulliList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{System.Boolean},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="allTrue">Incoming message from <c>allTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="array">Constant value for <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(allTrue) p(allTrue) factor(allTrue,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="allTrue"/> is not a proper distribution.</exception>
            <typeparam name="BernoulliList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>VMP message to <c>allTrue</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>The outgoing VMP message to the <c>allTrue</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>allTrue</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(allTrue,array)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="allTrue">Incoming message from <c>allTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>allTrue</c> integrated out. The formula is <c>sum_allTrue p(allTrue) factor(allTrue,array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="allTrue"/> is not a proper distribution.</exception>
            <typeparam name="BernoulliList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageLogarithm``1(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="allTrue">Constant value for <c>allTrue</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(allTrue,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAndOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for VMP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Incoming message from <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(and) p(and) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>and</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[p(and) sum_(a,b) p(a,b) factor(and,a,b)]/p(and)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>and</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[p(and) sum_(b) p(b) factor(and,a,b)]/p(and)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>and</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[p(and) sum_(a) p(a) factor(and,a,b)]/p(and)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(and,b) p(and,b) factor(and,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(and,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(and) p(and) factor(and,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(and,a) p(and,a) factor(and,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(and,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(and) p(and) factor(and,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Incoming message from <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(and,a,b) p(and,a,b) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Incoming message from <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(and,b) p(and,b) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Incoming message from <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(and,a) p(and,a) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(and,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Incoming message from <c>and</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(and) p(and) factor(and,a,b) / sum_and p(and) messageTo(and))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="and">Constant value for <c>and</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(and,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>and</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(and,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>and</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(and,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>and</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>and</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>and</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(and,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>and</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_and p(and) factor(and,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>and</c> integrated out. The formula is <c>sum_and p(and) factor(and,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(and,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>and</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_and p(and) factor(and,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="and">Incoming message from <c>and</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>and</c> integrated out. The formula is <c>sum_and p(and) factor(and,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="and"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(and,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="and">Constant value for <c>and</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)"/>, given random arguments to the function.</summary>
            <remarks>This factor is symmetric among all three arguments.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for VMP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(b) p(b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a) p(a) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>areEqual</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(areEqual,b) p(areEqual,b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(areEqual) p(areEqual) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(areEqual,a) p(areEqual,a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(areEqual) p(areEqual) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><param name="to_areEqual">Outgoing message to <c>areEqual</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Outgoing message to <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b) / sum_areEqual p(areEqual) messageTo(areEqual))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Outgoing message to <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(areEqual,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(areEqual,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>areEqual</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>areEqual</c> integrated out. The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>areEqual</c> integrated out. The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AverageLogFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual,a,b) p(areEqual,a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(areEqual,b) p(areEqual,b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(areEqual,b) p(areEqual,b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(areEqual,a) p(areEqual,a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(areEqual,a) p(areEqual,a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><param name="to_areEqual">Outgoing message to <c>areEqual</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Outgoing message to <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b) / sum_areEqual p(areEqual) messageTo(areEqual))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Outgoing message to <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayHelper">
            <summary>
            Helpful methods used by generated code.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.Fill``1(``0[],``0)">
            <summary>
            Fill an array with copies of an object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array to modify.</param>
            <param name="margprot">The object to copy into each element</param>
            <returns>The modified array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.Fill2D``1(``0[0:,0:],``0)">
            <summary>
            Fill a 2D array with copies of an object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array to modify</param>
            <param name="margprot">The object to copy into each element</param>
            <returns>The modified array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.MakeUniform``1(``0)">
            <summary>
            Create a clone of obj with uniform value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.SetToUniform``1(``0)">
            <summary>
            Call obj.SetToUniform() and return the object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.SetTo``1(``0,``0)">
            <summary>
            Call result.SetTo(value) and return result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result">The object to modify</param>
            <param name="value">The desired value</param>
            <returns>The modified object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.SetTo``1(``0[],``0[])">
            <summary>
            Call result.SetTo(value) and return result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result">The array to modify</param>
            <param name="values">The desired values</param>
            <returns>The modified array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.SetAllElementsTo``2(``0,``1)">
            <summary>
            Set all elements of an array to the same value.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="result">The array to modify</param>
            <param name="item">The desired value</param>
            <returns>The modified array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.SetAllElementsTo``1(``0[],``0)">
            <summary>
            Set all elements of an array to the same value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result">The array to modify</param>
            <param name="item">The desired value</param>
            <returns>The modified array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.MakeCopy``1(``0)">
            <summary>
            Make a deep copy of an object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.CopyStorage``1(``0)">
            <summary>
            Copies the storage of the passed in argument, without caring about its value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ArrayFromVector(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Constant value for <c>vector</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(array,vector))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Constant value for <c>vector</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(array,vector))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Constant value for <c>vector</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(array,vector))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(vector) p(vector) factor(array,vector))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(vector) p(vector) factor(array,vector))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><param name="to_vector">Outgoing message to <c>vector</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array,vector) p(array,vector) factor(array,vector))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Evidence message for EP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><param name="to_vector">Outgoing message to <c>vector</c>.</param><param name="to_array">Outgoing message to <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array,vector) p(array,vector) factor(array,vector) / sum_array p(array) messageTo(array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="array">Constant value for <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="vector">Constant value for <c>vector</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>vector</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>vector</c> as the random arguments are varied. The formula is <c>proj[p(vector) sum_(array) p(array) factor(array,vector)]/p(vector)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>vector</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>vector</c> with <c>array</c> integrated out. The formula is <c>sum_array p(array) factor(array,vector)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageConditional(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>vector</c>.</summary><param name="array">Constant value for <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>vector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageLogarithm(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>vector</c>.</summary><param name="array">Constant value for <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>vector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.ArrayAverageConditional``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>EP message to <c>array</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="vector">Incoming message from <c>vector</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_vector">Outgoing message to <c>vector</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(vector) p(vector) factor(array,vector)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="vector"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.ArrayAverageConditionalInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="vector">Incoming message from <c>vector</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="vector">Incoming message from <c>vector</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[sum_(vector) p(vector) factor(array,vector)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="vector"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the resulting array.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterOneOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Int32,``0,System.Int32)"/>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable entering the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterOneOp.ValueAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Discrete,``0,System.Int32,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterOne">Incoming message from <c>enterOne</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterOne,selector) p(enterOne,selector) factor(enterOne,selector,value,index)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterOne"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Int32,``0)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Boolean,``0)"/></description></item></list>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable entering the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,``0,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enter,selector) p(enter,selector) factor(enter,selector,value)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterPartialOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Int32,``0,System.Int32[])"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Boolean,``0,System.Int32[])"/></description></item></list>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable entering the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterPartialOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="selector"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterPartialOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="selector"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterPartialTwoOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])"/>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable entering the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateEnterPartialTwoOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartialTwo,case0,case1) p(enterPartialTwo,case0,case1) factor(enterPartialTwo,case0,case1,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartialTwo"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateExitOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])"/>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable exiting the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateExitOp.ExitAverageConditional``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BeliefPropagationGateExitTwoOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])"/>, given random arguments to the function.</summary>
            <remarks>
            The message operators contained in this class assume that the distribution
            of the variable exiting the gate can represent mixtures exactly.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BeliefPropagationGateExitTwoOp.ExitTwoAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exitTwo</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exitTwo</c> as the random arguments are varied. The formula is <c>proj[p(exitTwo) sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]/p(exitTwo)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample(System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,probTrue) p(sample,probTrue) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleConditional(System.Double)">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing Gibbs message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageConditional(System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueConditional(System.Boolean)">
            <summary>Gibbs message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing Gibbs message to the <c>probTrue</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageConditional(System.Boolean)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing EP message to the <c>probTrue</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(probTrue) p(probTrue) factor(sample,probTrue)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>probTrue</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>probTrue</c> as the random arguments are varied. The formula is <c>proj[p(probTrue) sum_(sample) p(sample) factor(sample,probTrue)]/p(probTrue)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,probTrue) p(sample,probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(probTrue) p(probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(System.Boolean,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageLogarithm(System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(probTrue) p(probTrue) log(factor(sample,probTrue)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageLogarithm(System.Boolean)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing VMP message to the <c>probTrue</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><returns>The outgoing VMP message to the <c>probTrue</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>probTrue</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleConditional(System.Boolean,System.Double,System.Double)">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="choice">Constant value for <c>choice</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing Gibbs message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="choice">Constant value for <c>choice</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="choice">Constant value for <c>choice</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceConditional(System.Boolean,System.Double,System.Double)">
            <summary>Gibbs message to <c>choice</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing Gibbs message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>choice</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>EP message to <c>choice</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing EP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>choice</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>VMP message to <c>choice</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing VMP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>choice</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="choice">Incoming message from <c>choice</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(choice) p(choice) factor(sample,choice,probTrue0,probTrue1)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>EP message to <c>choice</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing EP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>choice</c> as the random arguments are varied. The formula is <c>proj[p(choice) sum_(sample) p(sample) factor(sample,choice,probTrue0,probTrue1)]/p(choice)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="choice">Incoming message from <c>choice</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(choice) p(choice) log(factor(sample,choice,probTrue0,probTrue1)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>VMP message to <c>choice</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue0">Constant value for <c>probTrue0</c>.</param><param name="probTrue1">Constant value for <c>probTrue1</c>.</param><returns>The outgoing VMP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>choice</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,choice,probTrue0,probTrue1)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>EP message to <c>sample</c>.</summary><param name="choice">Incoming message from <c>choice</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(choice) p(choice) factor(sample,choice,probTrue)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(System.Boolean,System.Double[])">
            <summary>EP message to <c>sample</c>.</summary><param name="choice">Constant value for <c>choice</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>EP message to <c>choice</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>choice</c> as the random arguments are varied. The formula is <c>proj[p(choice) sum_(sample) p(sample) factor(sample,choice,probTrue)]/p(choice)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>VMP message to <c>sample</c>.</summary><param name="choice">Incoming message from <c>choice</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(choice) p(choice) log(factor(sample,choice,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>VMP message to <c>choice</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing VMP message to the <c>choice</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>choice</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,choice,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])"/>, given random arguments to the function.</summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="index">Incoming message from <c>index</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(index) p(index) factor(sample,index,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="index">Incoming message from <c>index</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(index) p(index) factor(sample,index,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleConditional(System.Int32,System.Double[])">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="index">Constant value for <c>index</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing Gibbs message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageConditional(System.Int32,System.Double[])">
            <summary>EP message to <c>sample</c>.</summary><param name="index">Constant value for <c>index</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageLogarithm(System.Int32,System.Double[])">
            <summary>VMP message to <c>sample</c>.</summary><param name="index">Constant value for <c>index</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Gibbs message to <c>index</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>index</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>index</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>index</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageLogarithm(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>index</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>index</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>EP message to <c>sample</c>.</summary><param name="index">Incoming message from <c>index</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(index) p(index) factor(sample,index,probTrue)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>VMP message to <c>sample</c>.</summary><param name="index">Incoming message from <c>index</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(index) p(index) log(factor(sample,index,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>index</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>index</c> as the random arguments are varied. The formula is <c>proj[p(index) sum_(sample) p(sample) factor(sample,index,probTrue)]/p(index)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>index</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="ProbTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>index</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,index,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            Performs KL minimization using gradient matching, a distributed gradient descent algorithm. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>logOdds</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>logOdds</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>logOdds</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>logOdds</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>logOdds</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>logOdds</c> as the random arguments are varied. The formula is <c>proj[p(logOdds) sum_(sample) p(sample) factor(sample,logOdds)]/p(logOdds)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Constant value for <c>logOdds</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,logOdds))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(logOdds) p(logOdds) factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Constant value for <c>logOdds</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,logOdds) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(logOdds) p(logOdds) factor(sample,logOdds))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(logOdds) p(logOdds) factor(sample,logOdds)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(System.Boolean,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Constant value for <c>logOdds</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="logOdds">Constant value for <c>logOdds</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(logOdds) p(logOdds) log(factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,logOdds) p(sample,logOdds) log(factor(sample,logOdds))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>sample</c>.</summary><param name="logOdds">Incoming message from <c>logOdds</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(logOdds) p(logOdds) log(factor(sample,logOdds)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logOdds"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageLogarithm(System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="logOdds">Constant value for <c>logOdds</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_LogOdds">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta">
            <summary>
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})"/>, given random arguments to the function.</summary>
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogAverageFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogAverageFactor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogAverageFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogEvidenceRatio(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogEvidenceRatio(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,probTrue) p(sample,probTrue) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbTrueConditional(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Gibbs message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbTrueAverageConditional(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(probTrue) p(probTrue) factor(sample,probTrue)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbTrueAverageConditional(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>probTrue</c> as the random arguments are varied. The formula is <c>proj[p(probTrue) sum_(sample) p(sample) factor(sample,probTrue)]/p(probTrue)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,probTrue) p(sample,probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(probTrue) p(probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(probTrue) p(probTrue) log(factor(sample,probTrue)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbTrueAverageLogarithm(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>probTrue</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.BetaOp.damping">
            <summary>
            How much damping to use to avoid improper messages. A higher value implies more damping. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>prob</c>. The formula is <c>exp(sum_(mean,totalCount) p(mean,totalCount) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>VMP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>The outgoing VMP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>prob</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>prob</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>prob</c>. The formula is <c>exp(sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>mean</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_mean">Previous outgoing message to <c>mean</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>mean</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><param name="to_mean">Previous outgoing message to <c>mean</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>mean</c>.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_mean">Previous outgoing message to <c>mean</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(prob,totalCount) p(prob,totalCount) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_totalCount">Previous outgoing message to <c>totalCount</c>.</param><returns>The outgoing VMP message to the <c>totalCount</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>totalCount</c>. The formula is <c>exp(sum_(mean,prob) p(mean,prob) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(prob,mean,totalCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,mean,totalCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>prob</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(totalCount,prob) p(totalCount,prob) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>totalCount</c> as the random arguments are varied. The formula is <c>proj[p(totalCount) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(totalCount)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>totalCount</c> as the random arguments are varied. The formula is <c>proj[p(totalCount) sum_(mean,prob) p(mean,prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Beta.Sample(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trueCount,falseCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trueCount,falseCount) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,trueCount,falseCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="trueCount">Constant value for <c>trueCount</c>.</param><param name="falseCount">Constant value for <c>falseCount</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Beta.SampleFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BinomialOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Binomial(System.Int32,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>The factor is f(sample,n,p) = choose(n,sample) p^sample (1-p)^(n-sample)</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,System.Double,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(trialCount) p(trialCount) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(p,trialCount) p(p,trialCount) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(p) p(p) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(trialCount) p(trialCount) factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(p,trialCount) p(p,trialCount) factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(System.Int32,System.Double,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(p) p(p) factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditionalInit(System.Int32)">
            <summary/><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(p) p(p) factor(sample,trialCount,p)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>sample</c>.</summary><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(trialCount) p(trialCount) factor(sample,trialCount,p)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>The outgoing EP message to the <c>trialCount</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>trialCount</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><returns>The outgoing EP message to the <c>trialCount</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>trialCount</c> as the random arguments are varied. The formula is <c>proj[p(trialCount) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(trialCount)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(trialCount) p(trialCount) factor(sample,trialCount,p)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(p,trialCount) p(p,trialCount) factor(sample,trialCount,p)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>trialCount</c> as the random arguments are varied. The formula is <c>proj[p(trialCount) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(trialCount)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>trialCount</c> as the random arguments are varied. The formula is <c>proj[p(trialCount) sum_(sample,p) p(sample,p) factor(sample,trialCount,p)]/p(trialCount)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>trialCount</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>trialCount</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>trialCount</c> as the random arguments are varied. The formula is <c>proj[p(trialCount) sum_(p) p(p) factor(sample,trialCount,p)]/p(trialCount)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageConditional(System.Int32,System.Int32)">
            <summary>EP message to <c>p</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing EP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>p</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>EP message to <c>p</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>The outgoing EP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>p</c> as the random arguments are varied. The formula is <c>proj[p(p) sum_(trialCount) p(trialCount) factor(sample,trialCount,p)]/p(p)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>EP message to <c>p</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing EP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>p</c> as the random arguments are varied. The formula is <c>proj[p(p) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(p)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,System.Double,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(p) p(p) log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(p,trialCount) p(p,trialCount) log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(trialCount) p(trialCount) log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(System.Int32,System.Int32)">
            <summary>VMP message to <c>p</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing VMP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>p</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>p</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>The outgoing VMP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>p</c>. The formula is <c>exp(sum_(trialCount) p(trialCount) log(factor(sample,trialCount,p)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>VMP message to <c>p</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing VMP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>p</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,trialCount,p)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>p</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Incoming message from <c>trialCount</c>.</param><returns>The outgoing VMP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>p</c>. The formula is <c>exp(sum_(sample,trialCount) p(sample,trialCount) log(factor(sample,trialCount,p)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageLogarithm(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>trialCount</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Constant value for <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>trialCount</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>trialCount</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>trialCount</c>. The formula is <c>exp(sum_(p) p(p) log(factor(sample,trialCount,p)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.BufferTester.Copy``1(``0)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.Buffer``1(``0,``0,``0)">
            <summary>Update the buffer <c>buffer</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.BufferInit``1(``0)">
            <summary>Initialize the buffer <c>buffer</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>Initial value of buffer <c>buffer</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.CopyAverageConditional``1(``0,``0)">
            <summary>EP message to <c>copy</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="buffer">Buffer <c>buffer</c>.</param><returns>The outgoing EP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[p(copy) sum_(value) p(value) factor(copy,value)]/p(copy)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.ValueAverageConditional``1(``0)">
            <summary>EP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>The outgoing EP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Buffer">
            <summary>
            Buffer factors
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1">
            <summary>
            Value factor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)">
            <summary>
            Infer factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BufferOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageConditional``1(``0)">
            <summary>EP message to <c>value</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageLogarithm``1(``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InferOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageConditional``1(``0,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CharFromProbabilitiesOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Char(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharFromProbabilitiesOp.CharacterAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>character</c>.</summary><param name="probabilities">Incoming message from <c>probabilities</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>character</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>character</c> as the random arguments are varied. The formula is <c>proj[p(character) sum_(probabilities) p(probabilities) factor(character,probabilities)]/p(character)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probabilities"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharFromProbabilitiesOp.ProbabilitiesAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>probabilities</c>.</summary><param name="character">Incoming message from <c>character</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probabilities">Incoming message from <c>probabilities</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>probabilities</c> as the random arguments are varied. The formula is <c>proj[p(probabilities) sum_(character) p(character) factor(character,probabilities)]/p(probabilities)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="character"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharFromProbabilitiesOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>Evidence message for EP.</summary><param name="probabilities">Incoming message from <c>probabilities</c>.</param><param name="character">Incoming message from <c>character</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probabilities,character) p(probabilities,character) factor(character,probabilities) / sum_character p(character) messageTo(character))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharFromProbabilitiesOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Char)">
            <summary>Evidence message for EP.</summary><param name="probabilities">Incoming message from <c>probabilities</c>.</param><param name="character">Constant value for <c>character</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probabilities) p(probabilities) factor(character,probabilities))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CharStringConcatOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.Char,System.String)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>concat</c>.</summary><param name="ch">Incoming message from <c>ch</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>The outgoing EP message to the <c>concat</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(ch,str) p(ch,str) factor(concat,ch,str)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>EP message to <c>str</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(concat,ch) p(concat,ch) factor(concat,ch,str)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.ChAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>ch</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>The outgoing EP message to the <c>ch</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ch</c> as the random arguments are varied. The formula is <c>proj[p(ch) sum_(concat,str) p(concat,str) factor(concat,ch,str)]/p(ch)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,ch,str) p(concat,ch,str) factor(concat,ch,str))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,ch,str) p(concat,ch,str) factor(concat,ch,str) / sum_concat p(concat) messageTo(concat))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CharStringConcatOp.LogEvidenceRatio(System.String,MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ch,str) p(ch,str) factor(concat,ch,str))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConcatOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.Concat(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(first,second) p(first,second) factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(second) p(second) factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(first) p(first) factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(first,second) p(first,second) factor(concat,first,second))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(concat,first,second))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(second) p(second) factor(concat,first,second))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(first) p(first) factor(concat,first,second))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="to_concat">Outgoing message to <c>concat</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second) / sum_concat p(concat) messageTo(concat))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditionalInit(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditionalInit(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditionalInit(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>concat</c>.</summary><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(first,second) p(first,second) factor(concat,first,second)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>concat</c>.</summary><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(second) p(second) factor(concat,first,second)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>concat</c>.</summary><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(first) p(first) factor(concat,first,second)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>first</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="second">Constant value for <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>first</c> as the random arguments are varied. The formula is <c>proj[p(first) sum_(concat) p(concat) factor(concat,first,second)]/p(first)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>first</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>first</c> as the random arguments are varied. The formula is <c>proj[p(first) sum_(concat,second) p(concat,second) factor(concat,first,second)]/p(first)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>second</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="first">Constant value for <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>second</c> as the random arguments are varied. The formula is <c>proj[p(second) sum_(concat) p(concat) factor(concat,first,second)]/p(second)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>second</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="first">Incoming message from <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>second</c> as the random arguments are varied. The formula is <c>proj[p(second) sum_(concat,first) p(concat,first) factor(concat,first,second)]/p(second)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>first</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>first</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>second</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>second</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>second</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>second</c> as the random arguments are varied. The formula is <c>proj[p(second) sum_(first) p(first) factor(concat,first,second)]/p(second)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(concat,first,second))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithmInit(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>concat</c>.</summary><param name="first">Incoming message from <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[sum_(first,second) p(first,second) factor(concat,first,second)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>concat</c>.</summary><param name="first">Constant value for <c>first</c>.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[sum_(second) p(second) factor(concat,first,second)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>concat</c>.</summary><param name="first">Incoming message from <c>first</c>.</param><param name="second">Constant value for <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[sum_(first) p(first) factor(concat,first,second)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>first</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="second">Constant value for <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>first</c> with <c>concat</c> integrated out. The formula is <c>sum_concat p(concat) factor(concat,first,second)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>first</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="second">Incoming message from <c>second</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>first</c>. Because the factor is deterministic, <c>concat</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(second) p(second) log(sum_concat p(concat) factor(concat,first,second)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>second</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="first">Constant value for <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>second</c> with <c>concat</c> integrated out. The formula is <c>sum_concat p(concat) factor(concat,first,second)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>second</c>.</summary><param name="concat">Incoming message from <c>concat</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="first">Incoming message from <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>second</c>. Because the factor is deterministic, <c>concat</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(first) p(first) log(sum_concat p(concat) factor(concat,first,second)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="concat"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>first</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>first</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>second</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Constant value for <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>second</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>second</c>.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="first">Incoming message from <c>first</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>second</c>. The formula is <c>exp(sum_(first) p(first) log(factor(concat,first,second)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstraintViolatedException">
            <summary>
            Exception which is thrown when a constraint is violated.  This
            occurs when an observation does not hold true or a weight is 0.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstraintViolatedException.#ctor(System.String)">
            <summary>
            Construct a constraint violated exception with a specified error message 
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Constrain">
            <summary>
            A repository of commonly used constraint methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)">
            <summary>
            Constrains a value to be equal to a sample from dist.
            </summary>
            <typeparam name="TDomain">Domain type</typeparam>
            <typeparam name="TDistribution">Distribution type</typeparam>
            <param name="value">Value</param>
            <param name="dist">Distribution instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)">
            <summary>
            Constrains a value to be equal to another value.
            </summary>
            <typeparam name="T">Value type</typeparam>
            <param name="A">First value</param>
            <param name="B">Second value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Contain(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            Constrains a set of integers to contain a particular integer.
            </summary>
            <param name="set">The set of integers, specified as a list</param>
            <param name="i">The integer which the set must contain</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)"/>, given random arguments to the function.</summary>
            <typeparam name="TDomain">The domain of the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageConditional``1(``0)">
            <summary>EP message to <c>value</c>.</summary><param name="dist">Incoming message from <c>dist</c>.</param><returns>The outgoing EP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(dist) p(dist) factor(value,dist)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(value,dist) p(value,dist) factor(value,dist))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(value,dist) p(value,dist) factor(value,dist))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="dist"/> is not a proper distribution.</exception>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(value,dist) p(value,dist) factor(value,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(value,dist) p(value,dist) factor(value,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(``0,``0)">
            <summary>Evidence message for VMP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(value,dist) p(value,dist) log(factor(value,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(`0,``0)">
            <summary>Evidence message for VMP.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="dist">Incoming message from <c>dist</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(value,dist) p(value,dist) log(factor(value,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="dist"/> is not a proper distribution.</exception>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageLogarithm``1(``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="dist">Incoming message from <c>dist</c>.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. The formula is <c>exp(sum_(dist) p(dist) log(factor(value,dist)))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,`0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor(`0,`0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,`0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio(`0,`0)">
            <summary>Evidence message for EP.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(``0,``0)">
            <summary>EP message to <c>A</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(A,B)]/p(A)</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(`0,``0)">
            <summary>EP message to <c>A</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(A,B)]/p(A)</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(``0,``0)">
            <summary>EP message to <c>B</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(A,B)]/p(B)</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(`0,``0)">
            <summary>EP message to <c>B</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(A,B)]/p(B)</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>A</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. The formula is <c>exp(sum_(B) p(B) log(factor(A,B)))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>B</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. The formula is <c>exp(sum_(A) p(A) log(factor(A,B)))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(`0,``0)">
            <summary>VMP message to <c>A</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. The formula is <c>exp(sum_(B) p(B) log(factor(A,B)))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(`0,``0)">
            <summary>VMP message to <c>B</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. The formula is <c>exp(sum_(A) p(A) log(factor(A,B)))</c>.</para>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AMaxConditional``1(``0,``0)">
            <summary/><param name="B">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BMaxConditional``1(``0,``0)">
            <summary/><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDistribution">The distribution over the constrained variables.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainContainOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Contain(System.Collections.Generic.IList{System.Int32},System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainContainOp.SetAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>VMP message to <c>set</c>.</summary><param name="i">Constant value for <c>i</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>set</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Double(System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.LogEvidenceRatio(System.Double,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="Double">Constant value for <c>double</c>.</param><param name="Integer">Constant value for <c>integer</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(double,integer))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="Double">Constant value for <c>double</c>.</param><param name="Integer">Incoming message from <c>integer</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(integer) p(integer) factor(double,integer))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="Double">Incoming message from <c>double</c>.</param><param name="Integer">Constant value for <c>integer</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(double) p(double) factor(double,integer) / sum_double p(double) messageTo(double))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="Double">Incoming message from <c>double</c>.</param><param name="Integer">Incoming message from <c>integer</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(double,integer) p(double,integer) factor(double,integer))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Double">Incoming message from <c>double</c>.</param><param name="Integer">Incoming message from <c>integer</c>.</param><param name="to_double">Previous outgoing message to <c>double</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(double,integer) p(double,integer) factor(double,integer) / sum_double p(double) messageTo(double))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.DoubleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>double</c>.</summary><param name="Double">Incoming message from <c>double</c>.</param><param name="Integer">Incoming message from <c>integer</c>.</param><returns>The outgoing EP message to the <c>double</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>double</c> as the random arguments are varied. The formula is <c>proj[p(double) sum_(integer) p(integer) factor(double,integer)]/p(double)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleOp.IntegerAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>integer</c>.</summary><param name="Double">Incoming message from <c>double</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>integer</c> as the random arguments are varied. The formula is <c>proj[p(integer) sum_(double) p(double) factor(double,integer)]/p(integer)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringCapitalizedOfMinMaxLengthOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.StringCapitalized(System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCapitalizedOfMinMaxLengthOp.StrAverageConditional(System.Int32,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="minLength">Constant value for <c>minLength</c>.</param><param name="maxLength">Constant value for <c>maxLength</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringCapitalizedOfMinLengthOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.StringCapitalized(System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCapitalizedOfMinLengthOp.StrAverageConditional(System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="minLength">Constant value for <c>minLength</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringCharConcatOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.String,System.Char)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>EP message to <c>concat</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>The outgoing EP message to the <c>concat</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(str,ch) p(str,ch) factor(concat,str,ch)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>EP message to <c>str</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(concat,ch) p(concat,ch) factor(concat,str,ch)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.ChAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>ch</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>The outgoing EP message to the <c>ch</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ch</c> as the random arguments are varied. The formula is <c>proj[p(ch) sum_(concat,str) p(concat,str) factor(concat,str,ch)]/p(ch)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str">Incoming message from <c>str</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,str,ch) p(concat,str,ch) factor(concat,str,ch))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str">Incoming message from <c>str</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,str,ch) p(concat,str,ch) factor(concat,str,ch) / sum_concat p(concat) messageTo(concat))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringCharConcatOp.LogEvidenceRatio(System.String,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="str">Incoming message from <c>str</c>.</param><param name="ch">Incoming message from <c>ch</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str,ch) p(str,ch) factor(concat,str,ch))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringOfMinLengthOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.String(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfMinLengthOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="minLength">Constant value for <c>minLength</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringOfLengthOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.StringOfLength(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>str</c>.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="length">Incoming message from <c>length</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(length) p(length) factor(str,length,allowedChars)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.LengthAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>length</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>length</c> as the random arguments are varied. The formula is <c>proj[p(length) sum_(str) p(str) factor(str,length,allowedChars)]/p(length)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="length">Incoming message from <c>length</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(length,str) p(length,str) factor(str,length,allowedChars) / sum_str p(str) messageTo(str))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DiscreteChar,System.Int32,System.String)">
            <summary>Evidence message for EP.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="length">Constant value for <c>length</c>.</param><param name="str">Constant value for <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(str,length,allowedChars))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfLengthOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DiscreteChar,MicrosoftResearch.Infer.Distributions.Discrete,System.String)">
            <summary>Evidence message for EP.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="length">Incoming message from <c>length</c>.</param><param name="str">Constant value for <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(length) p(length) factor(str,length,allowedChars))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CountTrueOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.CountTrue(System.Boolean[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialTableInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>Initialize the buffer <c>PoissonBinomialTable</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>Initial value of buffer <c>PoissonBinomialTable</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialTable(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>Update the buffer <c>PoissonBinomialTable</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>New value of buffer <c>PoissonBinomialTable</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.CountAverageConditional(System.Double[0:,0:])">
            <summary>EP message to <c>count</c>.</summary><param name="poissonBinomialTable">Buffer <c>poissonBinomialTable</c>.</param><returns>The outgoing EP message to the <c>count</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>count</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Marginal distribution of count is known as Poisson Binomial.
            It can be found in O(n^2) time using dynamic programming, where n is the length of the array.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.ArrayAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[0:,0:],``0)">
            <summary>EP message to <c>array</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="count">Incoming message from <c>count</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="poissonBinomialTable">Buffer <c>poissonBinomialTable</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(count) p(count) factor(count,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="count"/> is not a proper distribution.</exception>
            <remarks><para>
            Poison Binomial for a given list of Bernoulli random variables with one variable excluded can be computed
            in linear time given Poisson Binomial for the whole list of items computed in a forward pass, as well as a special table
            containing averaged Poisson Binomial, which can be computed in a backward pass.
            Both tables can be computed in O(n^2) time, where n is a size of the list, so the time complexity of this message operator
            is also O(n^2).
            </para></remarks>
            <typeparam name="TBernoulliArray">The type of messages from/to 'array'.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.ArrayAverageConditional``1(``0,System.Int32,System.Double[0:,0:],``0)">
            <summary>EP message to <c>array</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="count">Constant value for <c>count</c>.</param><param name="poissonBinomialTable">Buffer <c>poissonBinomialTable</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TBernoulliArray">The type of messages from/to 'array'.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="count">Incoming message from <c>count</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(count) p(count) factor(count,array) / sum_count p(count) messageTo(count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="count"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(System.Int32,System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="count">Constant value for <c>count</c>.</param><param name="poissonBinomialTable">Buffer <c>poissonBinomialTable</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(count,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(System.Int32,System.Boolean[])">
            <summary>Evidence message for EP.</summary><param name="count">Constant value for <c>count</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(count,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialForwardPass(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Compute Poisson Binomial table for a given list of Bernoulli-distributed random variables in a forward pass.
            </summary>
            <param name="array">List of Bernoulli random variables.</param>
            <returns>Table A, such that A[i, j] = P(sum(<paramref name="array"/>[1], ..., <paramref name="array"/>[i]) = j).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.AveragedPoissonBinomialBackwardPassTableRows(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Enumerate rows of averaged Poisson Binomial table for a given list of Bernoulli-distributed random variables in a backward pass.
            </summary>
            <param name="array">List of Bernoulli random variables.</param>
            <param name="averager">Distribution over sum of values in <paramref name="array"/> used to average the Poisson Binomial.</param>
            <returns>
            <para>
            Rows of table A, such that A[i, j] =
            \sum_c P(<paramref name="averager"/> = c) P(sum(<paramref name="array"/>[i + 1], ..., <paramref name="array"/>[n]) + j = c).
            Rows are returned last-to-first, the very first row is omitted.
            </para>
            </returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CutOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Cut``1(``0)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CutOp`1.ValueAverageConditional``1(``0)">
            <summary>EP message to <c>value</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CutOp`1.CutAverageConditional``1(``0)">
            <summary>EP message to <c>cut</c>.</summary><param name="Value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>cut</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cut</c> as the random arguments are varied. The formula is <c>proj[p(cut) sum_(value) p(value) factor(cut,value)]/p(cut)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CutOp`1.CutAverageConditional(`0)">
            <summary>EP message to <c>cut</c>.</summary><param name="Value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>cut</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cut</c> as the random arguments are varied. The formula is <c>proj[p(cut) sum_(value) p(value) factor(cut,value)]/p(cut)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ExperimentalFactor.GetItemsWithDictionary``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32})"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.MarginalInit``1(``0)">
            <summary>Initialize the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Initial value of buffer <c>marginal</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="ArrayType">The type of an array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.Marginal``2(``0,System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},``0)">
            <summary>Update the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="dict">Constant value for <c>dict</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of an array.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.MarginalIncrement``2(``0,``1,``1,System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32)">
            <summary/><param name="result">Modified to contain the outgoing message.</param><param name="to_item"/><param name="item"/><param name="indices">Constant value for <c>indices</c>.</param><param name="dict">Constant value for <c>dict</c>.</param><param name="resultIndex">Index of the <c>marginal</c> for which a message is desired.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of an array.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.ItemsAverageConditional``2(``1,``0,``0,System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32,``1)">
            <summary>EP message to <c>items</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="dict">Constant value for <c>dict</c>.</param><param name="resultIndex">Index of the <c>items</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices,dict)]/p(items)</c>.</para>
      </remarks>
            <typeparam name="ArrayType">The type of an array.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="dict">Constant value for <c>dict</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices,dict)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an item.</typeparam>
            <typeparam name="ArrayType">The type of an array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="dict">Constant value for <c>dict</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices,dict)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an item.</typeparam>
            <typeparam name="ArrayType">The type of an array.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer">
            <summary>
            Holds messages for IndexOfMaximumOp
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximumDouble(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp.BufferInit``1(``0)">
            <summary>Initialize the buffer <c>Buffer</c>.</summary><param name="list">Incoming message from <c>list</c>.</param><returns>Initial value of buffer <c>Buffer</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp.Buffer``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer,``0,System.Int32)">
            <summary>Update the buffer <c>Buffer</c>.</summary><param name="Buffer">Buffer <c>Buffer</c>.</param><param name="list">Incoming message from <c>list</c>.</param><param name="IndexOfMaximumDouble">Constant value for <c>indexOfMaximumDouble</c>.</param><returns>New value of buffer <c>Buffer</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp.listAverageConditional``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer,``0,System.Int32)">
            <summary>EP message to <c>list</c>.</summary><param name="Buffer">Buffer <c>Buffer</c>.</param><param name="to_list">Previous outgoing message to <c>list</c>.</param><param name="IndexOfMaximumDouble">Constant value for <c>indexOfMaximumDouble</c>.</param><returns>The outgoing EP message to the <c>list</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>list</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp.LogAverageFactor``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer,``0,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="Buffer">Buffer <c>Buffer</c>.</param><param name="list">Incoming message from <c>list</c>.</param><param name="IndexOfMaximumDouble">Constant value for <c>indexOfMaximumDouble</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(list) p(list) factor(indexOfMaximumDouble,list))</c>.</para>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp.LogEvidenceRatio``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer,``0,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="Buffer">Buffer <c>Buffer</c>.</param><param name="list">Incoming message from <c>list</c>.</param><param name="IndexOfMaximumDouble">Constant value for <c>indexOfMaximumDouble</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(list) p(list) factor(indexOfMaximumDouble,list))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximumDouble(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.BuffersInit``1(``0,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Initialize the buffer <c>Buffers</c>.</summary><param name="list">Incoming message from <c>list</c>.</param><param name="IndexOfMaximumDouble">Incoming message from <c>indexOfMaximumDouble</c>.</param><returns>Initial value of buffer <c>Buffers</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.Buffers``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer[],``0,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Update the buffer <c>Buffers</c>.</summary><param name="Buffers">Buffer <c>Buffers</c>.</param><param name="list">Incoming message from <c>list</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="IndexOfMaximumDouble">Incoming message from <c>indexOfMaximumDouble</c>.</param><returns>New value of buffer <c>Buffers</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="list"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.listAverageConditional``1(MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer[],``0,MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>EP message to <c>list</c>.</summary><param name="Buffers">Buffer <c>Buffers</c>.</param><param name="list">Incoming message from <c>list</c>.</param><param name="IndexOfMaximumDouble">Incoming message from <c>indexOfMaximumDouble</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>list</c> as the random arguments are varied. The formula is <c>proj[p(list) sum_(indexOfMaximumDouble) p(indexOfMaximumDouble) factor(indexOfMaximumDouble,list)]/p(list)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="IndexOfMaximumDouble"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.IndexOfMaximumDoubleAverageConditional``1(``0,MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer[])">
            <summary>EP message to <c>indexOfMaximumDouble</c>.</summary><param name="list">Incoming message from <c>list</c>.</param><param name="Buffers">Buffer <c>Buffers</c>.</param><returns>The outgoing EP message to the <c>indexOfMaximumDouble</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>indexOfMaximumDouble</c> as the random arguments are varied. The formula is <c>proj[p(indexOfMaximumDouble) sum_(list) p(list) factor(indexOfMaximumDouble,list)]/p(indexOfMaximumDouble)</c>.</para>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.LogAverageFactor``1(``0,``0,MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="list">Incoming message from <c>list</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_list">Previous outgoing message to <c>list</c>.</param><param name="Buffers">Buffer <c>Buffers</c>.</param><param name="IndexOfMaximumDouble">Incoming message from <c>indexOfMaximumDouble</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(list,indexOfMaximumDouble) p(list,indexOfMaximumDouble) factor(indexOfMaximumDouble,list))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="list"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp.LogEvidenceRatio``1(``0,``0,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Factors.IndexOfMaximumBuffer[])">
            <summary>Evidence message for EP.</summary><param name="list">Incoming message from <c>list</c>.</param><param name="to_list">Previous outgoing message to <c>list</c>.</param><param name="IndexOfMaximumDouble">Incoming message from <c>indexOfMaximumDouble</c>.</param><param name="to_IndexOfMaximumDouble">Previous outgoing message to <c>IndexOfMaximumDouble</c>.</param><param name="Buffers">Buffer <c>Buffers</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(list,indexOfMaximumDouble) p(list,indexOfMaximumDouble) factor(indexOfMaximumDouble,list) / sum_indexOfMaximumDouble p(indexOfMaximumDouble) messageTo(indexOfMaximumDouble))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of an incoming message from <c>list</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp_Fast">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximumDouble(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp_Fast.IndexOfMaximumDoubleAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>indexOfMaximumDouble</c>.</summary><param name="list">Incoming message from <c>list</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>indexOfMaximumDouble</c> as the random arguments are varied. The formula is <c>proj[p(indexOfMaximumDouble) sum_(list) p(list) factor(indexOfMaximumDouble,list)]/p(indexOfMaximumDouble)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="list"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp_Fast.IndexOfMaximumDoubleAverageConditional2(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>indexOfMaximumDouble</c>.</summary><param name="list">Incoming message from <c>list</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>indexOfMaximumDouble</c> as the random arguments are varied. The formula is <c>proj[p(indexOfMaximumDouble) sum_(list) p(list) factor(indexOfMaximumDouble,list)]/p(indexOfMaximumDouble)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="list"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp_Fast.ProbGreater(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Returns the probability that A>B
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.JaggedSubarray``1(System.Collections.Generic.IList{``0},System.Int32[][])"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.AverageLogFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.AverageLogFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array,items,indices) p(array,items,indices) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array,items,indices) p(array,items,indices) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.AverageLogFactor``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for VMP.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.AverageLogFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``3(``1,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},``1)">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="to_items">Previous outgoing message to <c>items</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array,indices) p(items,array,indices) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemArrayType">The type of an incoming message from <c>items</c>.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.MarginalInit``1(``0)">
            <summary>Initialize the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Initial value of buffer <c>marginal</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="ArrayType">The type of a message from <c>array</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.Marginal``4(``0,System.Collections.Generic.IList{``3},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},``0)">
            <summary>Update the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of a message from <c>array</c>.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemArrayType">The type of an incoming message from <c>items</c>.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.MarginalIncrement``3(``0,``2,``2,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Int32)">
            <summary/><param name="result">Modified to contain the outgoing message.</param><param name="to_item"/><param name="item"/><param name="indices">Incoming message from <c>indices</c>.</param><param name="resultIndex">Index of the <c>marginal</c> for which a message is desired.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ItemsAverageConditional``3(``2,``0,``0,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Int32,``2)">
            <summary>EP message to <c>items</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="resultIndex">Index of the <c>items</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[p(items) sum_(array,indices) p(array,indices) factor(items,array,indices)]/p(items)</c>.</para>
      </remarks>
            <typeparam name="ArrayType">The type of a message from <c>array</c>.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageConditional``3(System.Collections.Generic.IList{``2},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items,indices) p(items,indices) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageConditional``3(System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{``2},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="indices">Incoming message from <c>indices</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(indices,items) p(indices,items) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ItemsAverageLogarithm``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},``2)">
            <summary>VMP message to <c>items</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[sum_(array,indices) p(array,indices) factor(items,array,indices)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
            <typeparam name="ResultType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageLogarithm``3(System.Collections.Generic.IList{``2},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Incoming message from <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>array</c>. Because the factor is deterministic, <c>items</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(indices) p(indices) log(sum_items p(items) factor(items,array,indices)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageLogarithm``3(System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{``2},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="indices">Incoming message from <c>indices</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>array</c>. Because the factor is deterministic, <c>items</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(indices) p(indices) log(sum_items p(items) factor(items,array,indices)))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
            <typeparam name="ItemType">The type of a sub-array.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PlusGammaVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PlusGammaVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PlusGammaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PlusGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerOp">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Pow(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerOp.PowAverageConditional(MicrosoftResearch.Infer.Distributions.Pareto,System.Double)">
            <summary>EP message to <c>pow</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="y">Constant value for <c>y</c>.</param><returns>The outgoing EP message to the <c>pow</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>pow</c> as the random arguments are varied. The formula is <c>proj[p(pow) sum_(x) p(x) factor(pow,x,y)]/p(pow)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Pareto,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="pow">Incoming message from <c>pow</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="y">Constant value for <c>y</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(pow) p(pow) factor(pow,x,y)]/p(x)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductWishartOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageConditional(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for VMP.</summary><param name="product">Incoming message from <c>product</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.RotateOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Rotate(System.Double,System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="rotate">Incoming message from <c>rotate</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="angle">Incoming message from <c>angle</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>x</c>. Because the factor is deterministic, <c>rotate</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(angle) p(angle) log(sum_rotate p(rotate) factor(rotate,x,y,angle)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="angle"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.YAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>y</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="angle">Incoming message from <c>angle</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>y</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>y</c>. Because the factor is deterministic, <c>rotate</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(angle) p(angle) log(sum_rotate p(rotate) factor(rotate,x,y,angle)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="angle"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>VMP message to <c>x</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="angle">Constant value for <c>angle</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>rotate</c> integrated out. The formula is <c>sum_rotate p(rotate) factor(rotate,x,y,angle)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.YAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>VMP message to <c>y</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="angle">Constant value for <c>angle</c>.</param><returns>The outgoing VMP message to the <c>y</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>y</c> with <c>rotate</c> integrated out. The formula is <c>sum_rotate p(rotate) factor(rotate,x,y,angle)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.RotateAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.RotateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>rotate</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="y">Incoming message from <c>y</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="angle">Incoming message from <c>angle</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rotate</c> as the random arguments are varied. The formula is <c>proj[sum_(x,y,angle) p(x,y,angle) factor(rotate,x,y,angle)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="y"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="angle"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.RotateAverageLogarithm(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>rotate</c>.</summary><param name="x">Constant value for <c>x</c>.</param><param name="y">Constant value for <c>y</c>.</param><param name="angle">Incoming message from <c>angle</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rotate</c> as the random arguments are varied. The formula is <c>proj[sum_(angle) p(angle) factor(rotate,x,y,angle)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="angle"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.RotateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>rotate</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="y">Incoming message from <c>y</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="angle">Constant value for <c>angle</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rotate</c> as the random arguments are varied. The formula is <c>proj[sum_(x,y) p(x,y) factor(rotate,x,y,angle)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="y"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.AngleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>angle</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="y">Incoming message from <c>y</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>angle</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>angle</c>. Because the factor is deterministic, <c>rotate</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(x,y) p(x,y) log(sum_rotate p(rotate) factor(rotate,x,y,angle)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="y"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RotateOp.AngleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double,System.Double)">
            <summary>VMP message to <c>angle</c>.</summary><param name="rotate">Incoming message from <c>rotate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Constant value for <c>x</c>.</param><param name="y">Constant value for <c>y</c>.</param><returns>The outgoing VMP message to the <c>angle</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>angle</c> with <c>rotate</c> integrated out. The formula is <c>sum_rotate p(rotate) factor(rotate,x,y,angle)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rotate"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SingleOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Single(System.String)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SingleOp.CharacterAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>character</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><returns>The outgoing EP message to the <c>character</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>character</c> as the random arguments are varied. The formula is <c>proj[p(character) sum_(str) p(str) factor(character,str)]/p(character)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SingleOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>EP message to <c>str</c>.</summary><param name="character">Incoming message from <c>character</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(character) p(character) factor(character,str)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseGaussianListOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary/><param name="mean">Constant value for <c>means</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary/><param name="mean">Incoming message from <c>means</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>means</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>means</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>EP message to <c>precs</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precs</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(means) p(means) factor(sample,means,precs)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>means</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>means</c> as the random arguments are varied. The formula is <c>proj[p(means) sum_(sample) p(sample) factor(sample,means,precs)]/p(means)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(means,precs) p(means,precs) factor(sample,means,precs)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(precs) p(precs) factor(sample,means,precs)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>means</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>means</c> as the random arguments are varied. The formula is <c>proj[p(means) sum_(sample,precs) p(sample,precs) factor(sample,means,precs)]/p(means)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>EP message to <c>means</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>means</c> as the random arguments are varied. The formula is <c>proj[p(means) sum_(precs) p(precs) factor(sample,means,precs)]/p(means)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>EP message to <c>precs</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precs</c> as the random arguments are varied. The formula is <c>proj[p(precs) sum_(means) p(means) factor(sample,means,precs)]/p(precs)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>EP message to <c>precs</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precs</c> as the random arguments are varied. The formula is <c>proj[p(precs) sum_(sample) p(sample) factor(sample,means,precs)]/p(precs)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>EP message to <c>precs</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precs</c> as the random arguments are varied. The formula is <c>proj[p(precs) sum_(sample,means) p(sample,means) factor(sample,means,precs)]/p(precs)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,means,precs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,means) p(sample,means) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(means) p(means) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(precs) p(precs) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(means,precs) p(means,precs) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,precs) p(sample,precs) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,means,precs) p(sample,means,precs) factor(sample,means,precs))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,means) p(sample,means) factor(sample,means,precs) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,means,precs) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(means) p(means) factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(precs) p(precs) factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(means,precs) p(means,precs) factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,means,precs) p(sample,means,precs) factor(sample,means,precs) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,precs) p(sample,precs) factor(sample,means,precs) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary/><param name="mean">Constant value for <c>means</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary/><param name="mean">Incoming message from <c>means</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(means) p(means) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>means</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>means</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>means</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>means</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(means,precs) p(means,precs) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>means</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>means</c>. The formula is <c>exp(sum_(sample,precs) p(sample,precs) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(precs) p(precs) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>VMP message to <c>means</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>means</c>. The formula is <c>exp(sum_(precs) p(precs) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>VMP message to <c>precs</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precs</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>VMP message to <c>precs</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precs</c>. The formula is <c>exp(sum_(sample,means) p(sample,means) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>VMP message to <c>precs</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precs</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>VMP message to <c>precs</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precs</c>. The formula is <c>exp(sum_(means) p(means) log(factor(sample,means,precs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,means,precs) p(sample,means,precs) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(precs) p(precs) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(means) p(means) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(means,precs) p(means,precs) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>means</c>.</param><param name="precision">Incoming message from <c>precs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,precs) p(sample,precs) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>means</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,means) p(sample,means) log(factor(sample,means,precs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringConcatOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.String,System.String)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>concat</c>.</summary><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>The outgoing EP message to the <c>concat</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>concat</c> as the random arguments are varied. The formula is <c>proj[p(concat) sum_(str1,str2) p(str1,str2) factor(concat,str1,str2)]/p(concat)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.Str1AverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>str1</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>The outgoing EP message to the <c>str1</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str1</c> as the random arguments are varied. The formula is <c>proj[p(str1) sum_(concat,str2) p(concat,str2) factor(concat,str1,str2)]/p(str1)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.Str2AverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>str2</c>.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><returns>The outgoing EP message to the <c>str2</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str2</c> as the random arguments are varied. The formula is <c>proj[p(str2) sum_(concat,str1) p(concat,str1) factor(concat,str1,str2)]/p(str2)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,str1,str2) p(concat,str1,str2) factor(concat,str1,str2))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Incoming message from <c>concat</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(concat,str1,str2) p(concat,str1,str2) factor(concat,str1,str2) / sum_concat p(concat) messageTo(concat))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringConcatOp.LogEvidenceRatio(System.String,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="concat">Constant value for <c>concat</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str1,str2) p(str1,str2) factor(concat,str1,str2))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringFormatOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.StringFormat(System.String,System.String[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.StringFormatOp.LeftBraceReplacer">
            <summary>
            Used as a temporary replacement for '{' when computing messages. It is a unicode non-character.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.StringFormatOp.RightBraceReplacer">
            <summary>
            Used as a temporary replacement for '}' when computing messages. It is a unicode non-character.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.StringFormatOp.ArgumentCountToEscapingTransducers">
            <summary>
            For every possible number of arguments, stores transducers for escaping argument placeholders
            during message computation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.StringFormatOp.DisallowBraceReplacersTransducer">
            <summary>
            A transducer used to assert that string cannot have
            <see cref="F:MicrosoftResearch.Infer.Factors.StringFormatOp.LeftBraceReplacer"/> or <see cref="F:MicrosoftResearch.Infer.Factors.StringFormatOp.RightBraceReplacer"/> inside it.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MicrosoftResearch.Infer.Factors.StringFormatOp"/> class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{System.String})">
            <summary>EP message to <c>str</c>.</summary><param name="format">Incoming message from <c>format</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(format,args) p(format,args) factor(str,format,args)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.StringDistribution})">
            <summary>EP message to <c>str</c>.</summary><param name="format">Incoming message from <c>format</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(format,args) p(format,args) factor(str,format,args)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.FormatAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{System.String})">
            <summary>EP message to <c>format</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>The outgoing EP message to the <c>format</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>format</c> as the random arguments are varied. The formula is <c>proj[p(format) sum_(str,args) p(str,args) factor(str,format,args)]/p(format)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.FormatAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.StringDistribution})">
            <summary>EP message to <c>format</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>The outgoing EP message to the <c>format</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>format</c> as the random arguments are varied. The formula is <c>proj[p(format) sum_(str,args) p(str,args) factor(str,format,args)]/p(format)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.ArgsAverageConditional``1(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.StringDistribution},``0)">
            <summary>EP message to <c>args</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="format">Incoming message from <c>format</c>.</param><param name="args">Incoming message from <c>args</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>args</c> as the random arguments are varied. The formula is <c>proj[p(args) sum_(str,format) p(str,format) factor(str,format,args)]/p(args)</c>.</para>
      </remarks>
            <typeparam name="TStringDistributionList">The type of an outgoing message to <c>args</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str) p(str) factor(str,format,args) / sum_str p(str) messageTo(str))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.LogEvidenceRatio(System.String,MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.StringDistribution})">
            <summary>Evidence message for EP.</summary><param name="str">Constant value for <c>str</c>.</param><param name="format">Incoming message from <c>format</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(format,args) p(format,args) factor(str,format,args))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.LogEvidenceRatio(System.String,MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{System.String})">
            <summary>Evidence message for EP.</summary><param name="str">Constant value for <c>str</c>.</param><param name="format">Incoming message from <c>format</c>.</param><param name="args">Incoming message from <c>args</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(format,args) p(format,args) factor(str,format,args))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.AllDigitsExcept(System.Int32,System.Int32)">
            <summary>
            Creates a uniform distribution over all digits from 0 to <paramref name="maxDigit"/> (inclusive),
            excluding <paramref name="digit"/>.
            </summary>
            <param name="digit">The digit to exclude.</param>
            <param name="maxDigit">The maximum digit.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.GetPlaceholderReplacingTransducer(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Automata.StringAutomaton},System.Boolean)">
            <summary>
            Creates a transducer that replaces escaped argument placeholders with the corresponding arguments.
            </summary>
            <param name="escapedArgs">The list of arguments.</param>
            <param name="transpose">Specifies whether the created transducer should be transposed (useful for backward message computation).</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.GetArgumentEscapingTransducer(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a transducer that replaces braces surrounding the given argument placeholder
            with <see cref="F:MicrosoftResearch.Infer.Factors.StringFormatOp.LeftBraceReplacer"/> and <see cref="F:MicrosoftResearch.Infer.Factors.StringFormatOp.RightBraceReplacer"/>.
            </summary>
            <param name="argument">The index of the argument.</param>
            <param name="argumentCount">The total number of the arguments.</param>
            <param name="transpose">Specifies whether the created transducer should be transposed (useful for backward message computation).</param>
            <returns>The created transducer.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFormatOp.ToAutomatonArray(System.Collections.Generic.IList{System.String})">
            <summary>
            Converts a list of string to an array of point mass automata.
            </summary>
            <param name="strings">The list of strings.</param>
            <returns>The created automata array.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringFromArrayOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.StringFromArray(System.Char[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFromArrayOp.StrAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.DiscreteChar})">
            <summary>EP message to <c>str</c>.</summary><param name="characters">Incoming message from <c>characters</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(characters) p(characters) factor(str,characters)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFromArrayOp.CharactersAverageConditional``1(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.DiscreteChar},``0)">
            <summary>EP message to <c>characters</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="characters">Incoming message from <c>characters</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>characters</c> as the random arguments are varied. The formula is <c>proj[p(characters) sum_(str) p(str) factor(str,characters)]/p(characters)</c>.</para>
      </remarks>
            <typeparam name="TDiscreteCharList">The type of an outgoing message to <c>chars</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFromArrayOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.DiscreteChar},MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="characters">Incoming message from <c>characters</c>.</param><param name="str">Incoming message from <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(characters,str) p(characters,str) factor(str,characters) / sum_str p(str) messageTo(str))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFromArrayOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.DiscreteChar},System.String)">
            <summary>Evidence message for EP.</summary><param name="characters">Incoming message from <c>characters</c>.</param><param name="str">Constant value for <c>str</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(characters) p(characters) factor(str,characters))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringFromArrayOp.GetCharWeighter(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.DiscreteChar},System.Int32)">
            <summary>
            Creates a string distribution <c>P(s) = \prod_i P_i(s_i)^I[i != j]</c>,
            where <c>P_i(c)</c> is a given array of character distributions and <c>j</c> is a given position in the array.
            </summary>
            <param name="characters">The distributions over individual characters.</param>
            <param name="excludedPos">The character to skip.</param>
            <returns>The created distribution.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringOfMinMaxLengthOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.String(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringOfMinMaxLengthOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteChar,System.Int32,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="allowedChars">Constant value for <c>allowedChars</c>.</param><param name="minLength">Constant value for <c>minLength</c>.</param><param name="maxLength">Constant value for <c>maxLength</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.StringsAreEqualOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.String,System.String)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(str1,str2) p(str1,str2) factor(areEqual,str1,str2)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.Str1AverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>str1</c>.</summary><param name="str2">Incoming message from <c>str2</c>.</param><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str1</c> as the random arguments are varied. The formula is <c>proj[p(str1) sum_(str2,areEqual) p(str2,areEqual) factor(areEqual,str1,str2)]/p(str1)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.Str2AverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>EP message to <c>str2</c>.</summary><param name="str1">Incoming message from <c>str1</c>.</param><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str2</c> as the random arguments are varied. The formula is <c>proj[p(str2) sum_(str1,areEqual) p(str1,areEqual) factor(areEqual,str1,str2)]/p(str2)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,str1,str2) / sum_areEqual p(areEqual) messageTo(areEqual))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str1,str2) p(str1,str2) factor(areEqual,str1,str2))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.StringsAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="str1">Incoming message from <c>str1</c>.</param><param name="str2">Incoming message from <c>str2</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str1,str2) p(str1,str2) factor(areEqual,str1,str2))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubstringOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Substring(System.String,System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.SubAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Int32,System.Int32)">
            <summary>EP message to <c>sub</c>.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>The outgoing EP message to the <c>sub</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sub</c> as the random arguments are varied. The formula is <c>proj[p(sub) sum_(str) p(str) factor(sub,str,start,length)]/p(sub)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.SubAverageConditional(System.String,System.Int32,System.Int32)">
            <summary>EP message to <c>sub</c>.</summary><param name="str">Constant value for <c>str</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>The outgoing EP message to the <c>sub</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sub</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.StrAverageConditional(System.String,System.Int32,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="sub">Constant value for <c>sub</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>str</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.StrAverageConditional(MicrosoftResearch.Infer.Distributions.StringDistribution,System.Int32,System.Int32)">
            <summary>EP message to <c>str</c>.</summary><param name="sub">Incoming message from <c>sub</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>The outgoing EP message to the <c>str</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>str</c> as the random arguments are varied. The formula is <c>proj[p(str) sum_(sub) p(sub) factor(sub,str,start,length)]/p(str)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="sub">Incoming message from <c>sub</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str,sub) p(str,sub) factor(sub,str,start,length))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution,MicrosoftResearch.Infer.Distributions.StringDistribution,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="sub">Incoming message from <c>sub</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str,sub) p(str,sub) factor(sub,str,start,length) / sum_sub p(sub) messageTo(sub))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubstringOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.StringDistribution,System.String,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="str">Incoming message from <c>str</c>.</param><param name="sub">Constant value for <c>sub</c>.</param><param name="start">Constant value for <c>start</c>.</param><param name="length">Constant value for <c>length</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(str) p(str) factor(sub,str,start,length))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.SumAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>sum</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sum</c> as the random arguments are varied. The formula is <c>proj[p(sum) sum_(array) p(array) factor(sum,array)]/p(sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian[],MicrosoftResearch.Infer.Distributions.VectorGaussian[])">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TVectorGaussianList">A list of <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> distributions which may be set to uniform.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>sum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array) / sum_sum p(sum) messageTo(sum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.SumAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>sum</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sum</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(sum,array)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_array">Previous outgoing message to <c>array</c>.</param><returns>The outgoing VMP message to the <c>array</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>sum</c> integrated out. The formula is <c>sum_sum p(sum) factor(sum,array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="TVectorGaussianList">A list of <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> distributions.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageLogarithm1``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},``0)">
            <summary/><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_array">Previous outgoing message to <c>array</c>.</param><returns/><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="TVectorGaussianList">A list of <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> distributions.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.VectorGaussian},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="TVectorGaussianList">A list of <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> distributions.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.IsUniform(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Tests whether all elements on the diagonal of variance are infinite.
            </summary>
            <param name="variance">The variance, a <see cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix"/>.</param>
            <returns>True, if all elements on the diagonal of <paramref name="variance"/> are infinite.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumVectorGaussianOp.CheckArgumentConsistency(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Distributions.VectorGaussian},System.Collections.Generic.ICollection{MicrosoftResearch.Infer.Distributions.VectorGaussian})">
            <summary>
            Checks arguments for consistency and returns the dimension of the arguments' distributions.
            </summary>
            <param name="sum">Incoming message from 'sum'.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Contains the outgoing message.</param>
            <returns>The dimension of the distributions.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when sum, array, or any element of array is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown for inconsistent arguments.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumWhereOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.SumWhere(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogEvidenceRatio(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AverageLogFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageConditional(System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>Sum</c>.</summary><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.CovarianceOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Update the buffer <c>CovarianceOfB</c>.</summary><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>New value of buffer <c>CovarianceOfB</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.MeanOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>MeanOfB</c>.</summary><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>New value of buffer <c>MeanOfB</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A) p(A) factor(Sum,A,B)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(B) p(B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sum</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean})">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean})">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. The formula is <c>exp(sum_(B) p(B) log(factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(System.Double,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageConditional(System.Double,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.InnerProductPartialCovariance(System.Double[],MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(X,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.EbbtInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="B">Incoming message from <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.Ebbt(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary/><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.EaatInit(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary/><param name="A">Incoming message from <c>A</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.Eaat(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary/><param name="A">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.CovarianceOfBInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>CovarianceOfB</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><returns>Initial value of buffer <c>CovarianceOfB</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.CovarianceOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>CovarianceOfB</c>.</summary><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.MeanOfBInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>MeanOfB</c>.</summary><param name="B">Incoming message from <c>B</c>.</param><returns>Initial value of buffer <c>MeanOfB</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.MeanOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>MeanOfB</c>.</summary><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>A</c>.</summary><param name="X">Incoming message from <c>X</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>X</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_X p(X) factor(X,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="X"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="X">Incoming message from <c>X</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>X</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_X p(X) factor(X,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="X"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>X</c>.</summary><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="MeanOfB">Buffer <c>MeanOfB</c>.</param><param name="CovarianceOfB">Buffer <c>CovarianceOfB</c>.</param><returns>The outgoing VMP message to the <c>X</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>X</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(X,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.XAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CopyOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogAverageFactor(`0,`0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogAverageFactor``1(``0,`0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value))</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value))</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogAverageFactor``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value))</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio(`0,`0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value) / sum_copy p(copy) messageTo(copy))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio``1(``0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy) p(copy) factor(copy,value) / sum_copy p(copy) messageTo(copy))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(copy,value) p(copy,value) factor(copy,value) / sum_copy p(copy) messageTo(copy))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional``1(``0)">
            <summary>EP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>The outgoing EP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional(`0)">
            <summary>EP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>The outgoing EP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional``1(`0,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageConditional``1(``0)">
            <summary>EP message to <c>copy</c>.</summary><param name="Value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[p(copy) sum_(value) p(value) factor(copy,value)]/p(copy)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageConditional(`0)">
            <summary>EP message to <c>copy</c>.</summary><param name="Value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[p(copy) sum_(value) p(value) factor(copy,value)]/p(copy)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(``0,``0)">
            <summary>Evidence message for VMP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="Value">Incoming message from <c>value</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(``0,`0)">
            <summary>Evidence message for VMP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="Value">Incoming message from <c>value</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(`0,``0)">
            <summary>Evidence message for VMP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="Value">Incoming message from <c>value</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor(`0,`0)">
            <summary>Evidence message for VMP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="Value">Incoming message from <c>value</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm``1(``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>copy</c> integrated out. The formula is <c>sum_copy p(copy) factor(copy,value)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm``1(`0,``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>copy</c> integrated out. The formula is <c>sum_copy p(copy) factor(copy,value)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm``1(``0)">
            <summary>VMP message to <c>copy</c>.</summary><param name="Value">Incoming message from <c>value</c>.</param><returns>The outgoing VMP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>copy</c> integrated out. The formula is <c>sum_copy p(copy) factor(copy,value)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>VMP message to <c>copy</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>The outgoing VMP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_value">Previous outgoing message to <c>value</c>.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>copy</c> integrated out. The formula is <c>sum_copy p(copy) factor(copy,value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="to_value">Previous outgoing message to <c>value</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <remarks>
            <para>
            This factor is implicitly maintaining the truncated Gaussian variational posterior. Therefore
            we need to remove the entropy of the Gaussian representation, and add the entropy for the
            truncated Gaussian
            </para>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>copy</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_value">Previous outgoing message to <c>value</c>.</param><returns>The outgoing VMP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>value</c>.</summary><param name="copy">Incoming message from <c>copy</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="to_value">Previous outgoing message to <c>value</c>.</param><returns>The outgoing VMP message to the <c>value</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>copy</c> integrated out. The formula is <c>sum_copy p(copy) factor(copy,value)</c>.</para>
      </remarks>
            <remarks><para>
            We reverse the direction of factor to get the behaviour we want here.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>copy</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="copy">Incoming message from <c>copy</c>.</param><param name="to_value">Previous outgoing message to <c>value</c>.</param><returns>The outgoing VMP message to the <c>copy</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>copy</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.</para>
      </remarks>
            <remarks><para>
            This message should include the previous contribution.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MaxProductCopyOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxProductCopyOp`1.ValueMaxConditional``1(``0,``0)">
            <summary/><param name="copy">Incoming message from <c>copy</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxProductCopyOp`1.CopyMaxConditional``1(``0)">
            <summary/><param name="Value">Incoming message from <c>value</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable being copied.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SampleFromPseudoCounts(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) factor(sampleFromPseudoCounts,pseudoCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) factor(sampleFromPseudoCounts,pseudoCount) / sum_sampleFromPseudoCounts p(sampleFromPseudoCounts) messageTo(sampleFromPseudoCounts))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) log(factor(sampleFromPseudoCounts,pseudoCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sampleFromPseudoCounts</c>.</param><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>sampleFromPseudoCounts</c>.</summary><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>The outgoing EP message to the <c>sampleFromPseudoCounts</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sampleFromPseudoCounts</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>sampleFromPseudoCounts</c>.</summary><param name="pseudoCounts">Constant value for <c>pseudoCount</c>.</param><returns>The outgoing VMP message to the <c>sampleFromPseudoCounts</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sampleFromPseudoCounts</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DirichletSymmetric(System.Int32,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probMeanLog">Buffer <c>probMeanLog</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob,alpha) p(prob,alpha) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(alpha) p(alpha) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(alpha) p(alpha) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Incoming message from <c>alpha</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob,alpha) p(prob,alpha) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Constant value for <c>alpha</c>.</param><param name="probMeanLog">Buffer <c>probMeanLog</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob) p(prob) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.GradientAndValueAtPoint(System.Double,System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the gradient and value of the KL divergence for this factor
            </summary>
            <param name="a2">Prior shape</param>
            <param name="b2">Prior rate</param>
            <param name="x">A vector of the variational posterior parameters. x[1]=log(shape), x[2]=log(rate)</param>
            <param name="SumElogP">Sum E[ log(prob_k) ]. Cached for efficiency</param>
            <param name="grad">Vector to fill with the gradient</param>
            <param name="K">Dimensionality</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLogInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Initialize the buffer <c>probMeanLog</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><returns>Initial value of buffer <c>probMeanLog</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLogInit(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Initialize the buffer <c>probMeanLog</c>.</summary><param name="prob">Incoming message from <c>prob</c>.</param><returns>Initial value of buffer <c>probMeanLog</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLog(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>probMeanLog</c>.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLog(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>probMeanLog</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>alpha</c>.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probMeanLog">Buffer <c>probMeanLog</c>.</param><param name="to_Alpha">Previous outgoing message to <c>Alpha</c>.</param><returns>The outgoing VMP message to the <c>alpha</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>alpha</c>. The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,K,alpha)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>alpha</c>.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probMeanLog">Buffer <c>probMeanLog</c>.</param><returns>The outgoing VMP message to the <c>alpha</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>alpha</c>. The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,K,alpha)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>alpha</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="alpha">Incoming message from <c>alpha</c>.</param><param name="probMeanLog">Buffer <c>probMeanLog</c>.</param><returns>The outgoing VMP message to the <c>alpha</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>alpha</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>alpha</c>.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_Alpha">Previous outgoing message to <c>Alpha</c>.</param><returns>The outgoing VMP message to the <c>alpha</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>alpha</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>prob</c>.</summary><param name="alpha">Constant value for <c>alpha</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>prob</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithmInit(System.Int32)">
            <summary/><param name="K">Constant value for <c>K</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>prob</c>.</summary><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>prob</c>. The formula is <c>exp(sum_(alpha) p(alpha) log(factor(prob,K,alpha)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>prob</c>.</summary><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>prob</c>. The formula is <c>exp(sum_(alpha) p(alpha) log(factor(prob,K,alpha)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob,alpha) p(prob,alpha) factor(prob,K,alpha))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="alpha">Constant value for <c>alpha</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,K,alpha))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="alpha">Constant value for <c>alpha</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,K,alpha) / sum_prob p(prob) messageTo(prob))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="alpha">Constant value for <c>alpha</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob) p(prob) log(factor(prob,K,alpha))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="alpha">Constant value for <c>alpha</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,K,alpha))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="alpha">Constant value for <c>alpha</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,K,alpha) / sum_prob p(prob) messageTo(prob))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>prob</c>.</summary><param name="alpha">Constant value for <c>alpha</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>prob</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageConditionalInit(System.Int32)">
            <summary/><param name="K">Constant value for <c>K</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>alpha</c>.</summary><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>alpha</c> as the random arguments are varied. The formula is <c>proj[p(alpha) sum_(prob) p(prob) factor(prob,K,alpha)]/p(alpha)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>prob</c>.</summary><param name="alpha">Incoming message from <c>alpha</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(alpha) p(alpha) factor(prob,K,alpha)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="alpha"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.DirichletOp.damping">
            <summary>
            How much damping to use to prevent improper messages. Higher values result in more damping. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob,mean,totalCount) p(prob,mean,totalCount) log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(prob,totalCount) p(prob,totalCount) log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean,totalCount) p(mean,totalCount) log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_mean">Previous outgoing message to <c>mean</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(totalCount,prob) p(totalCount,prob) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.CalculateGradientForMean(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Helper function to calculate gradient of the KL divergence with respect to the mean of the Dirichlet. 
            </summary>
            <param name="meanPseudoCount">Pseudocount vector of the incoming message from 'mean'</param>
            <param name="totalCount">Incoming message from 'totalCount'</param>
            <param name="meanLogProb">E[log(prob)]</param>
            <returns>Gradient of the KL divergence with respect to the mean of the Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>totalCount</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_totalCount">Previous outgoing message to <c>totalCount</c>.</param><returns>The outgoing VMP message to the <c>totalCount</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>totalCount</c>. The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_totalCount">Previous outgoing message to <c>totalCount</c>.</param><returns>The outgoing VMP message to the <c>totalCount</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>totalCount</c>. The formula is <c>exp(sum_(mean,prob) p(mean,prob) log(factor(prob,mean,totalCount)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithmHelper(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'totalCount'. This functionality is separated out to allow use by BetaOp. 
            </summary>
            <param name="meanPseudoCount">Pseudocount of incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="meanLogProb">E[log(prob)] from incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'mean'
            </summary>
            <param name="meanQPseudoCount">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogMLogGamma">Array to be filled with E[Log(m_k)*LogGamma(s*m_k)].</param>
            <param name="EELogOneMinusMLogGamma">Array to be filled with E[Log(1-m_k)*LogGamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is performed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'totalCount'
            </summary>
            <param name="meanQPseudoCount">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogSLogGamma">Array to be filled with E[Log(s)*LogGamma(s*m_k)].</param>
            <param name="EEMSDigamma">Array to be filled with E[s*m_k*Digamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is peformed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.EvidenceMessageExpectations(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Perform the quadrature required for the VMP evidence message
            </summary>
            <param name="meanQ">Incoming message from m='mean'.</param>
            <param name="totalCountQ">Incoming message from s='totalCount'.</param>
            <returns>Vector of E[ LogGamma(s*m_k)].</returns>
            <remarks><para>
            The quadrature over 'totalCount' (which is Gamma-distributed) is 
            peformed by a change of variable x=log(s) followed by Gauss-Hermite 
            quadrature. The quadrature over m is performed using Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(prob,mean,totalCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(prob,mean,totalCount))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="to_prob">Previous outgoing message to <c>prob</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,mean,totalCount))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob,mean,totalCount) p(prob,mean,totalCount) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob,totalCount) p(prob,totalCount) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(totalCount) p(totalCount) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(prob,mean) p(prob,mean) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for EP.</summary><param name="prob">Constant value for <c>prob</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(prob,mean,totalCount))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>prob</c> as the random arguments are varied. The formula is <c>proj[p(prob) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>EP message to <c>prob</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><returns>The outgoing EP message to the <c>prob</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>prob</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Constant value for <c>totalCount</c>.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>mean</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(totalCount,prob) p(totalCount,prob) factor(prob,mean,totalCount)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>totalCount</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>totalCount</c> as the random arguments are varied. The formula is <c>proj[p(totalCount) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Constant value for <c>prob</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>totalCount</c> as the random arguments are varied. The formula is <c>proj[p(totalCount) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(totalCount)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>totalCount</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="totalCount">Incoming message from <c>totalCount</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="prob">Incoming message from <c>prob</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>totalCount</c> as the random arguments are varied. The formula is <c>proj[p(totalCount) sum_(mean,prob) p(mean,prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="totalCount"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="prob"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(MicrosoftResearch.Infer.Maths.Vector)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample,Probs) p(Sample,Probs) factor(Sample,Probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample,Probs) p(Sample,Probs) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample,Probs) p(Sample,Probs) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Gibbs message to <c>Sample</c>.</summary><param name="probs">Constant value for <c>Probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Sample</c>.</summary><param name="probs">Constant value for <c>Probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>Sample</c>.</summary><param name="probs">Constant value for <c>Probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary/><param name="probs">Incoming message from <c>Probs</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary/><param name="probs">Incoming message from <c>Probs</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="probs">Constant value for <c>Probs</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="probs">Constant value for <c>Probs</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Gibbs message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Probs</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Probs</c> as the random arguments are varied. The formula is <c>proj[p(Probs) sum_(Sample) p(Sample) factor(Sample,Probs)]/p(Probs)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Probs</c>. The formula is <c>exp(sum_(Sample) p(Sample) log(factor(Sample,Probs)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Sample</c>.</summary><param name="probs">Incoming message from <c>Probs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sample</c> as the random arguments are varied. The formula is <c>proj[p(Sample) sum_(Probs) p(Probs) factor(Sample,Probs)]/p(Sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probs"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>Sample</c>.</summary><param name="probs">Incoming message from <c>Probs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Sample</c>. The formula is <c>exp(sum_(Probs) p(Probs) log(factor(Sample,Probs)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probs"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Probs</c>. The formula is <c>exp(sum_(Sample) p(Sample) log(factor(Sample,Probs)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probs">Constant value for <c>Probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Probs</c> as the random arguments are varied. The formula is <c>proj[p(Probs) sum_(Sample) p(Sample) factor(Sample,Probs)]/p(Probs)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="probs">Incoming message from <c>Probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Probs</c> as the random arguments are varied. The formula is <c>proj[p(Probs) sum_(Sample) p(Sample) factor(Sample,Probs)]/p(Probs)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample,Probs) p(Sample,Probs) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probs"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample) p(Sample) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample,Probs) p(Sample,Probs) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probs"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample) p(Sample) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="probs">Constant value for <c>probs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,selector) p(sample,selector) factor(sample,selector,probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="probs">Constant value for <c>probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,selector) p(sample,selector) factor(sample,selector,probs) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="selector">Incoming message from <c>selector</c>.</param><param name="probs">Constant value for <c>probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(selector) p(selector) factor(sample,selector,probs)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>selector</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probs">Constant value for <c>probs</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>selector</c> as the random arguments are varied. The formula is <c>proj[p(selector) sum_(sample) p(sample) factor(sample,selector,probs)]/p(selector)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteUniform">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteUniform(System.Int32)"/>, given random arguments to the function.</summary>
            <remarks>Factor is f(sample, size) = 1(sample &lt; size)/size</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Constant value for <c>size</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,size))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Constant value for <c>size</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Incoming message from <c>size</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(size) p(size) factor(sample,size))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Incoming message from <c>size</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(size) p(size) factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,size))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="size">Incoming message from <c>size</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,size) p(sample,size) factor(sample,size) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="size">Constant value for <c>size</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,size) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="size">Constant value for <c>size</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>sample</c>.</summary><param name="size">Incoming message from <c>size</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(size) p(size) factor(sample,size)]/p(sample)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditionalInit(System.Int32)">
            <summary/><param name="size">Constant value for <c>size</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="size">Incoming message from <c>size</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>size</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>size</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>size</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>size</c> as the random arguments are varied. The formula is <c>proj[p(size) sum_(sample) p(sample) factor(sample,size)]/p(size)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="size">Constant value for <c>size</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Incoming message from <c>size</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(size) p(size) log(factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(System.Int32,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="size">Constant value for <c>size</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="size">Incoming message from <c>size</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,size) p(sample,size) log(factor(sample,size))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithmInit(System.Int32)">
            <summary/><param name="size">Constant value for <c>size</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="size">Incoming message from <c>size</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>sample</c>.</summary><param name="size">Constant value for <c>size</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>sample</c>.</summary><param name="size">Incoming message from <c>size</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(size) p(size) log(factor(sample,size)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>size</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>size</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>size</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>size</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,size)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumSupport">
            <summary>
            Provides factors and operators for using Enum types.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.EnumToInt``1(``0)">
            <summary>
            Converts an Enum to an Int
            </summary>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples an enum value from a discrete enum distribution.
            </summary>
            <typeparam name="TEnum">The type of the enum to sample</typeparam>
            <param name="probs">Vector of the probability of each Enum value, in order</param>
            <returns>An enum sampled from the distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)">
            <summary>
            Test if two enums are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumToIntOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.EnumToInt``1(``0)"/>, given random arguments to the function.</summary>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(System.Int32,`0)">
            <summary>Evidence message for EP.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(System.Int32,`0)">
            <summary>Evidence message for EP.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.AverageLogFactor(System.Int32,`0)">
            <summary>Evidence message for VMP.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>Evidence message for EP.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>Evidence message for EP.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,`0)">
            <summary>Evidence message for EP.</summary><param name="Int">Incoming message from <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Int,Enum) p(Int,Enum) factor(Int,Enum))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="Int">Incoming message from <c>Int</c>.</param><param name="Enum">Incoming message from <c>Enum</c>.</param><param name="to_Int">Outgoing message to <c>Int</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Int,Enum) p(Int,Enum) factor(Int,Enum))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="Int">Incoming message from <c>Int</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Int) p(Int) factor(Int,Enum) / sum_Int p(Int) messageTo(Int))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Int,Enum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Int</c>.</summary><param name="Enum">Incoming message from <c>Enum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Int</c> as the random arguments are varied. The formula is <c>proj[p(Int) sum_(Enum) p(Enum) factor(Int,Enum)]/p(Int)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Enum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageConditionalInit(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary/><param name="Enum">Incoming message from <c>Enum</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>Enum</c>.</summary><param name="Int">Incoming message from <c>Int</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Enum</c> as the random arguments are varied. The formula is <c>proj[p(Enum) sum_(Int) p(Int) factor(Int,Enum)]/p(Enum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Int"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>Enum</c>.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Enum</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageLogarithm(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>Int</c>.</summary><param name="Enum">Incoming message from <c>Enum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Int</c> as the random arguments are varied. The formula is <c>proj[sum_(Enum) p(Enum) factor(Int,Enum)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Enum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>Enum</c>.</summary><param name="Int">Incoming message from <c>Int</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Enum</c> with <c>Int</c> integrated out. The formula is <c>sum_Int p(Int) factor(Int,Enum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Int"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>Enum</c>.</summary><param name="Int">Constant value for <c>Int</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Enum</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
            <remarks>
            This class provides operators which have <see cref="T:System.Enum"/> arguments.  
            The rest are provided by <see cref="T:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp"/>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogAverageFactor(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample,Probs) p(Sample,Probs) factor(Sample,Probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogAverageFactor(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.AverageLogFactor(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample,Probs) p(Sample,Probs) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.AverageLogFactor(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(Sample) p(Sample) log(factor(Sample,Probs))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Incoming message from <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample,Probs) p(Sample,Probs) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="probs">Constant value for <c>Probs</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sample) p(Sample) factor(Sample,Probs) / sum_Sample p(Sample) messageTo(Sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.ProbsAverageConditional(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>EP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Probs</c> as the random arguments are varied. The formula is <c>proj[p(Probs) sum_(Sample) p(Sample) factor(Sample,Probs)]/p(Probs)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.ProbsAverageLogarithm(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>Probs</c>.</summary><param name="sample">Incoming message from <c>Sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Probs</c>. The formula is <c>exp(sum_(Sample) p(Sample) log(factor(Sample,Probs)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)"/>, given random arguments to the function.</summary>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
            <remarks>
            This class only implements enumeration-specific overloads that are not provided by <see cref="T:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp"/>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(areEqual,b) p(areEqual,b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageConditional(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(areEqual,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageLogarithm(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>a</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(areEqual,a) p(areEqual,a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageConditional(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(areEqual,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Incoming message from <c>areEqual</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>areEqual</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="areEqual"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageLogarithm(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>b</c>.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(areEqual,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageConditional(`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>EP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[p(areEqual) sum_(a,b) p(a,b) factor(areEqual,a,b)]/p(areEqual)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageLogarithm(`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>VMP message to <c>areEqual</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>areEqual</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>areEqual</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,`0)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Incoming message from <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(areEqual,a,b) p(areEqual,a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,`0,`0)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogEvidenceRatio(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Outgoing message to <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogEvidenceRatio(System.Boolean,`0,`0)">
            <summary>Evidence message for EP.</summary><param name="areEqual">Constant value for <c>areEqual</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureIterations">
            <summary>
            Number of quadrature iterations
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureShift">
            <summary>
            Quadrature shift
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.ForceProper">
            <summary>
             Forces proper messages when set to true. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="exp">Constant value for <c>exp</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(exp,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="exp">Constant value for <c>exp</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(exp,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.AverageLogFactor(System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="exp">Constant value for <c>exp</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(exp,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp) p(exp) factor(exp,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Constant value for <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(d) p(d) factor(exp,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor_slow(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_exp">Outgoing message to <c>exp</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d) / sum_exp p(exp) messageTo(exp))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Constant value for <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(d) p(d) factor(exp,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary/><param name="d">Incoming message from <c>d</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Constant value for <c>exp</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(exp,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>exp</c>.</summary><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[sum_(d) p(d) factor(exp,d)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>VMP message to <c>exp</c>.</summary><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[sum_(d) p(d) factor(exp,d)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>VMP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> with <c>exp</c> integrated out. The formula is <c>sum_exp p(exp) factor(exp,d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DNonconjugateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Nonconjugate VMP message to 'd'.
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d"></param>
            <param name="result"></param>
            <returns>The outgoing nonconjugate VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing VMP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> with <c>exp</c> integrated out. The formula is <c>sum_exp p(exp) factor(exp,d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(System.Double)">
            <summary>VMP message to <c>d</c>.</summary><param name="exp">Constant value for <c>exp</c>.</param><returns>The outgoing VMP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(System.Double)">
            <summary>VMP message to <c>exp</c>.</summary><param name="d">Constant value for <c>d</c>.</param><returns>The outgoing VMP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>exp</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_Laplace">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="to_exp">Previous outgoing message to <c>exp</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d) / sum_exp p(exp) messageTo(exp))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.XInit(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Initialize the buffer <c>x</c>.</summary><param name="d">Incoming message from <c>d</c>.</param><returns>Initial value of buffer <c>x</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.X(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>x</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Buffer <c>x</c>.</param><returns>New value of buffer <c>x</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Buffer <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Buffer <c>x</c>.</param><param name="to_exp">Previous outgoing message to <c>exp</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d) / sum_exp p(exp) messageTo(exp))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Buffer <c>x</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="x">Buffer <c>x</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.CInit">
            <summary>Initialize the buffer <c>c</c>.</summary><returns>Initial value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.C(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>c</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>New value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="to_exp">Previous outgoing message to <c>exp</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d) / sum_exp p(exp) messageTo(exp))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3_Slow">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3_Slow.LoghInit">
            <summary>Initialize the buffer <c>logh</c>.</summary><returns>Initial value of buffer <c>logh</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3_Slow.Logh(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double[])">
            <summary>Update the buffer <c>logh</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3_Slow.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double[])">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="logh">Buffer <c>logh</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace3_Slow.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2_Slow">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2_Slow.CInit">
            <summary>Initialize the buffer <c>c</c>.</summary><returns>Initial value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2_Slow.C(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>c</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>New value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2_Slow.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_Laplace2_Slow.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp3">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp3.CInit">
            <summary>Initialize the buffer <c>c</c>.</summary><returns>Initial value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp3.C(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>c</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>New value of buffer <c>c</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp3.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><param name="c">Buffer <c>c</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp3.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>exp</c>.</summary><param name="exp">Incoming message from <c>exp</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing EP message to the <c>exp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exp</c> as the random arguments are varied. The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_BFGS">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_BFGS.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>d</c>.</summary><param name="exp">Incoming message from <c>exp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_d">Previous outgoing message to <c>d</c>.</param><returns>The outgoing VMP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> with <c>exp</c> integrated out. The formula is <c>sum_exp p(exp) factor(exp,d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Factor">
            <summary>
            A repository of commonly used factor methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})">
            <summary>
            Random factor - samples from a given distribution
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
            <param name="dist">Distribution to sample from</param>
            <returns>Sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)">
            <summary>
            Sample from a Bernoulli distribution.
            </summary>
            <param name="probTrue">The probability that the result is true.</param>
            <returns>A random boolean value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)">
            <summary>
            Sample from a Bernoulli distribution with specified log odds
            </summary>
            <param name="logOdds"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)">
            <summary>
            Sample from a Gamma with specified shape and scale
            </summary>
            <param name="shape"></param>
            <param name="rate"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])">
            <summary>
            Sample from one of many Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="index">The index of the distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each index.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each choice.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrueElseChoice">The probability that the result is true, if <paramref name="choice"/> is false.</param>
            <param name="probTrueIfChoice">The probability that the result is true, if <paramref name="choice"/> is true.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)">
            <summary>
            Sample from a Beta distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, i.e. a value in [0,1]. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sample from a Dirichlet distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, a probability vector. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DirichletSymmetric(System.Int32,System.Double)">
            <summary>
            Sample from a symmetric Dirichlet distribution Dir(alpha,...,alpha)
            </summary>
            <param name="K">Dimension of the distribution.</param>
            <param name="alpha">The hyperparameter.</param>
            <returns>A sample from the distribution, a probability vector. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sample from one of several discrete distributions.
            </summary>
            <param name="probs">Matrix holding discrete distributions as rows.</param>
            <param name="selector">Integer selecting which row of probs to sample from.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a discrete distribution.
            </summary>
            <param name="probs">The probability of each outcome.</param>
            <returns>A random integer from 0 to <c>probs.Length-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteUniform(System.Int32)">
            <summary>
            Sample from a uniform discrete distribution
            </summary>
            <param name="size">The dimension of the distribution (how many possibke distinct values</param>
            <returns>A random integer from 0 to <c>size-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromStickBreaking(System.Double[])">
            <summary>
            Sample from a stick breaking distribution
            </summary>
            <param name="v">Stick lengths.  The last value is ignored.</param>
            <returns>A random integer in 0..(v.Length-1)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian distribution.
            </summary>
            <param name="mean">The mean of the distribution.</param>
            <param name="precision">The precision of the distribution.  The variance will be 1/precision.</param>
            <returns>A random real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GaussianFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian distribution.
            </summary>
            <param name="mean">The mean of the distribution.</param>
            <param name="variance">The variance of the distribution.  The precision will be 1/variance.</param>
            <returns>A random real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sample from a VectorGaussian distribution.
            </summary>
            <param name="mean">The mean vector of the distribution.</param>
            <param name="precision">The precision matrix of the distribution.  The variance matrix will be inv(precision).</param>
            <returns>A random real vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)">
            <summary>
            Sample from a Poisson distribution with a specified mean
            </summary>
            <param name="mean">The mean of the Poisson distribution</param>
            <returns>An integer sample &gt;= 0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.PoissonFromLogRate(System.Double)">
            <summary>
            Sample from a Poisson distribution with specified log mean
            </summary>
            <param name="logRate">The log mean of the Poisson distribution</param>
            <returns>An integer sample &gt;= 0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Binomial(System.Int32,System.Double)">
            <summary>
            Sample from a Binomial distribution with specified probability of success per trial and number of trials.
            </summary>
            <param name="trialCount"></param>
            <param name="probSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.MultinomialList(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>A list of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)">
            <summary>
            Negate a boolean
            </summary>
            <param name="b">The bool</param>
            <returns>The negation of a boolean argument</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)">
            <summary>
            Logical or of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a|b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)">
            <summary>
            Logical and of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a&amp;b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)">
            <summary>
            Test if two booleans are equal.
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)">
            <summary>
            Test if two integers are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.String,System.String)">
            <summary>
            Tests if two strings are equal.
            </summary>
            <param name="str1">The first string.</param>
            <param name="str2">The second string.</param>
            <returns><see langword="true"/> if the strings are equal, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)">
            <summary>
            Test if a real number is positive.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <returns>True if x>0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Test if a number is between two bounds.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <param name="lowerBound">Any number besides NaN.</param>
            <param name="upperBound">Any number besides NaN.</param>
            <returns>True if (lowerBound &lt;= x) and (x &lt; upperBound)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)">
            <summary>
            Returns the maximum of the two arguments: max(a,b)
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsGreaterThan(System.Int32,System.Int32)">
            <summary>
            Test if A is greater than B.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a &gt; b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Int32,System.Int32)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)">
            <summary>
            Returns the difference of the two arguments: (a - b).
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Int32,System.Int32)">
            <summary>
            Returns the difference of the two arguments: (a - b).
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)">
            <summary>
            Returns the product of the two arguments a * b.
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product_SHG09(System.Double,System.Double)">
            <summary>
            Returns the product of the two arguments a * b.
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ProductExp(System.Double,System.Double)">
            <summary>
            Returns the product  a * exp(b).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)">
            <summary>
            Returns the ratio of the two arguments a / b.
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.InnerProductPartialCovariance(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.SumWhere(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors, the first of which is binary.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiply matrix times vector
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_j a[i,j]*b[j]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Multiply posdef matrix times scalar
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>a[i,j]*b</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Multiply scalar times posdef matrix
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>a*b[i,j]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
            Returns the product of two matrices.
            </summary>
            <param name="A">A two-dimensional array indexed by [row,col].</param>
            <param name="B">A two-dimensional array indexed by [row,col].</param>
            <returns>A two-dimensional array indexed by [row,col].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})">
            <summary>
            Sum the numbers in an array.
            </summary>
            <param name="array"></param>
            <returns><c>sum_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Sums the specified list of vectors.
            </summary>
            <param name="array">The list of vectors.</param>
            <returns>The sum over all vectors in the array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.CountTrue(System.Boolean[])">
            <summary>
            Count the number of true values in the given boolean array.
            </summary>
            <param name="array">The array of booleans.</param>
            <returns>Number of true values in the given array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            True if all array elements are true.
            </summary>
            <param name="array"></param>
            <returns><c>AND_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get an element of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index">The index to get</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple different elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get.  Must all be different.</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>
            Get an element of a 2D array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index1">The first index</param>
            <param name="index2">The second index</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ArrayFromVector(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Convert a Vector into an array of doubles.
            </summary>
            <param name="vector"></param>
            <returns>A new array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)">
            <summary>
            An internal factor.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="def"></param>
            <param name="marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)">
            <summary>
            An internal factor.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="def"></param>
            <param name="marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="count"></param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)">
            <summary>
            Create an array filled with a single value. For reference types,
            the replicates all reference the same instance
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <param name="count">Number of replicates</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateNd``1(``0)">
            <summary>
            Create a multidimensional array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="count"></param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)">
            <summary>
            Passes the input through to the output.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to return.</param>
            <returns>The supplied value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Cut``1(``0)">
            <summary>
            Passes the input through to the output. Used to set backward messages to uniform.
            </summary>
            <typeparam name="T">The type the input value.</typeparam>
            <param name="value">The value to return.</param>
            <returns>The supplied value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GaussianArrayArray(System.Int32,System.Double[],System.Int32[][]@)">
            <summary>
            Generate a jagged array of Gaussian random variables.
            </summary>
            <param name="sampleCount"></param>
            <param name="precisions"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function evaluate factor
            </summary>
            <param name="func">Function</param>
            <param name="x">Function input</param>
            <returns>Function output</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Rotate a 2D vector about the origin
            </summary>
            <param name="x">First coordinate of vector</param>
            <param name="y">Second coordinate of vector</param>
            <param name="angle">Counter-clockwise rotation angle in radians</param>
            <returns>The rotated vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Char(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples a character from a given probability distribution over characters.
            </summary>
            <param name="probabilities">A vector storing probabilities of individual characters.</param>
            <returns>The sampled character.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.StringFromArray(System.Char[])">
            <summary>
            Converts a given character array to a string.
            </summary>
            <param name="characters">The character array to convert.</param>
            <returns>A string made of characters in the array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.StringCapitalized(System.Int32)">
            <summary>
            Samples a string from <see cref="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Capitalized(System.Int32,System.Nullable{System.Int32})"/> with a specified minimum string length.
            </summary>
            <param name="minLength">The minimum length of a string.</param>
            <returns>The sampled string.</returns>
            <remarks>The method always throws <see cref="T:System.InvalidOperationException"/> since the distribution is improper.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.StringCapitalized(System.Int32,System.Int32)">
            <summary>
            Samples a string from <see cref="M:MicrosoftResearch.Infer.Distributions.StringDistribution.Capitalized(System.Int32,System.Nullable{System.Int32})"/> with a specified minimum and maximum string length.
            </summary>
            <param name="minLength">The minimum length of a string.</param>
            <param name="maxLength">The maximum length of a string.</param>
            <returns>The sampled string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.StringOfLength(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>
            Samples a string from a uniform distribution over strings of a given length,
            with characters restricted to the support of a given distribution.
            </summary>
            <param name="length">The length of a string.</param>
            <param name="allowedChars">The distribution specifying allowed string characters.</param>
            <returns>The sampled string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.String(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>
            Samples a string from a uniform distribution over strings of length greater or equal to a given one,
            with characters restricted to the support of a given distribution.
            </summary>
            <param name="minLength">The minimum length of a string.</param>
            <param name="allowedChars">The distribution specifying allowed string characters.</param>
            <returns>The sampled string.</returns>
            <remarks>The method always throws <see cref="T:System.InvalidOperationException"/> since the distribution is improper.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.String(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteChar)">
            <summary>
            Samples a string from a uniform distribution over strings of length within given bounds,
            with characters restricted to the support of a given distribution.
            </summary>
            <param name="minLength">The minimum length of a string.</param>
            <param name="maxLength">The maximum length of a string.</param>
            <param name="allowedChars">The distribution specifying allowed string characters.</param>
            <returns>The sampled string.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Substring(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts a substring from a given string.
            </summary>
            <param name="str">The string.</param>
            <param name="start">The start index of the substring.</param>
            <param name="length">The length of the substring.</param>
            <returns>The extracted substring.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Single(System.String)">
            <summary>
            If a given string contains a single character, extracts the character, otherwise fails.
            </summary>
            <param name="str">The string.</param>
            <returns>The extracted character.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.String,System.String)">
            <summary>
            Concatenates given strings.
            </summary>
            <param name="str1">The first string.</param>
            <param name="str2">The second string.</param>
            <returns>The concatenation result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.Char,System.String)">
            <summary>
            Concatenates a character and a string.
            </summary>
            <param name="ch">The character.</param>
            <param name="str">The string.</param>
            <returns>The concatenation result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Concat(System.String,System.Char)">
            <summary>
            Concatenates a string and a character.
            </summary>
            <param name="str">The string.</param>
            <param name="ch">The character.</param>
            <returns>The concatenation result.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.StringFormat(System.String,System.String[])">
            <summary>
            Replaces argument placeholders such as {0}, {1} etc with arguments having the corresponding index,
            similar to what <see cref="M:System.String.Format(System.String,System.Object[])"/> does.
            </summary>
            <param name="format">The string with argument placeholders.</param>
            <param name="args">The array of arguments.</param>
            <returns><paramref name="format"/> with argument placeholders replaced by arguments.</returns>
            <remarks>
            This method has the following notable differences from <see cref="M:System.String.Format(System.String,System.Object[])"/>:
            <list type="bullet"></list>
            <item><description>Placeholder for each of the arguments must be present in the format string exactly once.</description></item>
            <item><description>No braces are allowed except for those used to specify placeholders.</description></item>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.UniformPlusMinus(System.Double)">
            <summary>
            Generate a real number uniformly between [-upperBound,upperBound]
            </summary>
            <param name="upperBound"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Double(System.Int32)">
            <summary>
            Convert an integer to a double-precision value
            </summary>
            <param name="integer"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`1">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`2">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`3">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`4">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`5">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`1">
            <summary>
            Delegate definition for constraint method with one argument
            </summary>
            <typeparam name="T1">Argument type for the constraint method</typeparam>
            <param name="arg1">Argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`2">
            <summary>
            Delegate definition for constraint method with two arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`3">
            <summary>
            Delegate definition for constraint method with three arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <typeparam name="T3">Third argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <param name="arg3">Third argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`4">
            <summary>
            Delegate definition for constraint method with four arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <typeparam name="T3">Third argument type for the constraint method</typeparam>
            <typeparam name="T4">Fourth argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <param name="arg3">Third argument for the constraint method</param>
            <param name="arg4">Fourth argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HasMessageFunctionsAttribute">
            <summary>
            When applied to an assembly, indicates that the assembly should be searched for message functions.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethodAttribute">
            <summary>
            When applied to a class, indicates that the class provides message functions for a given factor.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.Type">
            <summary>
            Type which contains the factor definition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.MethodName">
            <summary>
            Method name for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.ParameterTypes">
            <summary>
            Parameter types for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.NewParameterNames">
            <summary>
            New names for factor parameters overriding the default choice of parameter names
            - these are used to name message passing methods
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.Default">
            <summary>
            True if this class should override other classes for the same factor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.String[],System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
            <param name="newParameterNames">New names for factor parameters overriding the default choice of
            parameter names - these are used to name message passing methods</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HiddenAttribute">
            <summary>
            Marks a factor as hidden
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.HiddenAttribute.IsDefined(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the given method has a 'Hidden' attribute
            </summary>
            <param name="mi">The method info</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.HiddenAttribute.IsDefined(System.Type)">
            <summary>
            Returns true if the given type has a 'Hidden' attribute
            </summary>
            <param name="ty">The type</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HasUnitDerivative">
            <summary>
            Marks a factor as having derivative wrt all inputs equal to 1 always (only applies to deterministic factors)
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BuffersAttribute">
            <summary>
            When applied to a message operator class, indicates that the message operators may use the named parameters as storage for holding algorithm state.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.BuffersAttribute.BufferNames">
            <summary>
            Names of buffers that may be used as method parameters.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BuffersAttribute.#ctor(System.String[])">
            <summary>
            Creates a new Buffers attribute
            </summary>
            <param name="names"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute">
            <summary>
            When applied to a method, overrides the default choice of parameter names.
            </summary>
            <remarks>
            The first parameter is the result.  Thus the method <c>int f(int x)</c> has two parameters, the
            result and x.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.Names">
            <summary>
            The new parameter names
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.#ctor(System.String[])">
            <summary>
            Creates a new ParameterNames attribute
            </summary>
            <param name="names"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllExceptIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on all items
            in the message collection except the resultIndex.  The default is all items.
            </summary>
            <remarks>
            This attribute cannot be combined with MatchingIndexAttribute, since they would cancel.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on the one
            item in the message collection at resultIndex.  The default is all items.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexedAttribute">
            <summary>
            When applied to a message function parameter, indicates that the argument should be indexed by resultIndex.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CancelsAttribute">
            <summary>
            When applied to a message function parameter, indicates that the argument's value is cancelled by another argument, thus there is no real dependency.
            </summary>
            <remarks>
            Implies NoInit.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InducedSourceAttribute">
            <summary>
            When applied to a message function parameter, causes the InducedTarget to depend on the parameter
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InducedTargetAttribute">
            <summary>
            When applied to a message function parameter, causes the parameter to depend on the InducedSource
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProperAttribute">
            <summary>
            The distribution must be proper.
            </summary>
            <remarks>
            Applies to message function parameters.  Indicates that the parameter should be a proper distribution,
            or else the behavior is undefined.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipAttribute">
            <summary>
            The result is always uniform.
            </summary>
            <remarks>
            Applies to message functions.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce uniform results.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) whenever this parameter is uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message function parameters.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.  For LogAverageFactor and AverageLogFactor, SkipIfUniform means the result would be 0.
            </para><para>
            When applied to an array parameter, this attribute means the result is uniform (or an exception would be thrown)
            whenever all dependent elements in the array are uniform.
            For example:
            <list type="bullet">
            <item><term><c>f([AllExceptIndex,SkipIfUniform] Message[] array, int resultIndex)</c></term>
            <description><c>f</c> depends on all elements other than resultIndex, and can be skipped if all of these are uniform.
            <c>f</c> does not depend on <c>array[resultIndex]</c> and the uniformity of this element is ignored.
            </description>
            </item>
            </list>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements are uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message functions and message function array parameters.
            This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.
            When applied to a message function, it means that the result is uniform (or an exception would be thrown) whenever all parameters to the function are uniform.
            When applied to an array parameter, it means that the result is uniform (or an exception would be thrown) whenever all dependent elements in the array are uniform.
            Array elements that the function does not depend on are ignored.
            </para><para>
            It only makes sense to apply this attribute to a method when the method parameters have no SkipIfUniform attributes set.
            Otherwise SkipIfAllUniform is automatically implied by SkipIfUniform for the parameter.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.ParameterNames">
            <summary>
            List of parameter names for which to check for uniformity
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor">
            <summary>
            Creates a new SkipIfAllUniform attribute
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor(System.String[])">
            <summary>
            Creates a new SkipIfAllUniform attribute applied to the specified parameter names
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAnyUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if any element is uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message function array parameters.
            This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.
            When applied to an array parameter, it means that the result is uniform (or an exception would be thrown) whenever any dependent element in the array is uniform.
            Array elements that the function does not depend on are ignored.
            When applied to a parameter that is not an array, it has the same meaning as SkipIfUniform.
            </para><para>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAnyExceptIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if any element except
            at the result index is uniform, hence the function call can be skipped.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item><term><c>f([SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Since no dependency attribute was given, the default is that <c>f</c> depends on all elements of the array.
            Since <c>SkipIfAnyExceptIndexIsUniform</c> was given, <c>f</c> returns uniform (or throws an exception) if any elements except the one at resultIndex is uniform.
            Thus <c>array[resultIndex]</c> is a dependency but its uniformity is ignored.</description>
            </item>
            <item><term><c>f([AllExceptIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>In this case, <c>f</c> depends on all elements other than resultIndex, and returns uniform (or throws an exception) if any of them are uniform.
            Thus it is equivalent to <c>[AllExceptIndex,SkipIfUniform]</c></description>
            </item>
            <item><term><c>f([MatchingIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Here <c>SkipIfAnyExceptIndexIsUniform</c> is ignored since <c>f</c> only depends on <c>array[resultIndex]</c>.
            </description>
            </item>
            </list>
            This attribute can be stacked with the other SkipIfUniform attributes, to build up a set of skip cases.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllExceptIndexAreUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements except
            at the result index are uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfMatchingIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if the element at
            the result index is uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IgnoreDependencyAttribute">
            <summary>
            When attached to a method parameter, indicates that the dependency should be ignored by the FactorManager.  Only a declaration dependency will be retained.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IgnoreDeclarationAttribute">
            <summary>
            When attached to a method parameter, indicates that the dependency and the declaration dependency should be ignored by the FactorManager.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstantAttribute">
            <summary>
            When attached to a factor parameter, indicates that the parameter
            is constant - i.e. cannot be changed by observation or by inference
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantAttribute.IsDefined(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if this parameter has a Constant attribute
            </summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.RequiredArgumentAttribute">
            <summary>
            When applied to a method argument, indicates that argument is required to have
            been set before calling the method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RequiredArgumentAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsReturnedAttribute">
            <summary>
            When applied to a method argument, indicates that the argument will be returned unmodified
            as the result of the method.  This automatically implies SkipIfUniform and Trigger.
            </summary>
            <remarks>
            This attribute allows significant optimisations to be undertaken in the compiler.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsReturnedAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsReturnedInEveryElementAttribute">
            <summary>
            When applied to a method argument for methods that return lists, indicates that all elements
            of the returned list will be identical and equal to that argument.  This automatically implies SkipIfUniform.
            </summary>
            <remarks>
            This attribute allows significant optimisations to be undertaken in the compiler.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsReturnedInEveryElementAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.TriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            a dependent item in that argument changes.
            </summary>
            <remarks>
            The formal definition of trigger is:
            If C uses A, and A is triggered by B, then when B changes, A must be updated before C.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexTriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            the array element at resultIndex changes.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NoTriggersAttribute">
            <summary>
            When applied to a method, indicates that no default triggers should be assigned to its parameters.
            The method will explicitly mark its triggers using TriggerAttribute.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FreshAttribute">
            <summary>
            When applied to a method argument, indicates that the argument must be up-to-date
            before invoking the method.
            When applied to a method, indicates that the method must be recomputed whenever any of its arguments change.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MultiplyAllAttribute">
            <summary>
            When applied to a message function, indicates that the function returns the product of its arguments.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NoInitAttribute">
            <summary>
            When applied to a method argument, indicates that the argument does not benefit from initialization (by default, initialization is assumed to be beneficial)
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReturnsCompositeArrayAttribute">
            <summary>
            When applied to a factor, indicates that the factor returns a composite array.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
            <summary>
            Improper message exception
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ImproperMessageException.#ctor(System.Object)">
            <summary>
            Creates an improper message exception with the specified distribution
            </summary>
            <param name="distribution">Distribution instance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NotSupportedAttribute">
            <summary>
            When applied to a method, indicates that the method will always throw a NotSupportedException.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.Message">
            <summary>
            Message for the exception that will be thrown by the method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.#ctor(System.String)">
            <summary>
            Creates a NotSupported attribute with the given exception message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.QualityBand">
            <summary>
            Quality bands for Infer.NET components - distributions, operators, factors
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Unknown">
            <summary>
            Unknown. Components which are not marked with a quality band. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Experimental">
            <summary>
            Experimental components are work in progress and represent early stage development
            of new components. They are typically usable in just a few common scenarios, and
            will not have undergone rigorous testing. They are primarily intended for use by
            researchers and provide an opportunity for preliminary feedback. It is possible that
            a given experimental component may not be included in a future release. These may
            be undocumented or only sparsely documented.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Preview">
            <summary>
            Preview components are intended to meet most basic usage scenarios. While in
            the Preview Quality Band, these components may have a moderate number of breaking
            API or behavior changes in response to user feedback and as we learn more
            about how they will be used. Users are likely to encounter bugs and
            functionality issues for less common scenarios. These will have some documentation
            which may be minimal.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Stable">
            <summary>
            Stable components are suitable for a wide range of usage scenarios and will
            have incorporated substantial design and functionality feedback. They may continue
            evolving via limited bug fixes, fine-tuning, and support for additional scenarios.
            Stable components may have a small number of breaking API or behaviour changes
            when feedback demands it. These components will have reasonable documentation
            which may include examples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Mature">
            <summary>
            Mature components are ready for full release, meeting the highest levels of
            quality and stability. Future releases of mature components will maintain a high
            quality bar with no breaking changes other than in exceptional circumstances.
            Users should be confident using mature components, knowing that when they
            upgrade from one version of Infer.NET to a newer version it will be a quick and
            easy process. These components will have detailed documentation and at least one
            example of usage.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Quality">
            <summary>
            Attribute used to label Infer.NET components. They may be attached to algorithm classes,
            distribution classes, and operator classes. They may also be attached to any methods on
            these classes
            </summary>
            <remarks>Methods inherit the quality of their class. Classes are, by default, experimental.
            <para>
            The compiler will convert static quality bands to a quality band for each generated statement
            of code. Depending on the error level and warning levels set in the compiler, Errors and/or
            warnings will be issued. In addition, a general warning/error may be issued for the algorithm.
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Quality.Band">
            <summary>
            Quality band
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.#ctor(MicrosoftResearch.Infer.QualityBand)">
            <summary>
            Constructor
            </summary>
            <param name="band"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.GetQualityBand(System.Type)">
            <summary>
            Gets the quality band associated with a type. If this is an array type
            then the quality of the element is returned. If the type has generic parameters
            then the quality of the generic type is returned
            </summary>
            <param name="t">Type</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.GetQualityBand(System.Reflection.MemberInfo)">
            <summary>
            Gets the quality band associated with a member of a class
            </summary>
            <param name="mi">Member info</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp">
            <!-- No matching elements were found for the following include tag --><include file="FactorDocs.xml" path="factor_docs/message_op_class[@name=&quot;GammaFromShapeAndRateOp&quot;]/doc/*"/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,rate) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(rate) p(rate) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(rate) p(rate) factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><returns>The outgoing EP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>rate</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,shape,rate) p(sample,shape,rate) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,shape) p(sample,shape) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(shape,rate) p(shape,rate) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(shape) p(shape) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(shape,rate) p(shape,rate) factor(sample,shape,rate)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(shape) p(shape) factor(sample,shape,rate)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rate</c> as the random arguments are varied. The formula is <c>proj[p(rate) sum_(sample,shape) p(sample,shape) factor(sample,shape,rate)]/p(rate)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ShapeAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>shape</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>shape</c> as the random arguments are varied. The formula is <c>proj[p(shape) sum_(sample) p(sample) factor(sample,shape,rate)]/p(shape)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ShapeAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>shape</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>shape</c> as the random arguments are varied. The formula is <c>proj[p(shape) sum_(rate) p(rate) factor(sample,shape,rate)]/p(shape)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ShapeAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>shape</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>shape</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ShapeAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>shape</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>shape</c> as the random arguments are varied. The formula is <c>proj[p(shape) sum_(sample,rate) p(sample,rate) factor(sample,shape,rate)]/p(shape)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,shape,rate) p(sample,shape,rate) log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(shape,rate) p(shape,rate) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(shape) p(shape) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(rate) p(rate) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>rate</c>. The formula is <c>exp(sum_(sample,shape) p(sample,shape) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>rate</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>rate</c>. The formula is <c>exp(sum_(shape) p(shape) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><returns>The outgoing VMP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>rate</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.RateAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>rate</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><returns>The outgoing VMP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>rate</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ShapeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>shape</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Incoming message from <c>shape</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_shape">Previous outgoing message to <c>shape</c>.</param><returns>The outgoing VMP message to the <c>shape</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>shape</c>. The formula is <c>exp(sum_(sample,rate) p(sample,rate) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="shape"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.NonconjugateProjection(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Project the standard VMP message onto a gradient matched Gamma message. 
            </summary>
            <param name="context">Incoming message.</param>
            <param name="gradS">Gradient of S=int factor(x) p(x) dx</param>
            <returns>Projected gamma message</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.twoByTwoInverse(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Two by two matrix inversion. 
            </summary>
            <param name="a">Matrix to invert</param>
            <returns>Inverted matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.CalculateDerivatives(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Calculate derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b)
            </summary>
            <param name="q">The Gamma distribution G(x;a,b).</param>
            <returns>A 2-vector containing derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b).</returns>
            <remarks><para>
             Calculates expectations in x=log(s) space using Gauss-Hermite quadrature. 
             For each integral the behaviour as x->0 is subtracted from the integrand 
             before performing quadrature to remove the singularity there. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOpBase.ELogGamma(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Calculates \int G(x;a,b) LogGamma(x) dx
            </summary>
            <param name="q">G(x;a,b)</param>
            <returns>\int G(x;a,b) LogGamma(x) dx</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(rate) p(rate) factor(sample,shape,rate)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.GetIntegrationBoundsForSample(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double@,System.Double@,System.Double@)">
            <summary>
            Get integration bounds for sample where rate is marginalized
            </summary>
            <param name="sample"></param>
            <param name="shape"></param>
            <param name="rate"></param>
            <param name="y">On output, the mode of the integrand</param>
            <param name="ymin">On output, the lower bound for integration</param>
            <param name="ymax">On output, the upper bound for integration</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.FindMaximum(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find the maximum of the function shape1*log(x) - shape2*log(x + yRate) - x*rateRate
            </summary>
            <param name="shape1">Must be &gt;= 0</param>
            <param name="shape2"></param>
            <param name="yRate">Must be &gt;= 0</param>
            <param name="rateRate">Must be &gt;= 0</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.GetIntegrationBoundsForRate(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double@,System.Double@,System.Double@)">
            <summary>
            Get integration bounds for rate where sample is marginalized.  The bounds are for an integral in the log-domain, but exponentiated.
            </summary>
            <param name="sample"></param>
            <param name="shape"></param>
            <param name="rate"></param>
            <param name="r">On output, the mode of the integrand</param>
            <param name="rmin">On output, the lower bound for integration</param>
            <param name="rmax">On output, the upper bound for integration</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Slow.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><returns>The outgoing EP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rate</c> as the random arguments are varied. The formula is <c>proj[p(rate) sum_(sample) p(sample) factor(sample,shape,rate)]/p(rate)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.QInit">
            <summary>Initialize the buffer <c>Q</c>.</summary><returns>Initial value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.Q(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Update the buffer <c>Q</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>New value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>rate</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rate</c> as the random arguments are varied. The formula is <c>proj[p(rate) sum_(sample) p(sample) factor(sample,shape,rate)]/p(rate)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(rate) p(rate) factor(sample,shape,rate)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Gamma.SampleFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Gate">
            <summary>
            Factors for handling gates.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Int32,``0)">
            <summary>
            Enter factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="selector"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Int32,``0,System.Int32[])">
            <summary>
            Enter partial factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="selector"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])">
            <summary>
            Enter partial factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Int32,``0,System.Int32)">
            <summary>
            Enter one factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="selector"></param>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])">
            <summary>
            Exit factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandomTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0@)">
            <summary>
            Exiting variable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <param name="Marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ReplicateExiting``1(``0,System.Int32)">
            <summary>
            Replicate an exiting variable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)">
            <summary>
            Boolean cases factor
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesBool(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Boolean cases factor expanded into elements
            </summary>
            <param name="b"></param>
            <param name="case0">case 0 (true)</param>
            <param name="case1">case 1 (false)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)">
            <summary>
            Integer cases factor
            </summary>
            <param name="i">index</param>
            <param name="count">number of cases</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CasesOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>EP message to <c>cases</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cases</c> as the random arguments are varied. The formula is <c>proj[p(cases) sum_(b) p(b) factor(cases,b)]/p(cases)</c>.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>EP message to <c>b</c>.</summary><param name="cases">Incoming message from <c>cases</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(cases) p(cases) factor(cases,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="cases">Incoming message from <c>cases</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(cases,b) p(cases,b) factor(cases,b) / sum_cases p(cases) messageTo(cases))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="cases">Incoming message from <c>cases</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(cases) p(cases) factor(cases,b) / sum_cases p(cases) messageTo(cases))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>VMP message to <c>cases</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cases</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(cases,b)]</c>.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>VMP message to <c>b</c>.</summary><param name="cases">Incoming message from <c>cases</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>cases</c> integrated out. The formula is <c>sum_cases p(cases) factor(cases,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for VMP.</summary><param name="cases">Incoming message from <c>cases</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CasesBoolOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.CasesBool(System.Boolean,System.Boolean@,System.Boolean@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>case0</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>case0</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case0</c> as the random arguments are varied. The formula is <c>proj[p(case0) sum_(b) p(b) factor(b,case0,case1)]/p(case0)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>case1</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>case1</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case1</c> as the random arguments are varied. The formula is <c>proj[p(case1) sum_(b) p(b) factor(b,case0,case1)]/p(case1)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(case0,case1) p(case0,case1) factor(b,case0,case1)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(case0,case1,b) p(case0,case1,b) factor(b,case0,case1))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>case0</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>case0</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case0</c>. The formula is <c>exp(sum_(b) p(b) log(factor(b,case0,case1)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>case1</c>.</summary><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>case1</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case1</c>. The formula is <c>exp(sum_(b) p(b) log(factor(b,case0,case1)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(case0,case1) p(case0,case1) log(factor(b,case0,case1)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for VMP.</summary><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntCasesOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>EP message to <c>casesInt</c>.</summary><param name="i">Incoming message from <c>i</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>casesInt</c> as the random arguments are varied. The formula is <c>proj[p(casesInt) sum_(i) p(i) factor(casesInt,i,count)]/p(casesInt)</c>.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="i">Incoming message from <c>i</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>i</c>.</summary><param name="cases">Incoming message from <c>casesInt</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>i</c> as the random arguments are varied. The formula is <c>proj[p(i) sum_(casesInt) p(casesInt) factor(casesInt,i,count)]/p(i)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="cases">Incoming message from <c>casesInt</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="i">Incoming message from <c>i</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(casesInt,i) p(casesInt,i) factor(casesInt,i,count) / sum_casesInt p(casesInt) messageTo(casesInt))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Int32)">
            <summary>Evidence message for EP.</summary><param name="cases">Incoming message from <c>casesInt</c>.</param><param name="i">Constant value for <c>i</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(casesInt) p(casesInt) factor(casesInt,i,count) / sum_casesInt p(casesInt) messageTo(casesInt))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>VMP message to <c>casesInt</c>.</summary><param name="i">Incoming message from <c>i</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>casesInt</c> as the random arguments are varied. The formula is <c>proj[sum_(i) p(i) factor(casesInt,i,count)]</c>.</para>
      </remarks>
            <typeparam name="BernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="i">Incoming message from <c>i</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>i</c>.</summary><param name="cases">Incoming message from <c>casesInt</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>i</c> with <c>casesInt</c> integrated out. The formula is <c>sum_casesInt p(casesInt) factor(casesInt,i,count)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="cases">Incoming message from <c>casesInt</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="i">Incoming message from <c>i</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="cases"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Int32,``0,System.Int32[])"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Boolean,``0,System.Int32[])"/></description></item></list>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartial,selector,value,indices))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartial,selector,value,indices))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.EnterPartialAverageConditional``2(``0,``1)">
            <summary>EP message to <c>enterPartial</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterPartial</c> as the random arguments are varied. The formula is <c>proj[p(enterPartial) sum_(value) p(value) factor(enterPartial,selector,value,indices)]/p(enterPartial)</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.EnterPartialInit``2(``0,System.Int32[],MicrosoftResearch.Infer.Collections.IArrayFactory{``0,``1})">
            <summary>Initialize the buffer <c>enterPartial</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="factory"/><returns>Initial value of buffer <c>enterPartial</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TValue">The type of the incoming message from <c>value</c>.</typeparam>
            <typeparam name="TArray">The type of an array that can be produced by <paramref name="factory"/>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="selector"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Constant value for <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial) p(enterPartial) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="selector"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},System.Boolean,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{`0},System.Boolean,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartial,selector) p(enterPartial,selector) factor(enterPartial,selector,value,indices)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartial,selector,value,indices))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.EnterPartialAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>enterPartial</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterPartial</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(enterPartial,selector,value,indices)]</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32[],``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Constant value for <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>enterPartial</c> integrated out. The formula is <c>sum_enterPartial p(enterPartial) factor(enterPartial,selector,value,indices)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,System.Int32[],``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enterPartial</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(selector) p(selector) log(sum_enterPartial p(enterPartial) factor(enterPartial,selector,value,indices)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam> 
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Boolean,System.Int32[],``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enterPartial</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(selector) p(selector) log(sum_enterPartial p(enterPartial) factor(enterPartial,selector,value,indices)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam> 
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32[],``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterPartial">Incoming message from <c>enterPartial</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enterPartial</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(selector) p(selector) log(sum_enterPartial p(enterPartial) factor(enterPartial,selector,value,indices)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartial"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam> 
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.SelectorAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.SelectorAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageConditional``2(``0,``1)">
            <summary>EP message to <c>enterPartialTwo</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterPartialTwo</c> as the random arguments are varied. The formula is <c>proj[p(enterPartialTwo) sum_(value) p(value) factor(enterPartialTwo,case0,case1,value,indices)]/p(enterPartialTwo)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case0AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>case0</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>case0</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case1AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>case1</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>case1</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,``0,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartialTwo,case0,case1) p(enterPartialTwo,case0,case1) factor(enterPartialTwo,case0,case1,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartialTwo"/> is not a proper distribution.</exception>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageConditional``2(System.Collections.Generic.IList{``0},System.Boolean,System.Boolean,System.Int32[],``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="case1">Constant value for <c>case1</c>.</param><param name="case2"/><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterPartialTwo) p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartialTwo"/> is not a proper distribution.</exception>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TDomain">The type of the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>enterPartialTwo</c>.</summary><param name="value">Incoming message from <c>value</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterPartialTwo</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(enterPartialTwo,case0,case1,value,indices)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="value"/> is not a proper distribution.</exception>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case0AverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32[],MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>case0</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case0</c>. Because the factor is deterministic, <c>enterPartialTwo</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(value) p(value) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case1AverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32[],MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>case1</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case1</c>. Because the factor is deterministic, <c>enterPartialTwo</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(value) p(value) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32[],``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterPartialTwo">Incoming message from <c>enterPartialTwo</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enterPartialTwo</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(case0,case1) p(case0,case1) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterPartialTwo"/> is not a proper distribution.</exception>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Int32,``0,System.Int32)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterOne,selector,value,index))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterOne,selector,value,index))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.EnterOneAverageConditional``1(``0)">
            <summary>EP message to <c>enterOne</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>enterOne</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterOne</c> as the random arguments are varied. The formula is <c>proj[p(enterOne) sum_(value) p(value) factor(enterOne,selector,value,index)]/p(enterOne)</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the incoming message from <c>value</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.ValueAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Discrete,``0,System.Int32,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterOne">Incoming message from <c>enterOne</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterOne,selector) p(enterOne,selector) factor(enterOne,selector,value,index)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterOne"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.ValueAverageConditional``1(``0,System.Int32,System.Int32,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enterOne">Incoming message from <c>enterOne</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="selector">Constant value for <c>selector</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enterOne) p(enterOne) factor(enterOne,selector,value,index)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterOne"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enterOne,selector,value,index))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.EnterOneAverageLogarithm``1(``0)">
            <summary>VMP message to <c>enterOne</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>The outgoing VMP message to the <c>enterOne</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enterOne</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(enterOne,selector,value,index)]</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the incoming message from <c>value</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.SelectorAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.ValueAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enterOne">Incoming message from <c>enterOne</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enterOne</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(selector) p(selector) log(sum_enterOne p(enterOne) factor(enterOne,selector,value,index)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enterOne"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOp`1">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Int32,``0)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Boolean,``0)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GateEnterOp`1.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enter,selector,value))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enter,selector,value))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.EnterAverageConditional``2(``0,``1)">
            <summary>EP message to <c>enter</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enter</c> as the random arguments are varied. The formula is <c>proj[p(enter) sum_(value) p(value) factor(enter,selector,value)]/p(enter)</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.EnterInit``2(MicrosoftResearch.Infer.Distributions.Discrete,``0,MicrosoftResearch.Infer.Collections.IArrayFactory{``0,``1})">
            <summary>Initialize the buffer <c>enter</c>.</summary><param name="selector">Incoming message from <c>selector</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="factory"/><returns>Initial value of buffer <c>enter</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TValue">The type of the incoming message from <c>value</c>.</typeparam>
            <typeparam name="TArray">The type of an array that can be produced by <paramref name="factory"/>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,``0,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enter,selector) p(enter,selector) factor(enter,selector,value)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.ValueAverageConditional``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Constant value for <c>selector</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enter) p(enter) factor(enter,selector,value)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enter,selector,value))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.EnterAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>enter</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enter</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(enter,selector,value)]</c>.</para>
      </remarks>
            <typeparam name="TValue">The type of the message from <c>value</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.SelectorAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>selector</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>selector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="selector">Incoming message from <c>selector</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>value</c>. Because the factor is deterministic, <c>enter</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(selector) p(selector) log(sum_enter p(enter) factor(enter,selector,value)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable entering the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExitingVariableOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0@)"/>, given random arguments to the function.</summary>
            <remarks><para>
            This factor is like <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)"/> except <c>Uses[0]</c> plays the role of <c>Def</c>,
            and <c>Def</c> is considered a <c>Use</c>. Needed only when a variable exits a gate in VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Use,Def,Marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.MarginalAverageLogarithm``1(``0)">
            <summary>VMP message to <c>Marginal</c>.</summary><param name="Use">Incoming message from <c>Use</c>.</param><returns>The outgoing VMP message to the <c>Marginal</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Marginal</c> with <c>Use</c> integrated out. The formula is <c>sum_Use p(Use) factor(Use,Def,Marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.MarginalAverageLogarithmInit``1(``0)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.UseAverageLogarithm``1(``0)">
            <summary>VMP message to <c>Use</c>.</summary><param name="Def">Incoming message from <c>Def</c>.</param><returns>The outgoing VMP message to the <c>Use</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Use</c> as the random arguments are varied. The formula is <c>proj[sum_(Def) p(Def) factor(Use,Def,Marginal)]</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.DefAverageLogarithm``1(``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="Use">Incoming message from <c>Use</c>.</param><returns>The outgoing VMP message to the <c>Def</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> with <c>Use</c> integrated out. The formula is <c>sum_Use p(Use) factor(Use,Def,Marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateExitingOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ReplicateExiting``1(``0,System.Int32)"/>, given random arguments to the function.</summary>
            <remarks><para>
            This factor is like <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/> except <c>Uses[0]</c> plays the role of <c>Def</c>,
            and <c>Def</c> is considered a <c>Use</c>. Needed only when a variable exits a gate in VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Uses,Def,count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>VMP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[sum_(Def) p(Def) factor(Uses,Def,count)]</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.UsesAverageLogarithmInit``1(``0,System.Int32)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> with <c>Uses</c> integrated out. The formula is <c>sum_Uses p(Uses) factor(Uses,Def,count)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.LogEvidenceRatio``1(``0,System.Collections.Generic.IList{System.Boolean})">
            <summary>Evidence message for EP.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exit,cases) p(exit,cases) factor(exit,cases,values) / sum_exit p(exit) messageTo(exit))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.LogEvidenceRatio``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>Evidence message for EP.</summary><param name="exit">Incoming message from <c>exit</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>.</param><param name="to_exit">Outgoing message to <c>exit</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(exit,cases,values) p(exit,cases,values) factor(exit,cases,values) / sum_exit p(exit) messageTo(exit))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exit"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ValuesAverageConditional``2(``0,``1)">
            <summary>EP message to <c>values</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>values</c> as the random arguments are varied. The formula is <c>proj[p(values) sum_(exit) p(exit) factor(exit,cases,values)]/p(values)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the message from <c>exit</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageConditional``2(``0,System.Collections.Generic.IList{``0},``1)">
            <summary>EP message to <c>cases</c>.</summary><param name="exit">Incoming message from <c>exit</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="values">Incoming message from <c>values</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cases</c> as the random arguments are varied. The formula is <c>proj[p(cases) sum_(exit,values) p(exit,values) factor(exit,cases,values)]/p(cases)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exit"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TBernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional``1(``0,System.Collections.Generic.IList{System.Boolean},System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional1``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional2``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageConditional``2(``0,System.Collections.Generic.IList{`0},``1)">
            <summary>EP message to <c>cases</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="values">Incoming message from <c>values</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>cases</c> as the random arguments are varied. The formula is <c>proj[p(cases) sum_(exit,values) p(exit,values) factor(exit,cases,values)]/p(cases)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TBernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{`0},``0)">
            <summary>EP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditionalInit``1(System.Collections.Generic.IList{``0})">
            <summary/><param name="values">Incoming message from <c>values</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.AverageLogFactor``1(``0,``0)">
            <summary>Evidence message for VMP.</summary><param name="exit">Incoming message from <c>exit</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_exit">Outgoing message to <c>exit</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exit"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ValuesAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>values</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>values</c> with <c>exit</c> integrated out. The formula is <c>sum_exit p(exit) factor(exit,cases,values)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the message from <c>exit</c>.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageLogarithm``2(``0,System.Collections.Generic.IList{``0},``1)">
            <summary>VMP message to <c>cases</c>.</summary><param name="exit">Incoming message from <c>exit</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>cases</c>. Because the factor is deterministic, <c>exit</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(values) p(values) log(sum_exit p(exit) factor(exit,cases,values)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exit"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TBernoulliList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Boolean},System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>exit</c>.</summary><param name="exit">Incoming message from <c>exit</c>.</param><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[sum_(cases,values) p(cases,values) factor(exit,cases,values)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>exit</c>.</summary><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exit</c> as the random arguments are varied. The formula is <c>proj[sum_(cases,values) p(cases,values) factor(exit,cases,values)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageLogarithmInit``1(System.Collections.Generic.IList{``0})">
            <summary/><param name="values">Incoming message from <c>values</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitTwoOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageConditional``2(``0,``1)">
            <summary>EP message to <c>values</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>values</c> as the random arguments are varied. The formula is <c>proj[p(values) sum_(exitTwo) p(exitTwo) factor(exitTwo,case0,case1,values)]/p(values)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exitTwo"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>EP message to <c>case0</c>.</summary><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>case0</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case0</c> as the random arguments are varied. The formula is <c>proj[p(case0) sum_(values) p(values) factor(exitTwo,case0,case1,values)]/p(case0)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>EP message to <c>case1</c>.</summary><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>case1</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case1</c> as the random arguments are varied. The formula is <c>proj[p(case1) sum_(values) p(values) factor(exitTwo,case0,case1,values)]/p(case1)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>exitTwo</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exitTwo</c> as the random arguments are varied. The formula is <c>proj[p(exitTwo) sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]/p(exitTwo)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>EP message to <c>case0</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="values">Incoming message from <c>values</c>.</param><returns>The outgoing EP message to the <c>case0</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case0</c> as the random arguments are varied. The formula is <c>proj[p(case0) sum_(exitTwo,values) p(exitTwo,values) factor(exitTwo,case0,case1,values)]/p(case0)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TExitDomain">The domain of the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>EP message to <c>case1</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="values">Incoming message from <c>values</c>.</param><returns>The outgoing EP message to the <c>case1</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>case1</c> as the random arguments are varied. The formula is <c>proj[p(case1) sum_(exitTwo,values) p(exitTwo,values) factor(exitTwo,case0,case1,values)]/p(case1)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TExitDomain">The domain of the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``2(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``1},``0)">
            <summary>EP message to <c>exitTwo</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="values">Incoming message from <c>values</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exitTwo</c> as the random arguments are varied. The formula is <c>proj[p(exitTwo) sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]/p(exitTwo)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TExitDomain">The domain of the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>Evidence message for VMP.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="values">Incoming message from <c>values</c>.</param><param name="to_exitTwo">Outgoing message to <c>exitTwo</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>values</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>values</c> with <c>exitTwo</c> integrated out. The formula is <c>sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="exitTwo"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>VMP message to <c>case0</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>case0</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case0</c>. Because the factor is deterministic, <c>exitTwo</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(values) p(values) log(sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>VMP message to <c>case1</c>.</summary><param name="exitTwo">Incoming message from <c>exitTwo</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>case1</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>case1</c>. Because the factor is deterministic, <c>exitTwo</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(values) p(values) log(sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>exitTwo</c>.</summary><param name="case0">Incoming message from <c>case0</c>.</param><param name="case1">Incoming message from <c>case1</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>exitTwo</c> as the random arguments are varied. The formula is <c>proj[sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitRandomOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Exit,cases,values))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageConditional``1(``0,``0[])">
            <summary>EP message to <c>values</c>.</summary><param name="exit">Incoming message from <c>Exit</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>values</c> as the random arguments are varied. The formula is <c>proj[p(values) sum_(Exit) p(Exit) factor(Exit,cases,values)]/p(values)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageConditional``2(``0,``1)">
            <summary>EP message to <c>values</c>.</summary><param name="exit">Incoming message from <c>Exit</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>values</c> as the random arguments are varied. The formula is <c>proj[p(values) sum_(Exit) p(Exit) factor(Exit,cases,values)]/p(values)</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.CasesAverageConditional``1(``0)">
            <summary>EP message to <c>cases</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>cases</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageConditional``1(System.Boolean[],System.Collections.Generic.IList{``0})">
            <summary>EP message to <c>Exit</c>.</summary><param name="cases">Constant value for <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Exit</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Exit</c> as the random arguments are varied. The formula is <c>proj[p(Exit) sum_(values) p(values) factor(Exit,cases,values)]/p(Exit)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Exit,cases,values))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>VMP message to <c>values</c>.</summary><param name="exit">Incoming message from <c>Exit</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>values</c>. The formula is <c>exp(sum_(Exit) p(Exit) log(factor(Exit,cases,values)))</c>.</para>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.CasesAverageLogarithm``1(``0)">
            <summary>VMP message to <c>cases</c>.</summary><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>cases</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TResultList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>Exit</c>.</summary><param name="cases">Incoming message from <c>cases</c>.</param><param name="values">Incoming message from <c>values</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Exit</c>. The formula is <c>exp(sum_(cases,values) p(cases,values) log(factor(Exit,cases,values)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="values"/> is not a proper distribution.</exception>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageLogarithmInit``1(System.Collections.Generic.IList{``0})">
            <summary/><param name="values">Incoming message from <c>values</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TExit">The type of the distribution over the variable exiting the gate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GaussianFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,variance))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,variance))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,variance)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,variance) p(sample,mean,variance) factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,variance) p(sample,mean,variance) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(variance) p(variance) factor(sample,mean,variance)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LaplacianTimesGaussianMoments(System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Compute moments of 0.5*exp(-abs(x))*N(x;m,v)
            </summary>
            <param name="m"></param>
            <param name="v"></param>
            <param name="logZ"></param>
            <param name="mu"></param>
            <param name="vu"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean,variance) p(mean,variance) factor(sample,mean,variance)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.InterpolateBesselKMoment(System.Double,System.Double[])">
            <summary>
            Approximate a moment of VG(x;a) by interpolating its values for integer shapes
            </summary>
            <param name="a">The starting integer shape</param>
            <param name="binomt">The exact moment for integer shapes starting at <paramref name="a"/></param>
            <returns>The interpolated moment</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalCdfMomentRatios(System.Int32,System.Double,System.Double)">
            <summary>
            Computes int_0^Inf x^n N(x;m,v) dx / N(m/sqrt(v);0,1)
            </summary>
            <param name="nMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalCdfMoments(System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m,v) dx for all integer n from 0 to nMax.  Loses accuracy if m &lt; -1.
            </summary>
            <param name="nMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalVGMoments(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m+v,v) VG(x;a) dx *2*exp(m+v/2).  Loses accuracy if m &lt; -1.
            </summary>
            <param name="nMax"></param>
            <param name="aMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns>NormalVGMoment[a][n] where a ranges from 1 to aMax, n ranges from 0 to nMax+aMax-a</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalVGMomentRatios(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m+v,v) VG(x;a) dx *2*exp(m+v/2)/N(m/sqrt(v);0,1)
            </summary>
            <param name="nMax"></param>
            <param name="aMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns>NormalVGMoment[a][n] where a ranges from 1 to aMax, n ranges from 0 to nMax+aMax-a</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,variance)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(variance) p(variance) factor(sample,mean,variance)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample,variance) p(sample,variance) factor(sample,mean,variance)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>variance</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing EP message to the <c>variance</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>variance</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>variance</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>variance</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>variance</c> as the random arguments are varied. The formula is <c>proj[p(variance) sum_(mean) p(mean) factor(sample,mean,variance)]/p(variance)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>variance</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>variance</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>variance</c> as the random arguments are varied. The formula is <c>proj[p(variance) sum_(sample) p(sample) factor(sample,mean,variance)]/p(variance)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>variance</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>variance</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>variance</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>variance</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Incoming message from <c>variance</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>variance</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>variance</c> as the random arguments are varied. The formula is <c>proj[p(variance) sum_(sample,mean) p(sample,mean) factor(sample,mean,variance)]/p(variance)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variance"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceGammaTimesGaussianIntegral(System.Double,System.Double,System.Double)">
            <summary>
            Compute int_{-Inf}^{Inf} N(x;m,v) VG(x;a) dx * 2/N(m/sqrt(v);0,1)
            </summary>
            <param name="a"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,variance)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,variance)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOpBase">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.SampleAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.MeanAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.PrecisionAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>precision</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing EP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.TPdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of Student T density.
            </summary>
            <param name="x">sample</param>
            <param name="v">variance parameter</param>
            <param name="n">degrees of freedom plus 1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogFactorValue(System.Double,System.Double,System.Double)">
            <summary>Evidence message for Gibbs.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's value at the given arguments.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodeCount">
            <summary>
            Number of quadrature nodes to use for computing the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(precision) p(precision) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(precision) p(precision) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precision</c> as the random arguments are varied. The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.GammaFromAlphaBeta(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double,System.Boolean)">
            <summary>
            Gamma message computed directly from prior and expected derivatives of factor
            </summary>
            <param name="prior"></param>
            <param name="alpha">Exf'/Ef = -b dlogZ/db</param>
            <param name="beta">(Exf' + Ex^2f'')/Ef - alpha^2 = -b dalpha/db</param>
            <param name="forceProper"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodesAndWeights(MicrosoftResearch.Infer.Distributions.Gamma,System.Double[],System.Double[])">
            <summary>
            Quadrature nodes for Gamma expectations
            </summary>
            <param name="precision">'precision' message</param>
            <param name="nodes">Place to put the nodes</param>
            <param name="logWeights">Place to put the log-weights</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>precision</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing VMP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing VMP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>precision</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean,precision) p(sample,mean,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(precision) p(precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp_Slow">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precision</c> as the random arguments are varied. The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.FindZeroes(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Find all zeroes of a function, given its stationary points and inflection points 
            </summary>
            <param name="func"></param>
            <param name="deriv"></param>
            <param name="stationaryPoints"></param>
            <param name="inflectionPoints"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.GetRoots(System.Collections.Generic.IList{System.Double},System.Double[]@,System.Double[]@)">
            <summary>
            Get the complex roots of a polynomial
            </summary>
            <param name="coeffs">Coefficients of the polynomial, starting from the highest degree monomial down to the constant term</param>
            <param name="rootsReal">On exit, the real part of the roots</param>
            <param name="rootsImag">On exit, the imaginary part of the roots</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.GetRealRoots(System.Collections.Generic.IList{System.Double},System.Collections.Generic.List{System.Double}@,System.Predicate{System.Double})">
            <summary>
            Get the real roots of a polynomial
            </summary>
            <param name="coeffs">Coefficients of the polynomial, starting from the highest degree monomial down to the constant term</param>
            <param name="roots">On exit, the real roots</param>
            <param name="filter">If not null, only roots where filter returns true are included</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.LaplaceMoments(MicrosoftResearch.Infer.Distributions.Gamma,System.Double[],System.Double[],System.Double@,System.Double@)">
            <summary>
            Approximate the mean and variance of a function g(x) where x is distributed according to a Gamma times f(x).
            </summary>
            <param name="q">The Gamma distribution that multiplies f</param>
            <param name="g">g[0] = g(xhat), g[1] = g'(xhat), g[2] = g''(xhat), and so on.</param>
            <param name="dlogf">dlogf[0] = (logf)'(xhat), dlogf[1] = (logf)''(xhat), and so on.</param>
            <param name="m"></param>
            <param name="v"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.QInit">
            <summary>Initialize the buffer <c>Q</c>.</summary><returns>Initial value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.Q(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Update the buffer <c>Q</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>New value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.dlogfs(System.Double,System.Double,System.Double)">
            <summary>
            Derivatives of the factor wrt precision
            </summary>
            <param name="x"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.xdlogfs(System.Double,System.Double,System.Double)">
            <summary>
            Derivatives of the factor wrt precision, times powers of x
            </summary>
            <param name="x"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>precision</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precision</c> as the random arguments are varied. The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItem2DOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="to_item">Outgoing message to <c>item</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index1,index2))</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogAverageFactor``1(`0,MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index1,index2))</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(``0)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index1,index2) / sum_item p(item) messageTo(item))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(`0,MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index1,index2) / sum_item p(item) messageTo(item))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageConditional``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>EP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index1,index2)]/p(item)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(``0,System.Int32,System.Int32,``1)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index1,index2)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(`0,System.Int32,System.Int32,``1)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index1,index2)]/p(array)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(item,array,index1,index2))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageLogarithm``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>VMP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(item,array,index1,index2)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(``0,System.Int32,System.Int32,``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>item</c> integrated out. The formula is <c>sum_item p(item) factor(item,array,index1,index2)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(`0,System.Int32,System.Int32,``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="index1">Constant value for <c>index1</c>.</param><param name="index2">Constant value for <c>index2</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>item</c> integrated out. The formula is <c>sum_item p(item) factor(item,array,index1,index2)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogAverageFactor(`0,System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio(`0,System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index) / sum_item p(item) messageTo(item))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.AverageLogFactor(`0,System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="to_item">Outgoing message to <c>item</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index))</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogAverageFactor``1(`0,System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index))</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio``1(``0)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index) / sum_item p(item) messageTo(item))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio``1(`0,System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(item,array) p(item,array) factor(item,array,index) / sum_item p(item) messageTo(item))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageConditional``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>EP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index)]/p(item)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageConditionalInit``1(System.Collections.Generic.IList{``0})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(``0,System.Int32,``1)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(`0,System.Int32,``1)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index)]/p(array)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(item,array,index))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>VMP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(item,array,index)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageLogarithmInit``1(System.Collections.Generic.IList{``0})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(``0,System.Int32,``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>item</c> integrated out. The formula is <c>sum_item p(item) factor(item,array,index)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(`0,System.Int32,``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>item</c> integrated out. The formula is <c>sum_item p(item) factor(item,array,index)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over an item.</typeparam>
            <typeparam name="DistributionArray">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for VMP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{``0})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="to_items">Previous outgoing message to <c>items</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.MarginalInit``1(``0)">
            <summary>Initialize the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Initial value of buffer <c>marginal</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="ArrayType">The type of an array for the marginal.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.Marginal``2(``0,System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Int32},``0)">
            <summary>Update the buffer <c>marginal</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of an array for the marginal.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.MarginalIncrement``2(``0,``1,``1,System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary/><param name="result">Modified to contain the outgoing message.</param><param name="to_item"/><param name="item"/><param name="indices">Constant value for <c>indices</c>.</param><param name="resultIndex">Index of the <c>marginal</c> for which a message is desired.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of an array for the marginal.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageConditional``2(``1,``0,``0,System.Collections.Generic.IList{System.Int32},System.Int32,``1)">
            <summary>EP message to <c>items</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="resultIndex">Index of the <c>items</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.</para>
      </remarks>
            <typeparam name="ArrayType">The type of an array for the marginal and the result.</typeparam>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Int32,``0)">
            <summary>VMP message to <c>items</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="resultIndex">Index of the <c>items</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(items,array,indices)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageLogarithmInit``1(MicrosoftResearch.Infer.Distributions.DistributionStructArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageLogarithmInit``1(MicrosoftResearch.Infer.Distributions.DistributionRefArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>items</c> integrated out. The formula is <c>sum_items p(items) factor(items,array,indices)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the resulting array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>items</c> integrated out. The formula is <c>sum_items p(items) factor(items,array,indices)</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
            <typeparam name="ArrayType">The type of the resulting array.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsOp2`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of a list element.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditionalInit``1(MicrosoftResearch.Infer.Distributions.DistributionStructArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditionalInit``1(MicrosoftResearch.Infer.Distributions.DistributionRefArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditional2``1(``0,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Int32,``0)">
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditional``1(``0,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Int32,``0)">
            <summary>EP message to <c>items</c>.</summary><param name="partial">Buffer <c>partial</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="resultIndex">Index of the <c>items</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ArrayIncrement``1(``0,``0,``0)">
            <summary/><param name="partial">Buffer <c>partial</c>.</param><param name="item"/><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.PartialInit``1(``0)">
            <summary>Initialize the buffer <c>partial</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><returns>Initial value of buffer <c>partial</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="ArrayType">The type of a distribution array.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.Partial``1(``0,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Int32,``0)">
            <summary>Update the buffer <c>partial</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="to_array">Outgoing message to <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="resultIndex">Index of the <c>partial</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over array elements.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InnerProductOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Maths.Vector.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(innerProduct,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>innerProduct</c>.</summary><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>The outgoing VMP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>innerProduct</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>innerProduct</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>The outgoing VMP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>innerProduct</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>innerProduct</c>.</summary><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>innerProduct</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>BVariance</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>Initial value of buffer <c>BVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>BVariance</c>.</summary><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>BMean</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>Initial value of buffer <c>BMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>BMean</c>.</summary><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>AVariance</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><returns>Initial value of buffer <c>AVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>AVariance</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>AMean</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><returns>Initial value of buffer <c>AMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>AMean</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>innerProduct</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_innerProduct p(innerProduct) factor(innerProduct,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(innerProduct,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>innerProduct</c> integrated out. The formula is <c>sum_innerProduct p(innerProduct) factor(innerProduct,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>innerProduct</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_innerProduct p(innerProduct) factor(innerProduct,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(innerProduct,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>innerProduct</c> integrated out. The formula is <c>sum_innerProduct p(innerProduct) factor(innerProduct,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>innerProduct</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>innerProduct</c> as the random arguments are varied. The formula is <c>proj[p(innerProduct) sum_(a,b) p(a,b) factor(innerProduct,a,b)]/p(innerProduct)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(innerProduct,b) p(innerProduct,b) factor(innerProduct,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(innerProduct,a) p(innerProduct,a) factor(innerProduct,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>innerProduct</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>The outgoing EP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>innerProduct</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>innerProduct</c>.</summary><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>innerProduct</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>innerProduct</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="innerProduct"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(innerProduct,a,b) p(innerProduct,a,b) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(innerProduct,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(innerProduct,b) p(innerProduct,b) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(innerProduct,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(innerProduct,a) p(innerProduct,a) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(innerProduct,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(innerProduct,a,b) p(innerProduct,a,b) factor(innerProduct,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(innerProduct,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Incoming message from <c>innerProduct</c>.</param><param name="to_innerProduct">Outgoing message to <c>innerProduct</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(innerProduct,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="innerProduct">Constant value for <c>innerProduct</c>.</param><param name="AMean">Buffer <c>AMean</c>.</param><param name="AVariance">Buffer <c>AVariance</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(innerProduct,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,System.Double)">
            <summary>EP message to <c>lowerBound</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>The outgoing EP message to the <c>lowerBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>lowerBound</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,System.Double)">
            <summary>EP message to <c>upperBound</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>The outgoing EP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>upperBound</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be negative infinity.</param>
            <param name="U">Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>EP message to <c>isBetween</c>.</summary><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>The outgoing EP message to the <c>isBetween</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isBetween</c> as the random arguments are varied. The formula is <c>proj[p(isBetween) sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isBetween) p(isBetween) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isBetween"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be uniform.  Can be negative infinity.</param>
            <param name="U">Can be uniform.  Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogZInit">
            <summary>Initialize the buffer <c>logZ</c>.</summary><returns>Initial value of buffer <c>logZ</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogZ(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Update the buffer <c>logZ</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>New value of buffer <c>logZ</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isBetween,x,lowerBound,upperBound) p(isBetween,x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><param name="logZ">Buffer <c>logZ</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isBetween,x,lowerBound,upperBound) p(isBetween,x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>isBetween</c>.</summary><param name="X">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="upperBound">Incoming message from <c>upperBound</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>isBetween</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isBetween</c> as the random arguments are varied. The formula is <c>proj[p(isBetween) sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="X"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="lowerBound"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="upperBound"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>lowerBound</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><param name="logZ">Buffer <c>logZ</c>.</param><returns>The outgoing EP message to the <c>lowerBound</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>lowerBound</c> as the random arguments are varied. The formula is <c>proj[p(lowerBound) sum_(isBetween,x,upperBound) p(isBetween,x,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isBetween"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>upperBound</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><param name="logZ">Buffer <c>logZ</c>.</param><returns>The outgoing EP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>upperBound</c> as the random arguments are varied. The formula is <c>proj[p(upperBound) sum_(isBetween,x,lowerBound) p(isBetween,x,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isBetween"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><param name="logZ">Buffer <c>logZ</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isBetween,lowerBound,upperBound) p(isBetween,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isBetween"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>isBetween</c>.</summary><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>The outgoing VMP message to the <c>isBetween</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isBetween</c> as the random arguments are varied. The formula is <c>proj[sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>x</c>. Because the factor is deterministic, <c>isBetween</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(lowerBound,upperBound) p(lowerBound,upperBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>lowerBound</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>The outgoing VMP message to the <c>lowerBound</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>lowerBound</c>. Because the factor is deterministic, <c>isBetween</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(x,upperBound) p(x,upperBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>upperBound</c>.</summary><param name="isBetween">Incoming message from <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Incoming message from <c>lowerBound</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>The outgoing VMP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>upperBound</c>. Because the factor is deterministic, <c>isBetween</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(x,lowerBound) p(x,lowerBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>Evidence message for VMP.</summary><param name="X">Incoming message from <c>x</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double,System.Double)">
            <summary>VMP message to <c>x</c>.</summary><param name="isBetween">Constant value for <c>isBetween</c>.</param><param name="X">Incoming message from <c>x</c>.</param><param name="lowerBound">Constant value for <c>lowerBound</c>.</param><param name="upperBound">Constant value for <c>upperBound</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageLogarithm">
            <summary>VMP message to <c>lowerBound</c>.</summary><returns>The outgoing VMP message to the <c>lowerBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>lowerBound</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageLogarithm">
            <summary>VMP message to <c>upperBound</c>.</summary><returns>The outgoing VMP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>upperBound</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsGreaterThanOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsGreaterThan(System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
            <remarks>A and B need not have the same dimension.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="to_isGreaterThan">Outgoing message to <c>isGreaterThan</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isGreaterThan,a) p(isGreaterThan,a) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="to_isGreaterThan">Outgoing message to <c>isGreaterThan</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isGreaterThan,b) p(isGreaterThan,b) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b) / sum_isGreaterThan p(isGreaterThan) messageTo(isGreaterThan))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(isGreaterThan,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(isGreaterThan,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(isGreaterThan,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(isGreaterThan,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(a,b) p(a,b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(isGreaterThan,b) p(isGreaterThan,b) factor(isGreaterThan,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="b">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(isGreaterThan,a) p(isGreaterThan,a) factor(isGreaterThan,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>b</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Binomial,System.Int32)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Binomial)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,System.Int32)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>isGreaterThan</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[p(isGreaterThan) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Poisson,System.Int32)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>isGreaterThan</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(isGreaterThan,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>VMP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(isGreaterThan,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>isGreaterThan</c>.</summary><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>isGreaterThan</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isGreaterThan</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(isGreaterThan,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>isGreaterThan</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>isGreaterThan</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>isGreaterThan</c> integrated out. The formula is <c>sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="isGreaterThan">Incoming message from <c>isGreaterThan</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>isGreaterThan</c> integrated out. The formula is <c>sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isGreaterThan"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(isGreaterThan,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(isGreaterThan,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>a</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="b">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>VMP message to <c>b</c>.</summary><param name="isGreaterThan">Constant value for <c>isGreaterThan</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsPositiveOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isPositive,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isPositive,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(System.Boolean,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(isPositive,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(isPositive,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Incoming message from <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isPositive,x) p(isPositive,x) factor(isPositive,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Incoming message from <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(isPositive,x) p(isPositive,x) factor(isPositive,x) / sum_isPositive p(isPositive) messageTo(isPositive))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(isPositive,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>isPositive</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>isPositive</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isPositive</c> as the random arguments are varied. The formula is <c>proj[p(isPositive) sum_(x) p(x) factor(isPositive,x)]/p(isPositive)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Incoming message from <c>isPositive</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isPositive"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Incoming message from <c>isPositive</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Constant value for <c>x</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isPositive"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="isPositive">Incoming message from <c>isPositive</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>isPositive</c> integrated out. The formula is <c>sum_isPositive p(isPositive) factor(isPositive,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isPositive"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="isPositive">Incoming message from <c>isPositive</c>.</param><param name="X">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="X"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(System.Boolean)">
            <summary>VMP message to <c>x</c>.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(System.Boolean)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Constant value for <c>isPositive</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Incoming message from <c>isPositive</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isPositive"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>isPositive</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>isPositive</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>isPositive</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(isPositive,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor_helper(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>Evidence message for VMP.</summary><param name="X">Incoming message from <c>x</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsPositiveOp_Proper">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp_Proper.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>x</c>.</summary><param name="isPositive">Incoming message from <c>isPositive</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="isPositive"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogOp_EP">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Log(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(log,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(log,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.AverageLogFactor(System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(log,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Incoming message from <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(d) p(d) factor(log,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="log">Incoming message from <c>log</c>.</param><param name="d">Constant value for <c>d</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(log) p(log) factor(log,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="log">Incoming message from <c>log</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_log">Outgoing message to <c>log</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(log,d) p(log,d) factor(log,d))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="log">Incoming message from <c>log</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_log">Outgoing message to <c>log</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(log,d) p(log,d) factor(log,d) / sum_log p(log) messageTo(log))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Incoming message from <c>d</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(d) p(d) factor(log,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>d</c>.</summary><param name="log">Incoming message from <c>log</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>.</param><param name="to_log">Previous outgoing message to <c>log</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>d</c> as the random arguments are varied. The formula is <c>proj[p(d) sum_(log) p(log) factor(log,d)]/p(d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="log"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.DAverageConditional(System.Double)">
            <summary>EP message to <c>d</c>.</summary><param name="log">Constant value for <c>log</c>.</param><returns>The outgoing EP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageConditional(System.Double)">
            <summary>EP message to <c>log</c>.</summary><param name="d">Constant value for <c>d</c>.</param><returns>The outgoing EP message to the <c>log</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>log</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>log</c>.</summary><param name="log">Incoming message from <c>log</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>log</c> as the random arguments are varied. The formula is <c>proj[p(log) sum_(d) p(d) factor(log,d)]/p(log)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="log"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogOp_VMP">
            <summary>Provides outgoing messages for <see cref="M:System.Math.Log(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.LogOp_VMP.damping">
            <summary>
            Determines the amount of damping to use on the VMP updates for D. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>log</c>.</summary><param name="log">Incoming message from <c>log</c>.</param><param name="d">Constant value for <c>d</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>log</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>d</c>.</summary><param name="log">Constant value for <c>log</c>.</param><param name="d">Incoming message from <c>d</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>log</c>.</summary><param name="log">Incoming message from <c>log</c>.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>log</c> as the random arguments are varied. The formula is <c>proj[sum_(d) p(d) factor(log,d)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>d</c>.</summary><param name="log">Incoming message from <c>log</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="d">Incoming message from <c>d</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_D">Previous outgoing message to <c>D</c>.</param><returns>The outgoing VMP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> with <c>log</c> integrated out. The formula is <c>sum_log p(log) factor(log,d)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="log"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="d"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(log,d))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(System.Double)">
            <summary>VMP message to <c>log</c>.</summary><param name="d">Constant value for <c>d</c>.</param><returns>The outgoing VMP message to the <c>log</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>log</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(System.Double)">
            <summary>VMP message to <c>d</c>.</summary><param name="log">Constant value for <c>log</c>.</param><returns>The outgoing VMP message to the <c>d</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>d</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(logistic,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(logistic,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.AverageLogFactor(System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(logistic,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>Evidence message for EP.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(logistic) p(logistic) factor(logistic,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(logistic,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x) p(x) factor(logistic,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="falseMsg">Buffer <c>falseMsg</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(logistic,x) p(logistic,x) factor(logistic,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for EP.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>.</param><param name="falseMsg">Buffer <c>falseMsg</c>.</param><param name="to_logistic">Outgoing message to <c>logistic</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(logistic,x) p(logistic,x) factor(logistic,x) / sum_logistic p(logistic) messageTo(logistic))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>logistic</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="falseMsg">Buffer <c>falseMsg</c>.</param><returns>The outgoing EP message to the <c>logistic</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>logistic</c> as the random arguments are varied. The formula is <c>proj[p(logistic) sum_(x) p(x) factor(logistic,x)]/p(logistic)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.BetaFromMeanAndIntegral(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find a Beta distribution with given integral and mean times a Beta weight function.
            </summary>
            <param name="mean">The desired value of the mean</param>
            <param name="logZ">The desired value of the integral</param>
            <param name="a">trueCount-1 of the weight function</param>
            <param name="b">falseCount-1 of the weight function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(System.Double)">
            <summary>EP message to <c>x</c>.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.FalseMsgInit">
            <summary>Initialize the buffer <c>falseMsg</c>.</summary><returns>Initial value of buffer <c>falseMsg</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.FalseMsg(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Update the buffer <c>falseMsg</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="falseMsg">Buffer <c>falseMsg</c>.</param><returns>New value of buffer <c>falseMsg</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logistic"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>x</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="falseMsg">Buffer <c>falseMsg</c>.</param><returns>The outgoing EP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>x</c> as the random arguments are varied. The formula is <c>proj[p(x) sum_(logistic) p(logistic) factor(logistic,x)]/p(x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logistic"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="to_logistic">Previous outgoing message to <c>logistic</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>logistic</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>logistic</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>logistic</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_X">Previous outgoing message to <c>X</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>logistic</c> integrated out. The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logistic"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageLogarithm(System.Double)">
            <summary>VMP message to <c>x</c>.</summary><param name="logistic">Constant value for <c>logistic</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            Uses the Jaakkola and Jordan (1996) bound.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>Evidence message for VMP.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_logistic">Previous outgoing message to <c>logistic</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>logistic</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>logistic</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>logistic</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>x</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>logistic</c> integrated out. The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logistic"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            Uses the Saul and Jordan (1999) bound
            \langle log(1+exp(x)) \rangle \leq a^2*v/2 + log(1+exp(m+(1-2a)v/2))
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="logistic">Incoming message from <c>logistic</c>.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_logistic">Previous outgoing message to <c>logistic</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.AInit">
            <summary>Initialize the buffer <c>A</c>.</summary><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.A(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>logistic</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>The outgoing VMP message to the <c>logistic</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>logistic</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.LogisticInit">
            <summary>Initialize the buffer <c>logistic</c>.</summary><returns>Initial value of buffer <c>logistic</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.XInit">
            <summary>Initialize the buffer <c>x</c>.</summary><returns>Initial value of buffer <c>x</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>x</c>.</summary><param name="logistic">Incoming message from <c>logistic</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>logistic</c> integrated out. The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="logistic"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(matrixMultiply,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>matrixMultiply</c>.</summary><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(matrixMultiply,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="A">Incoming message from <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithmInit(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},System.Double[0:,0:])">
            <summary/><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>matrixMultiply</c>.</summary><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[sum_(B) p(B) factor(matrixMultiply,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>matrixMultiply</c>.</summary><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[sum_(A) p(A) factor(matrixMultiply,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>A</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>matrixMultiply</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>A</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> with <c>matrixMultiply</c> integrated out. The formula is <c>sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>B</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>matrixMultiply</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>VMP message to <c>B</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> with <c>matrixMultiply</c> integrated out. The formula is <c>sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(System.Double[0:,0:])">
            <summary>VMP message to <c>A</c>.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(System.Double[0:,0:])">
            <summary>VMP message to <c>B</c>.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>matrixMultiply</c>.</summary><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[p(matrixMultiply) sum_(A,B) p(A,B) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>A</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>B</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(matrixMultiply,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(matrixMultiply,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AverageLogFactor(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Evidence message for VMP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(matrixMultiply,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(matrixMultiply,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(matrixMultiply,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B) / sum_matrixMultiply p(matrixMultiply) messageTo(matrixMultiply))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B) / sum_matrixMultiply p(matrixMultiply) messageTo(matrixMultiply))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(matrixMultiply,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>Evidence message for EP.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Incoming message from <c>A</c>.</param><param name="B">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(matrixMultiply,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>matrixMultiply</c>.</summary><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[p(matrixMultiply) sum_(B) p(B) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>matrixMultiply</c>.</summary><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>matrixMultiply</c> as the random arguments are varied. The formula is <c>proj[p(matrixMultiply) sum_(A) p(A) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>A</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Incoming message from <c>A</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="B">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(matrixMultiply) p(matrixMultiply) factor(matrixMultiply,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>B</c>.</summary><param name="matrixMultiply">Incoming message from <c>matrixMultiply</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="A">Constant value for <c>A</c>.</param><param name="B">Incoming message from <c>B</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(matrixMultiply) p(matrixMultiply) factor(matrixMultiply,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="matrixMultiply"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>A</c>.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="B">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>EP message to <c>B</c>.</summary><param name="matrixMultiply">Constant value for <c>matrixMultiply</c>.</param><param name="A">Constant value for <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>BVariance</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>Initial value of buffer <c>BVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>BVariance</c>.</summary><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>BMean</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>Initial value of buffer <c>BMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>BMean</c>.</summary><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="to_product">Outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>product</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageConditionalInit(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary/><param name="A">Constant value for <c>a</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageLogarithmInit(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary/><param name="A">Constant value for <c>a</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="BMean">Buffer <c>BMean</c>.</param><param name="BVariance">Buffer <c>BVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>product</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MaxGaussianOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.MaxGaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(max,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(max,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(max,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,a,b) p(max,a,b) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,b) p(max,b) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,a) p(max,a) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(max,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,a,b) p(max,a,b) factor(max,a,b) / sum_max p(max) messageTo(max))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,b) p(max,b) factor(max,a,b) / sum_max p(max) messageTo(max))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(max,a) p(max,a) factor(max,a,b) / sum_max p(max) messageTo(max))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(max,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(max,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(max,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>max</c>.</summary><param name="max">Incoming message from <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>max</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>max</c> as the random arguments are varied. The formula is <c>proj[p(max) sum_(b) p(b) factor(max,a,b)]/p(max)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>max</c>.</summary><param name="max">Incoming message from <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>max</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>max</c> as the random arguments are varied. The formula is <c>proj[p(max) sum_(a) p(a) factor(max,a,b)]/p(max)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>max</c>.</summary><param name="max">Incoming message from <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>max</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>max</c> as the random arguments are varied. The formula is <c>proj[p(max) sum_(a,b) p(a,b) factor(max,a,b)]/p(max)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(max,b) p(max,b) factor(max,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(max,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(max) p(max) factor(max,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(max,a) p(max,a) factor(max,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(max,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="max">Incoming message from <c>max</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(max) p(max) factor(max,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="max"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="max">Constant value for <c>max</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MultinomialOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.MultinomialList(System.Int32,MicrosoftResearch.Infer.Maths.Vector)"/></description></item></list>, given random arguments to the function.</summary>
            <remarks>The factor is f(sample,p,n) = n!/prod_k sample[k]!  prod_k p[k]^sample[k]</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Discrete})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogAverageFactor(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogAverageFactor(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.PAverageConditional(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>EP message to <c>p</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing EP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>p</c> as the random arguments are varied. The formula is <c>proj[p(p) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(p)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.AverageLogFactor(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,p) p(sample,p) log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.MeanLog(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Update the buffer <c>MeanLog</c>.</summary><param name="p">Incoming message from <c>p</c>.</param><returns>New value of buffer <c>MeanLog</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.AverageLogFactor(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><param name="p">Incoming message from <c>p</c>.</param><param name="MeanLog">Buffer <c>MeanLog</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,p) p(sample,p) log(factor(sample,trialCount,p))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.PAverageLogarithm(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>VMP message to <c>p</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="trialCount">Constant value for <c>trialCount</c>.</param><returns>The outgoing VMP message to the <c>p</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>p</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,trialCount,p)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanNotOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="not">Constant value for <c>not</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(not,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="not">Constant value for <c>not</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(not,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.AverageLogFactor(System.Boolean,System.Boolean)">
            <summary>Evidence message for VMP.</summary><param name="not">Constant value for <c>not</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(not,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>not</c>.</summary><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>not</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>not</c> as the random arguments are varied. The formula is <c>proj[p(not) sum_(b) p(b) factor(not,b)]/p(not)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="not">Incoming message from <c>not</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(not) p(not) factor(not,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="not"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="not">Constant value for <c>not</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="not">Incoming message from <c>not</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="to_not">Outgoing message to <c>not</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(not,b) p(not,b) factor(not,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="not">Incoming message from <c>not</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(not) p(not) factor(not,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="not">Constant value for <c>not</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(not,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="not">Incoming message from <c>not</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(not) p(not) factor(not,b) / sum_not p(not) messageTo(not))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="not">Constant value for <c>not</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(not,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>not</c>.</summary><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>not</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>not</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(not,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="not">Incoming message from <c>not</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>not</c> integrated out. The formula is <c>sum_not p(not) factor(not,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="not"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="not">Constant value for <c>not</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(not,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanOrOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Evidence message for VMP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="or">Incoming message from <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>or</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[p(or) sum_(a,b) p(a,b) factor(or,a,b)]/p(or)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>or</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[p(or) sum_(b) p(b) factor(or,a,b)]/p(or)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>or</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[p(or) sum_(a) p(a) factor(or,a,b)]/p(or)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(or,b) p(or,b) factor(or,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>a</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(or,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(or) p(or) factor(or,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>a</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(or,a) p(or,a) factor(or,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(or) p(or) factor(or,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>EP message to <c>b</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(or,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>EP message to <c>b</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Incoming message from <c>or</c>.</param><param name="to_or">Outgoing message to <c>or</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(or,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Incoming message from <c>or</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b) / sum_or p(or) messageTo(or))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>Evidence message for EP.</summary><param name="or">Constant value for <c>or</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(or,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>or</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(or,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>or</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(or,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>or</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>or</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>or</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(or,a,b)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>or</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_or p(or) factor(or,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>or</c> integrated out. The formula is <c>sum_or p(or) factor(or,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>a</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(or,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>a</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>or</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_or p(or) factor(or,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="or">Incoming message from <c>or</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>or</c> integrated out. The formula is <c>sum_or p(or) factor(or,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="or"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>VMP message to <c>b</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(or,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>VMP message to <c>b</c>.</summary><param name="or">Constant value for <c>or</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntegerPlusOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Int32,System.Int32)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Int32,System.Int32)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum,A) p(Sum,A) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum,B) p(Sum,B) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B) / sum_Sum p(Sum) messageTo(Sum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A,B) p(A,B) factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,System.Int32,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary/><param name="a">Incoming message from <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditionalInit(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="b">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="b">Constant value for <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>A</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_a">Outgoing message to <c>a</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="to_b">Outgoing message to <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sum</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>A</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>A</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>A</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>A</c> as the random arguments are varied. The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>A</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing EP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>B</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>B</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>B</c> as the random arguments are varied. The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>B</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing EP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Incoming message from <c>Sum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B) / sum_Sum p(Sum) messageTo(Sum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><param name="to_b">Outgoing message to <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><param name="to_a">Outgoing message to <c>a</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="difference">Incoming message from <c>difference</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(difference) p(difference) factor(difference,a,b) / sum_difference p(difference) messageTo(difference))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="difference">Constant value for <c>difference</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(difference,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="difference">Constant value for <c>difference</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="to_a">Outgoing message to <c>a</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(difference,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="difference">Constant value for <c>difference</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="to_b">Outgoing message to <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(difference,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>Evidence message for VMP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A) p(A) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(B) p(B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>VMP message to <c>A</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>VMP message to <c>B</c>.</summary><param name="sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="sum">Incoming message from <c>Sum</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Sum,A,B))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(B) p(B) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Sum</c> as the random arguments are varied. The formula is <c>proj[sum_(A) p(A) factor(Sum,A,B)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>Sum</c>.</summary><param name="a">Constant value for <c>A</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>Sum</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Sum</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>A</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>.</param><param name="a_deriv"/><param name="to_a">Previous outgoing message to <c>a</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b_deriv"/><param name="to_b">Previous outgoing message to <c>b</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>A</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>A</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="b">Incoming message from <c>B</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>A</c>. The formula is <c>exp(sum_(B) p(B) log(factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>A</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>A</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="b">Constant value for <c>B</c>.</param><returns>The outgoing VMP message to the <c>A</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>A</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. Because the factor is deterministic, <c>Sum</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>B</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Incoming message from <c>A</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>B</c>. The formula is <c>exp(sum_(A) p(A) log(factor(Sum,A,B)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>B</c>.</summary><param name="Sum">Incoming message from <c>Sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> with <c>Sum</c> integrated out. The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>B</c>.</summary><param name="Sum">Constant value for <c>Sum</c>.</param><param name="a">Constant value for <c>A</c>.</param><returns>The outgoing VMP message to the <c>B</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>B</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(difference,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>difference</c>.</summary><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>difference</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>difference</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(difference,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>difference</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>difference</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>difference</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(difference,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>difference</c>.</summary><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>difference</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>difference</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(difference,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>difference</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>difference</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>difference</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="Difference">Incoming message from <c>difference</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>difference</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_difference p(difference) factor(difference,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Difference"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Difference">Incoming message from <c>difference</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>difference</c> integrated out. The formula is <c>sum_difference p(difference) factor(difference,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Difference"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="Difference">Constant value for <c>difference</c>.</param><param name="b">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(difference,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="b"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Difference">Constant value for <c>difference</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Difference">Incoming message from <c>difference</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>difference</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_difference p(difference) factor(difference,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Difference"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Difference">Incoming message from <c>difference</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="a">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>difference</c> integrated out. The formula is <c>sum_difference p(difference) factor(difference,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Difference"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Difference">Constant value for <c>difference</c>.</param><param name="a">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(difference,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="a"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Difference">Constant value for <c>difference</c>.</param><param name="a">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PoissonOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(System.Int32,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(System.Int32,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(System.Int32,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Poisson,System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_mean">Outgoing message to <c>mean</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="to_mean">Outgoing message to <c>mean</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(System.Int32)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageConditional(System.Double)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(System.Int32)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(System.Double)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlate">
            <summary>
            Power plate factor method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)">
            <summary>
            Copy a value from outside to the inside of a power plate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="exponent"></param>
            <returns>A copy of value.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlateOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="exponent">Constant value for <c>exponent</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(enter) p(enter) factor(enter,value,exponent)]/p(value)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageConditional``1(``0,``0,System.Double,``0)">
            <summary>EP message to <c>enter</c>.</summary><param name="enter">Incoming message from <c>enter</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="exponent">Constant value for <c>exponent</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enter</c> as the random arguments are varied. The formula is <c>proj[p(enter) sum_(value) p(value) factor(enter,value,exponent)]/p(enter)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageConditionalInit``1(``0)">
            <summary/><param name="value">Incoming message from <c>value</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.LogEvidenceRatio``1(``0,``0,System.Double,``0)">
            <summary>Evidence message for EP.</summary><param name="enter">Incoming message from <c>enter</c>.</param><param name="value">Incoming message from <c>value</c>.</param><param name="exponent">Constant value for <c>exponent</c>.</param><param name="to_enter">Outgoing message to <c>enter</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(enter,value) p(enter,value) factor(enter,value,exponent) / sum_enter p(enter) messageTo(enter))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(enter,value,exponent))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageLogarithm``1(``0,System.Double,``0)">
            <summary>VMP message to <c>value</c>.</summary><param name="enter">Incoming message from <c>enter</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="exponent">Constant value for <c>exponent</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>value</c> with <c>enter</c> integrated out. The formula is <c>sum_enter p(enter) factor(enter,value,exponent)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="enter"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageLogarithm``1(``0)">
            <summary>VMP message to <c>enter</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>The outgoing VMP message to the <c>enter</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>enter</c> as the random arguments are varied. The formula is <c>proj[sum_(value) p(value) factor(enter,value,exponent)]</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the variable entering the power plate.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Damp">
            <summary>
            Damp factor methods
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the backward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the forward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampBackwardOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(backward,value,stepsize))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <typeparam name="Distribution">The type of the distribution over the damped variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.BackwardAverageConditional``1(``0)">
            <summary>EP message to <c>backward</c>.</summary><param name="value">Incoming message from <c>value</c>.</param><returns>The outgoing EP message to the <c>backward</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>backward</c> as the random arguments are varied. The formula is <c>proj[p(backward) sum_(value) p(value) factor(backward,value,stepsize)]/p(backward)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over the damped variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampForwardOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(forward,value,stepsize))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ForwardAverageConditional``1(``0,System.Double,``0)">
            <typeparam name="Distribution">The type of the distribution over the damped variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ValueAverageConditional``1(``0,``0)">
            <summary>EP message to <c>value</c>.</summary><param name="forward">Incoming message from <c>forward</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>value</c> as the random arguments are varied. The formula is <c>proj[p(value) sum_(forward) p(forward) factor(forward,value,stepsize)]/p(value)</c>.</para>
      </remarks>
            <typeparam name="Distribution">The type of the distribution over the damped variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            Must be an odd number.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditionalInit(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary/><param name="A">Incoming message from <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(ratio,b) p(ratio,b) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a,b) p(a,b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(b) p(b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a,ratio) p(a,ratio) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(ratio) p(ratio) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="A">Constant value for <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(ratio) p(ratio) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="a">Constant value for <c>ratio</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a) p(a) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>ratio</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>ratio</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="A">Constant value for <c>ratio</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(ratio,b) p(ratio,b) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a,b) p(a,b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(b) p(b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a,ratio) p(a,ratio) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Slow.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(ratio) p(ratio) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product_SHG09(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor as if running VMP, as required by Stern's algorithm.
            The algorithm comes from "Matchbox: Large Scale Online Bayesian Recommendations" by David Stern, Ralf Herbrich, and Thore Graepel, WWW 2009.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor using Laplace's method.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor using Laplace's method.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp6">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor using modified Laplace's method.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp6.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp6.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp6.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp6.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp3">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor as a linear factor.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.Weights(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Update the buffer <c>weights</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>New value of buffer <c>weights</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.Weights(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Update the buffer <c>weights</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>New value of buffer <c>weights</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.Weights(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Update the buffer <c>weights</c>.</summary><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_A">Previous outgoing message to <c>A</c>.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>New value of buffer <c>weights</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="weights">Buffer <c>weights</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp3.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp4">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor using an approximation to the integral Z.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp4.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp5">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            This class allows EP to process the product factor using a log-normal approximation to the input distributions
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>product</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>product</c>.</summary><param name="Product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp5.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><param name="to_product">Outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="to_product">Outgoing message to <c>product</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><param name="to_ratio">Outgoing message to <c>ratio</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><param name="to_ratio">Outgoing message to <c>ratio</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio) p(ratio) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for VMP.</summary><param name="product">Incoming message from <c>product</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(ratio,a,b)]</c>.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(ratio,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(ratio,a,b)))</c>.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>ratio</c> integrated out. The formula is <c>sum_ratio p(ratio) factor(ratio,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.BAverageLogarithm">
            <summary>VMP message to <c>b</c>.</summary><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a) p(a) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>ratio</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.AAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>EP message to <c>ratio</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>ratio</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>Evidence message for VMP.</summary><param name="product">Incoming message from <c>a</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="A">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>ratio</c> integrated out. The formula is <c>sum_ratio p(ratio) factor(ratio,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="A">Constant value for <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(ratio,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(ratio,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>ratio</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(ratio,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp.AAverageLogarithm(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="Product">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>ratio</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductExpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ProductExp(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.ProductExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>productExp</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>productExp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>productExp</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(productExp,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.ProductExpAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>productExp</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>productExp</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>productExp</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(productExp,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="ProductExp">Incoming message from <c>productExp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>productExp</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ProductExp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>a</c>.</summary><param name="ProductExp">Constant value for <c>productExp</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(productExp,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="ProductExp">Incoming message from <c>productExp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>productExp</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ProductExp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="ProductExp">Incoming message from <c>productExp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>productExp</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ProductExp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="ProductExp">Constant value for <c>productExp</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(productExp,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="ProductExp">Incoming message from <c>productExp</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>productExp</c> integrated out. The formula is <c>sum_productExp p(productExp) factor(productExp,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ProductExp"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="ProductExp">Constant value for <c>productExp</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>product</c>.</summary><param name="a">Constant value for <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>product</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>a</c>.</summary><param name="product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>b</c>.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.RatioAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>ratio</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a) p(a) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.AAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>a</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(ratio) p(ratio) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>a</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(b) p(b) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.RatioAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>ratio</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(b) p(b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(ratio) p(ratio) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.BAverageConditional(System.Double,System.Double)">
            <summary>EP message to <c>b</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>b</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(a) p(a) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Incoming message from <c>a</c>.</param><param name="b">Constant value for <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="a">Constant value for <c>a</c>.</param><param name="b">Incoming message from <c>b</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.QInit">
            <summary>Initialize the buffer <c>Q</c>.</summary><returns>Initial value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.Q(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Update the buffer <c>Q</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>New value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a,b) p(ratio,a,b) factor(ratio,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_ratio">Previous outgoing message to <c>ratio</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(ratio,a,b) p(ratio,a,b) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(ratio,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>b</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(ratio,a) p(ratio,a) factor(ratio,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.RatioAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>ratio</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing EP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[p(ratio) sum_(a,b) p(a,b) factor(ratio,a,b)]/p(ratio)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioOp_Laplace.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>a</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(ratio,b) p(ratio,b) factor(ratio,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.QInit">
            <summary>Initialize the buffer <c>Q</c>.</summary><returns>Initial value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.Q(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Update the buffer <c>Q</c>.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>New value of buffer <c>Q</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="to_product">Previous outgoing message to <c>product</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(product,a,b) p(product,a,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for EP.</summary><param name="product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>.</param><param name="q">Buffer <c>q</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(a,b) p(a,b) factor(product,a,b))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>b</c>.</summary><param name="product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>b</c> as the random arguments are varied. The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>product</c>.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp_Laplace.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>EP message to <c>a</c>.</summary><param name="product">Incoming message from <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="q">Buffer <c>q</c>.</param><returns>The outgoing EP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>a</c> as the random arguments are varied. The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>Evidence message for VMP.</summary><param name="product">Incoming message from <c>product</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(ratio,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>ratio</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>ratio</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>ratio</c> as the random arguments are varied. The formula is <c>proj[sum_(a) p(a) factor(ratio,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>ratio</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_ratio p(ratio) factor(ratio,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> with <c>ratio</c> integrated out. The formula is <c>sum_ratio p(ratio) factor(ratio,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><param name="B">Constant value for <c>b</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>b</c>.</summary><param name="ratio">Incoming message from <c>ratio</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>ratio</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_ratio p(ratio) factor(ratio,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="ratio"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(System.Double)">
            <summary>VMP message to <c>a</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>a</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.BAverageLogarithm(System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="ratio">Constant value for <c>ratio</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
            <remarks><para>
            Variational Message Passing does not support a Ratio factor with fixed output
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
            <remarks>
            Implements nonconjugate VMP messages for multiplying a Gaussian variable (a) with a Beta variable (b).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.damping">
            <summary>
            How much damping to use to prevent improper messages. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp.ProposalDistribution(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Find a proposal distribution - we will use this to set the limits of
            integration
            </summary>
            <param name="y">Gaussian distribution for y</param>
            <param name="a">Gaussian distribution for a</param>
            <param name="b">Beta distribution for b</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp.LogisticProposalDistribution(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Find the Laplace approximation for Beta(Logistic(x)) * Gaussian(x))
            </summary>
            <param name="beta">Beta distribution</param>
            <param name="gauss">Gaussian distribution</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>product</c>.</summary><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>product</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>product</c> as the random arguments are varied. The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>a</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>a</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>a</c>. The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Incoming message from <c>a</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. Because the factor is deterministic, <c>product</c> is integrated out before taking the logarithm. The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="A"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Incoming message from <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>b</c>. The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Incoming message from <c>product</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="A">Constant value for <c>a</c>.</param><param name="B">Incoming message from <c>b</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_B">Previous outgoing message to <c>B</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> with <c>product</c> integrated out. The formula is <c>sum_product p(product) factor(product,a,b)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Product"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="B"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>VMP message to <c>b</c>.</summary><param name="Product">Constant value for <c>product</c>.</param><param name="A">Constant value for <c>a</c>.</param><returns>The outgoing VMP message to the <c>b</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>b</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.DefAverageConditional``1(``0,``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="toDef">Buffer <c>toDef</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.UsesAverageConditional``1(``0,``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Uses</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.MarginalInit``1(``0)">
            <summary>Initialize the buffer <c>marginal</c>.</summary><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Initial value of buffer <c>marginal</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.Marginal``1(``0,``0,``0)">
            <summary>Update the buffer <c>marginal</c>.</summary><param name="toDef">Buffer <c>toDef</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.MarginalIncrement``1(``0,``0,``0)">
            <summary/><param name="result">Modified to contain the outgoing message.</param><param name="def">Incoming message from <c>Def</c>.</param><param name="use"/><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.ToDefInit``1(``0)">
            <summary>Initialize the buffer <c>toDef</c>.</summary><param name="Def">Incoming message from <c>Def</c>.</param><returns>Initial value of buffer <c>toDef</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.ToDef``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Update the buffer <c>toDef</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Replicate2BufferOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Count)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.UsesAverageConditional``1(``0[],``0,``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="marginal">Buffer <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Count)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.UsesAverageConditionalInit``2(``0,System.Int32,MicrosoftResearch.Infer.Collections.IArrayFactory{``0,``1})">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="count">Constant value for <c>Count</c>.</param><param name="factory"/><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
            <typeparam name="ArrayType">The type of arrays produced by <paramref name="factory"/>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.MarginalInit``1(``0)">
            <summary>Initialize the buffer <c>marginal</c>.</summary><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>Initial value of buffer <c>marginal</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.Marginal``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>Update the buffer <c>marginal</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.MarginalIncrement``1(``0,``0,``0)">
            <summary/><param name="result">Modified to contain the outgoing message.</param><param name="use"/><param name="def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Def</c> as the random arguments are varied. The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Count)]/p(Def)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.DefAverageConditional``1(``0[],``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Def</c> as the random arguments are varied. The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Count)]/p(Def)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateBufferOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateBufferOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_marginal">Outgoing message to <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,count,Marginal)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateBufferOp.UsesAverageConditional``1(``0[],``0,``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_marginal">Outgoing message to <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,count,Marginal)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)"/></description></item></list>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable being replicated.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},`0)">
            <summary>Evidence message for EP.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="Def">Incoming message from <c>Def</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Count) / sum_Uses p(Uses) messageTo(Uses))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},`0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},``0,System.Int32,`0)">
            <summary/><param name="to_marginal"/><param name="def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs(`0,System.Int32,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs``1(``0,System.Int32,``0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(``0[],``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},`0)">
            <summary/><param name="to_marginal"/><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_marginal"/><returns/><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(`0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_marginal"/><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(`0[],MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="to_marginal"/><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbsInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginalGibbs``1(``0,System.Int32,System.Int32,System.Int32,``0@,``0@,``0@)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.ConditionalInit``1(``0)">
            <summary>Initialize the buffer <c>conditional</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>Initial value of buffer <c>conditional</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.Conditional``1(`0,``0)">
            <summary>Update the buffer <c>conditional</c>.</summary><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.Conditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>Update the buffer <c>conditional</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.Sample``1(``0,``0)">
            <summary>Update the buffer <c>sample</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="conditional">Buffer <c>conditional</c>.</param><returns>New value of buffer <c>sample</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.MarginalEstimatorInit``1(``0,System.Int32)">
            <summary>Initialize the buffer <c>marginalEstimator</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><returns>Initial value of buffer <c>marginalEstimator</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.MarginalEstimator``2(``0,``1)">
            <summary>Update the buffer <c>marginalEstimator</c>.</summary><param name="conditional">Buffer <c>conditional</c>.</param><param name="marginalEstimator">Buffer <c>marginalEstimator</c>.</param><returns>New value of buffer <c>marginalEstimator</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
            <typeparam name="TAcc">The type of the marginal estimator.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.MarginalGibbs``1(MicrosoftResearch.Infer.Distributions.BurnInAccumulator{``0},``0)">
            <summary/><param name="marginalEstimator">Buffer <c>marginalEstimator</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.SampleAccInit(System.Collections.Generic.ICollection{`0},System.Int32,System.Int32)">
            <summary>Initialize the buffer <c>sampleAcc</c>.</summary><param name="to_samples">Previous outgoing message to <c>samples</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><param name="thin">Constant value for <c>thin</c>.</param><returns>Initial value of buffer <c>sampleAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.SampleAcc(`0,MicrosoftResearch.Infer.Distributions.Accumulator{`0})">
            <summary>Update the buffer <c>sampleAcc</c>.</summary><param name="sample">Buffer <c>sample</c>.</param><param name="sampleAcc">Buffer <c>sampleAcc</c>.</param><returns>New value of buffer <c>sampleAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.SamplesGibbs``1(MicrosoftResearch.Infer.Distributions.Accumulator{`0},``0)">
            <summary/><param name="sampleAcc">Buffer <c>sampleAcc</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.ConditionalAccInit``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Int32)">
            <summary>Initialize the buffer <c>conditionalAcc</c>.</summary><param name="to_conditionals">Previous outgoing message to <c>conditionals</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><param name="thin">Constant value for <c>thin</c>.</param><returns>Initial value of buffer <c>conditionalAcc</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.ConditionalAcc``1(``0,MicrosoftResearch.Infer.Distributions.Accumulator{``0})">
            <summary>Update the buffer <c>conditionalAcc</c>.</summary><param name="conditional">Buffer <c>conditional</c>.</param><param name="conditionalAcc">Buffer <c>conditionalAcc</c>.</param><returns>New value of buffer <c>conditionalAcc</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.ConditionalsGibbs``2(MicrosoftResearch.Infer.Distributions.Accumulator{``0},``1)">
            <summary/><param name="conditionalAcc">Buffer <c>conditionalAcc</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
            <typeparam name="TDistList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},`0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs(`0,System.Int32,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs``1(``0,`0,System.Int32,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="sample">Buffer <c>sample</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbsInit``1(``0,System.Int32)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.DefGibbs``1(``0,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="sample">Buffer <c>sample</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.MarginalAverageConditional``1(``0[],``0,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Count)]/p(Uses)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Count)]/p(Uses)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Def</c> as the random arguments are varied. The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Count)]/p(Def)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.DefAverageConditional``1(``0[],``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Def</c> as the random arguments are varied. The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Count)]/p(Def)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Uses,Def,Count))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IList{``0})">
            <summary>Evidence message for EP.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_Uses">Outgoing message to <c>Uses</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Count) / sum_Uses p(Uses) messageTo(Uses))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Uses,Def,Count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalAverageLogarithm``2(``1,``0)">
            <summary/><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the outgoing message.</typeparam>
            <typeparam name="TDef">The type of the incoming message from <c>Def</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageLogarithm``2(``1,System.Int32,``0)">
            <summary>VMP message to <c>Uses</c>.</summary><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[sum_(Def) p(Def) factor(Uses,Def,Count)]</c>.</para>
      </remarks>
            <typeparam name="T">The type of the outgoing message.</typeparam>
            <typeparam name="TDef">The type of the incoming message from <c>Def</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesInit``2(``0,System.Int32,MicrosoftResearch.Infer.Collections.IArrayFactory{``0,``1})">
            <summary>Initialize the buffer <c>Uses</c>.</summary><param name="Def">Incoming message from <c>Def</c>.</param><param name="count">Constant value for <c>Count</c>.</param><param name="factory"/><returns>Initial value of buffer <c>Uses</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the incoming message from <c>Def</c>.</typeparam>
            <typeparam name="ArrayType">The type of arrays produced by <paramref name="factory"/>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> with <c>Uses</c> integrated out. The formula is <c>sum_Uses p(Uses) factor(Uses,Def,Count)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(``0[],``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> with <c>Uses</c> integrated out. The formula is <c>sum_Uses p(Uses) factor(Uses,Def,Count)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateMaxOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.UsesMaxConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution o0ver the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.UsesMaxConditionalInit``1(``0,System.Int32)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the distribution o0ver the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.DefMaxConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution o0ver the replicated variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.MarginalMaxConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the distribution over the replicated variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlpha">
            <summary>
            Factors that change a message channel's alpha factor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, going to a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, coming from a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>EP message to <c>factor</c>.</summary><param name="factor">Incoming message from <c>factor</c>.</param><param name="variable">Incoming message from <c>variable</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="variableAlpha">Constant value for <c>variableAlpha</c>.</param><param name="factorAlpha">Constant value for <c>factorAlpha</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>factor</c> as the random arguments are varied. The formula is <c>proj[p(factor) sum_(variable) p(variable) factor(factor,variable,variableAlpha,factorAlpha)]/p(factor)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variable"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>EP message to <c>variable</c>.</summary><param name="factor">Incoming message from <c>factor</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>variable</c> as the random arguments are varied. The formula is <c>proj[p(variable) sum_(factor) p(factor) factor(factor,variable,variableAlpha,factorAlpha)]/p(variable)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="factor"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (factor,variable,variableAlpha,factorAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>EP message to <c>factor</c>.</summary><param name="factor">Incoming message from <c>factor</c>.</param><param name="variable">Incoming message from <c>variable</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="factorAlpha">Constant value for <c>factorAlpha</c>.</param><param name="variableAlpha">Constant value for <c>variableAlpha</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>factor</c> as the random arguments are varied. The formula is <c>proj[p(factor) sum_(variable) p(variable) factor(variable,factor,factorAlpha,variableAlpha)]/p(factor)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="variable"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>EP message to <c>variable</c>.</summary><param name="factor">Incoming message from <c>factor</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>variable</c> as the random arguments are varied. The formula is <c>proj[p(variable) sum_(factor) p(factor) factor(variable,factor,factorAlpha,variableAlpha)]/p(variable)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="factor"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (variable,factor,factorAlpha,variableAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the simple first order Taylor series expansion from Blei et al. 06, followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse.AInit">
            <summary>Initialize the buffer <c>A</c>.</summary><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse.A``1(``0,System.Double)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse.SoftmaxAverageLogarithm``1(``0,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,System.Double,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the simple first order Taylor series expansion from Blei et al. 06, followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard.AInit">
            <summary>Initialize the buffer <c>A</c>.</summary><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard.A``1(``0,System.Double)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard.SoftmaxAverageLogarithm``1(``0,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bouchard.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,System.Double,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the simple first order Taylor series expansion from Blei and Lafferty (2006), followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GetMeanAndVariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Double[]@,System.Double[]@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GetMeanAndVariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.LogSumExpMPlusHalfV(System.Double[],System.Double[])">
            <summary>
            Helper function to calculation log sum_k exp(m_k+v_k/2), which is an upper bound
            on E[log sum_k exp(x_k)] when x_k ~ N(m_k,v_k)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GradientAndValueAtPoint(System.Double[],System.Double[],MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="mu">Prior means</param>
            <param name="s2">Prior variances</param>
            <param name="x">x[1..K]: posterior mean, x[K+1..2K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bohning">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bohning.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bohning.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Bohning.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_Taylor">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Taylor.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Taylor.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_Taylor.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the bound from Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Initialize the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.HistoryInit">
            <summary>Initialize the buffer <c>history</c>.</summary><returns>Initial value of buffer <c>history</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.History(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.List{System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian}})">
            <summary>Update the buffer <c>history</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="history">Buffer <c>history</c>.</param><returns>New value of buffer <c>history</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.SoftmaxAverageLogarithmInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="x">Incoming message from <c>x</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses a generalization of the tilted bound used in Saul Jordan 1999, followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.AsjInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Initialize the buffer <c>Asj</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><returns>Initial value of buffer <c>Asj</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.Asj(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double})">
            <summary>Update the buffer <c>Asj</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="asj">Buffer <c>asj</c>.</param><returns>New value of buffer <c>Asj</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.AbouchardInit">
            <summary>Initialize the buffer <c>Abouchard</c>.</summary><returns>Initial value of buffer <c>Abouchard</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.Abouchard``1(``0,System.Double)">
            <summary>Update the buffer <c>Abouchard</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="abouchard">Buffer <c>abouchard</c>.</param><returns>New value of buffer <c>Abouchard</c>.</returns><remarks>
        <para/>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.SoftmaxAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="asj">Buffer <c>asj</c>.</param><param name="abouchard">Buffer <c>abouchard</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>The outgoing VMP message to the <c>softmax</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.XAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="asj">Buffer <c>asj</c>.</param><param name="abouchard">Buffer <c>abouchard</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse2.LogAverageFactor``1(``0,System.Collections.Generic.IList{System.Double},System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for EP.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="asj">Buffer <c>asj</c>.</param><param name="abouchard">Buffer <c>abouchard</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(x,softmax) p(x,softmax) factor(softmax,x))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            This will replace SaulJordanSoftmaxOp_NCVMP once the functionality is confirmed to be equivalent. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Initialize the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double})">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.SoftmaxAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.AverageLogFactor``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0,System.Collections.Generic.IList{System.Double})">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the simple first order Taylor series expansion from Blei and Lafferty (2006), followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(softmax,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.AInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.A(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.SoftmaxAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.SoftmaxAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="x">Incoming message from <c>x</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_x">Previous outgoing message to <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><returns>The outgoing VMP message to the <c>x</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>Evidence message for VMP.</summary><param name="x">Incoming message from <c>x</c>.</param><param name="a">Buffer <c>a</c>.</param><param name="softmax">Incoming message from <c>softmax</c>.</param><param name="to_softmax">Previous outgoing message to <c>softmax</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.GradientAndValueAtPoint(System.Double[],System.Double[],MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="mu">Prior means</param>
            <param name="s2">Prior variances</param>
            <param name="a">Variational parameter vector a</param>
            <param name="x">x[1..K]: posterior mean, x[K+1..2K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the incoming message from <c>x</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.SoftmaxAverageLogarithmInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="x">Incoming message from <c>x</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Initialize the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>.</param><returns>Initial value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>A</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><returns>New value of buffer <c>A</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="a">Buffer <c>a</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.AverageLogFactor``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.GradientAndValueAtPoint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector[])">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="prior"></param>
            <param name="a">Variational parameter vector a</param>
            <param name="xm">xm[1..K]: posterior mean</param>
            <param name="lxv">lxv[1..K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.SoftmaxAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double})">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double},``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
            <remarks>
            Here the marginal prototype for logOdds is Gamma, which allows for heavier tailed distributions. 
            This implementation uses the Taylor series bound from Blei 06, followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.GetShapeAndRate(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma},System.Double[]@,System.Double[]@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.GetMeanLog(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma})">
            <summary>
            
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.SoftmaxAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma})">
            <summary>VMP message to <c>softmax</c>.</summary><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><returns>The outgoing VMP message to the <c>softmax</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>softmax</c> as the random arguments are varied. The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0)">
            <summary>VMP message to <c>x</c>.</summary><param name="softmax">Incoming message from <c>softmax</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="x">Incoming message from <c>x</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>x</c> with <c>softmax</c> integrated out. The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="softmax"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="x"/> is not a proper distribution.</exception>
            <typeparam name="GammaList">The type of the incoming message from <c>x</c> and the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp">
            <summary>
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample(MicrosoftResearch.Infer.Collections.ISparseList{System.Double})"/>, given random arguments to the function.</summary>
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogAverageFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,probTrue) p(sample,probTrue) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbTrueConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Gibbs message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbTrueAverageConditional(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>EP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(probTrue) p(probTrue) factor(sample,probTrue)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbTrueAverageConditional(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>EP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="probTrue">Incoming message from <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>probTrue</c> as the random arguments are varied. The formula is <c>proj[p(probTrue) sum_(sample) p(sample) factor(sample,probTrue)]/p(probTrue)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,probTrue) p(sample,probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(probTrue) p(probTrue) log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Collections.ISparseList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="probTrue">Constant value for <c>probTrue</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,probTrue))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Double},MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Constant value for <c>probTrue</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>VMP message to <c>sample</c>.</summary><param name="probTrue">Incoming message from <c>probTrue</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(probTrue) p(probTrue) log(factor(sample,probTrue)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="probTrue"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Collections.ISparseList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>probTrue</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>VMP message to <c>probTrue</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>probTrue</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probTrue)))</c>.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseGPOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Constant value for <c>func</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(y,func,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Constant value for <c>func</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(y,func,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for VMP.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Constant value for <c>func</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(y,func,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Incoming message from <c>func</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(func) p(func) factor(y,func,x))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Evidence message for EP.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Incoming message from <c>func</c>.</param><param name="x">Constant value for <c>x</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(func) p(func) factor(y,func,x))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="y">Incoming message from <c>y</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(y) p(y) factor(y,func,x) / sum_y p(y) messageTo(y))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.YAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>EP message to <c>y</c>.</summary><param name="func">Incoming message from <c>func</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Constant value for <c>x</c>.</param><returns>The outgoing EP message to the <c>y</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>y</c> as the random arguments are varied. The formula is <c>proj[p(y) sum_(func) p(func) factor(y,func,x)]/p(y)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="func"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.FuncAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>EP message to <c>func</c>.</summary><param name="y">Incoming message from <c>y</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="func">Incoming message from <c>func</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Constant value for <c>x</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>func</c> as the random arguments are varied. The formula is <c>proj[p(func) sum_(y) p(y) factor(y,func,x)]/p(func)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="y"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="func"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.FuncAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>EP message to <c>func</c>.</summary><param name="y">Constant value for <c>y</c>.</param><param name="func">Incoming message from <c>func</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="x">Constant value for <c>x</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>func</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="func"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubarrayOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>Evidence message for EP.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>EP message to <c>items</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ResultType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageConditionalInit``1(MicrosoftResearch.Infer.Distributions.DistributionStructArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageConditionalInit``1(MicrosoftResearch.Infer.Distributions.DistributionRefArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>EP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(items,array,indices))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageLogarithmInit``1(MicrosoftResearch.Infer.Distributions.DistributionStructArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageLogarithmInit``1(MicrosoftResearch.Infer.Distributions.DistributionRefArray{``0,`0},System.Collections.Generic.IList{System.Int32})">
            <summary/><param name="array">Incoming message from <c>array</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of a distribution over an array item.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>VMP message to <c>items</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>items</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(items,array,indices)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ResultType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>items</c> integrated out. The formula is <c>sum_items p(items) factor(items,array,indices)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="items"/> is not a proper distribution.</exception>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>VMP message to <c>array</c>.</summary><param name="items">Incoming message from <c>items</c>.</param><param name="indices">Constant value for <c>indices</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>items</c> integrated out. The formula is <c>sum_items p(items) factor(items,array,indices)</c>.</para>
      </remarks>
            <typeparam name="DistributionType">The type of a distribution over an array item.</typeparam>
            <typeparam name="ArrayType">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubvectorOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32,System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="source">Constant value for <c>source</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="source">Constant value for <c>source</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="source">Constant value for <c>source</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>SourceVariance</c>.</summary><param name="Source">Incoming message from <c>source</c>.</param><returns>Initial value of buffer <c>SourceVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>SourceVariance</c>.</summary><param name="Source">Incoming message from <c>source</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Source"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>SourceMean</c>.</summary><param name="Source">Incoming message from <c>source</c>.</param><returns>Initial value of buffer <c>SourceMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>SourceMean</c>.</summary><param name="Source">Incoming message from <c>source</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SourceVariance">Buffer <c>SourceVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Source"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="SourceMean">Buffer <c>SourceMean</c>.</param><param name="SourceVariance">Buffer <c>SourceVariance</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="SourceMean">Buffer <c>SourceMean</c>.</param><param name="SourceVariance">Buffer <c>SourceVariance</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="subvector">Incoming message from <c>subvector</c>.</param><param name="to_subvector">Outgoing message to <c>subvector</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(subvector) p(subvector) factor(subvector,source,startIndex,count))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="subvector">Incoming message from <c>subvector</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(subvector) p(subvector) factor(subvector,source,startIndex,count) / sum_subvector p(subvector) messageTo(subvector))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageConditionalInit(System.Int32)">
            <summary/><param name="count">Constant value for <c>count</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageLogarithmInit(System.Int32)">
            <summary/><param name="count">Constant value for <c>count</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>subvector</c>.</summary><param name="SourceMean">Buffer <c>SourceMean</c>.</param><param name="SourceVariance">Buffer <c>SourceVariance</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>subvector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>source</c>.</summary><param name="subvector">Incoming message from <c>subvector</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>source</c> as the random arguments are varied. The formula is <c>proj[p(source) sum_(subvector) p(subvector) factor(subvector,source,startIndex,count)]/p(source)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="subvector"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageConditional(MicrosoftResearch.Infer.Maths.Vector,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>source</c>.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>source</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>subvector</c>.</summary><param name="SourceMean">Buffer <c>SourceMean</c>.</param><param name="SourceVariance">Buffer <c>SourceVariance</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>subvector</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>source</c>.</summary><param name="subvector">Incoming message from <c>subvector</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>source</c> with <c>subvector</c> integrated out. The formula is <c>sum_subvector p(subvector) factor(subvector,source,startIndex,count)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="subvector"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>source</c>.</summary><param name="subvector">Constant value for <c>subvector</c>.</param><param name="startIndex">Constant value for <c>startIndex</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>source</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorElementOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>ArrayVariance</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>Initial value of buffer <c>ArrayVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>ArrayVariance</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>ArrayMean</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>Initial value of buffer <c>ArrayMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>ArrayMean</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Constant value for <c>item</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayMean">Buffer <c>ArrayMean</c>.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>Evidence message for EP.</summary><param name="item">Constant value for <c>item</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayMean">Buffer <c>ArrayMean</c>.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>EP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayMean">Buffer <c>ArrayMean</c>.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>The outgoing EP message to the <c>item</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index)]/p(item)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageConditionalInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageLogarithmInit">
            <summary/><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageConditional(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>array</c>.</summary><param name="item">Constant value for <c>item</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>Evidence message for VMP.</summary><param name="item">Constant value for <c>item</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayMean">Buffer <c>ArrayMean</c>.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="item">Incoming message from <c>item</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Zero.</returns><remarks>
        <para>In Variational Message Passing, the evidence contribution of a deterministic factor is zero. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>VMP message to <c>item</c>.</summary><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="ArrayMean">Buffer <c>ArrayMean</c>.</param><param name="ArrayVariance">Buffer <c>ArrayVariance</c>.</param><param name="index">Constant value for <c>index</c>.</param><returns>The outgoing VMP message to the <c>item</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>item</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(item,array,index)]</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Incoming message from <c>item</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>item</c> integrated out. The formula is <c>sum_item p(item) factor(item,array,index)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="item"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageLogarithm(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>array</c>.</summary><param name="item">Constant value for <c>item</c>.</param><param name="index">Constant value for <c>index</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FastSumOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.AverageLogFactor(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>Evidence message for VMP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Constant value for <c>array</c>.</param><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>Evidence message for EP.</summary><param name="sum">Incoming message from <c>sum</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array) / sum_sum p(sum) messageTo(sum))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Evidence message for EP.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>EP message to <c>sum</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>The outgoing EP message to the <c>sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sum</c> as the random arguments are varied. The formula is <c>proj[p(sum) sum_(array) p(array) factor(sum,array)]/p(sum)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian[],MicrosoftResearch.Infer.Distributions.Gaussian[])">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>VMP message to <c>sum</c>.</summary><param name="array">Incoming message from <c>array</c>.</param><returns>The outgoing VMP message to the <c>sum</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sum</c> as the random arguments are varied. The formula is <c>proj[sum_(array) p(array) factor(sum,array)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm2``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="to_array">Previous outgoing message to 'array'.</param>
            <returns>The outgoing VMP message to the 'array' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'sum' integrated out.
            The formula is <c>sum_sum p(sum) factor(sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm1``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="to_array">Previous outgoing message to 'array'.</param>
            <returns>The outgoing VMP message to the 'array' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'sum' integrated out.
            The formula is <c>sum_sum p(sum) factor(sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_array">Previous outgoing message to <c>array</c>.</param><returns>The outgoing VMP message to the <c>array</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>sum</c> integrated out. The formula is <c>sum_sum p(sum) factor(sum,array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sum,array))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumOp3">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumOp3.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>sum</c> integrated out. The formula is <c>sum_sum p(sum) factor(sum,array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the message to <c>array</c>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumOp2">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumOp2.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Int32)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If the element at resultIndex is uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>array</c> for which a message is desired.</param><returns>The outgoing EP message to the <c>array</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>array</c> as the random arguments are varied. The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumOp2.ArrayAverageConditional(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Int32)">
            <summary>EP message to <c>array</c>.</summary><param name="sum">Constant value for <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If the element at resultIndex is uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>array</c> for which a message is desired.</param><returns>The outgoing EP message to the <c>array</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> conditioned on the given values.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumOp2.ArrayAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Int32)">
            <summary>VMP message to <c>array</c>.</summary><param name="sum">Incoming message from <c>sum</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_sum">Outgoing message to <c>sum</c>.</param><param name="array">Incoming message from <c>array</c>. Must be a proper distribution. If the element at resultIndex is uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>array</c> for which a message is desired.</param><returns>The outgoing VMP message to the <c>array</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>array</c> with <c>sum</c> integrated out. The formula is <c>sum_sum p(sum) factor(sum,array)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sum"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumOp_SHG09">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UnaryOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})"/>, given random arguments to the function.</summary>
            <typeparam name="DomainType">The type of the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(random,dist) p(random,dist) factor(random,dist))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(random,dist) p(random,dist) factor(random,dist))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>Evidence message for EP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(random,dist) p(random,dist) factor(random,dist) / sum_random p(random) messageTo(random))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>Evidence message for EP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(random,dist) p(random,dist) factor(random,dist) / sum_random p(random) messageTo(random))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageConditional``1(``0)">
            <summary>EP message to <c>random</c>.</summary><param name="dist">Incoming message from <c>dist</c>.</param><returns>The outgoing EP message to the <c>random</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>random</c> as the random arguments are varied. The formula is <c>proj[p(random) sum_(dist) p(dist) factor(random,dist)]/p(random)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(``0,``0)">
            <summary>Evidence message for VMP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(random,dist) p(random,dist) log(factor(random,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(`0,``0)">
            <summary>Evidence message for VMP.</summary><param name="random">Incoming message from <c>random</c>.</param><param name="dist">Incoming message from <c>dist</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(random,dist) p(random,dist) log(factor(random,dist))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageLogarithm``1(``0)">
            <summary>VMP message to <c>random</c>.</summary><param name="dist">Incoming message from <c>dist</c>.</param><returns>The outgoing VMP message to the <c>random</c> argument.</returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>random</c>. The formula is <c>exp(sum_(dist) p(dist) log(factor(random,dist)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the distribution over the sampled variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomMaxConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary/><param name="dist">Incoming message from <c>dist</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomMaxConditional(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary/><param name="dist">Incoming message from <c>dist</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><returns/><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="dist"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UniformPlusMinusOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UniformPlusMinus(System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UniformPlusMinusOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Pareto)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="upperBound">Incoming message from <c>upperBound</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(upperBound) p(upperBound) factor(sample,upperBound))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UniformPlusMinusOp.UpperBoundAverageConditional(System.Double)">
            <summary>EP message to <c>upperBound</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing EP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>upperBound</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UniformPlusMinusOp.UpperBoundAverageLogarithm(System.Double)">
            <summary>VMP message to <c>upperBound</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><returns>The outgoing VMP message to the <c>upperBound</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>upperBound</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.LogEvidenceRatio1``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal) / sum_Uses p(Uses) messageTo(Uses))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IList{``0})">
            <summary>Evidence message for EP.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_Uses">Outgoing message to <c>Uses</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,count,Marginal) / sum_Uses p(Uses) messageTo(Uses))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>EP message to <c>Marginal</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Marginal</c> as the random arguments are varied. The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,count,Marginal)]/p(Marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(``0[],``0,``0)">
            <summary>EP message to <c>Marginal</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Marginal</c> as the random arguments are varied. The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,count,Marginal)]/p(Marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,count,Marginal)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>EP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Uses</c> as the random arguments are varied. The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,count,Marginal)]/p(Uses)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>EP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>Def</c> as the random arguments are varied. The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,count,Marginal)]/p(Def)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns/><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{``0},`0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{`0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.MarginalGibbsInit``1(``0)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.UsesGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},System.Int32,`0)">
            <summary/><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.UsesGibbsInit``2(``1,System.Int32,MicrosoftResearch.Infer.Collections.IArrayFactory{``1,``0})">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="count">Constant value for <c>count</c>.</param><param name="factory"/><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TArrayType">The type of arrays produced by <paramref name="factory"/>.</typeparam>
            <typeparam name="TDef">The type of the incoming message from <c>Def</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.DefGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},`0)">
            <summary/><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDefGibbs``1(``0,System.Int32,System.Int32,System.Int32,``0@,``0@,``0@)"/>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.ConditionalInit``1(``0)">
            <summary>Initialize the buffer <c>conditional</c>.</summary><param name="def">Incoming message from <c>Def</c>.</param><returns>Initial value of buffer <c>conditional</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.Conditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>Update the buffer <c>conditional</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.Sample``1(``0,``0)">
            <summary>Update the buffer <c>sample</c>.</summary><param name="def">Incoming message from <c>Def</c>.</param><param name="conditional">Buffer <c>conditional</c>.</param><returns>New value of buffer <c>sample</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.MarginalEstimatorInit``1(``0,System.Int32)">
            <summary>Initialize the buffer <c>marginalEstimator</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><returns>Initial value of buffer <c>marginalEstimator</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.MarginalEstimator``2(``0,``1)">
            <summary>Update the buffer <c>marginalEstimator</c>.</summary><param name="conditional">Buffer <c>conditional</c>.</param><param name="marginalEstimator">Buffer <c>marginalEstimator</c>.</param><returns>New value of buffer <c>marginalEstimator</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.MarginalGibbs``1(MicrosoftResearch.Infer.Distributions.BurnInAccumulator{``0},``0)">
            <summary/><param name="marginalEstimator">Buffer <c>marginalEstimator</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.SampleAccInit(System.Collections.Generic.ICollection{`0},System.Int32,System.Int32)">
            <summary>Initialize the buffer <c>sampleAcc</c>.</summary><param name="to_samples">Previous outgoing message to <c>samples</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><param name="thin">Constant value for <c>thin</c>.</param><returns>Initial value of buffer <c>sampleAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.SampleAcc(`0,MicrosoftResearch.Infer.Distributions.Accumulator{`0})">
            <summary>Update the buffer <c>sampleAcc</c>.</summary><param name="sample">Buffer <c>sample</c>.</param><param name="sampleAcc">Buffer <c>sampleAcc</c>.</param><returns>New value of buffer <c>sampleAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.SamplesGibbs``1(MicrosoftResearch.Infer.Distributions.Accumulator{`0},``0)">
            <summary/><param name="sampleAcc">Buffer <c>sampleAcc</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.ConditionalAccInit``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Int32)">
            <summary>Initialize the buffer <c>conditionalAcc</c>.</summary><param name="to_conditionals">Previous outgoing message to <c>conditionals</c>.</param><param name="burnIn">Constant value for <c>burnIn</c>.</param><param name="thin">Constant value for <c>thin</c>.</param><returns>Initial value of buffer <c>conditionalAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.ConditionalAcc``1(``0,MicrosoftResearch.Infer.Distributions.Accumulator{``0})">
            <summary>Update the buffer <c>conditionalAcc</c>.</summary><param name="conditional">Buffer <c>conditional</c>.</param><param name="conditionalAcc">Buffer <c>conditionalAcc</c>.</param><returns>New value of buffer <c>conditionalAcc</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.ConditionalsGibbs``2(MicrosoftResearch.Infer.Distributions.Accumulator{``0},``1)">
            <summary/><param name="conditionalAcc">Buffer <c>conditionalAcc</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0,`0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="sample">Buffer <c>sample</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.UsesGibbs``1(``0,`0,System.Int32,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="sample">Buffer <c>sample</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.UsesGibbsInit``1(``0,System.Int32)">
            <summary/><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.DefGibbs``1(``0,`0)">
            <summary/><param name="def">Incoming message from <c>Def</c>.</param><param name="sample">Buffer <c>sample</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="TDist">The type of the distribution over the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.UsesMaxConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.DefMaxConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>. Must be a proper distribution. If all elements are uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Uses"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.MarginalMaxConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary/><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>. Must be a proper distribution. If uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Def"/> is not a proper distribution.</exception>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>VMP message to <c>Marginal</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Marginal</c>. The formula is <c>exp(sum_(Uses,Def) p(Uses,Def) log(factor(Uses,Def,count,Marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.UsesAverageLogarithm``1(``0,System.Int32,``0)">
            <summary>VMP message to <c>Uses</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Uses</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.DefAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>Def</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.AverageLogFactor``1(``0)">
            <summary>Evidence message for VMP.</summary><param name="to_marginal">Outgoing message to <c>marginal</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(Uses,Def,count,Marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>VMP message to <c>Marginal</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Marginal</c>. The formula is <c>exp(sum_(Uses,Def) p(Uses,Def) log(factor(Uses,Def,count,Marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>VMP message to <c>Uses</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="resultIndex">Index of the <c>Uses</c> for which a message is desired.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Uses</c>. The formula is <c>exp(sum_(Def) p(Def) log(factor(Uses,Def,count,Marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>VMP message to <c>Def</c>.</summary><param name="Uses">Incoming message from <c>Uses</c>.</param><param name="Def">Incoming message from <c>Def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>Def</c>. The formula is <c>exp(sum_(Uses) p(Uses) log(factor(Uses,Def,count,Marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the messages.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariableInit``1(``0,``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.MarginalAverageConditional``1(``0,``0,``0)">
            <summary>EP message to <c>marginal</c>.</summary><param name="use">Incoming message from <c>use</c>.</param><param name="def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>marginal</c> as the random arguments are varied. The formula is <c>proj[p(marginal) sum_(use,def) p(use,def) factor(use,def,marginal)]/p(marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.MarginalAverageConditionalInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.UseAverageConditional``1(``0)">
            <summary>EP message to <c>use</c>.</summary><param name="Def">Incoming message from <c>def</c>.</param><returns>The outgoing EP message to the <c>use</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>use</c> as the random arguments are varied. The formula is <c>proj[p(use) sum_(def) p(def) factor(use,def,marginal)]/p(use)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.DefAverageConditional``1(``0)">
            <summary>EP message to <c>def</c>.</summary><param name="use">Incoming message from <c>use</c>.</param><returns>The outgoing EP message to the <c>def</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>def</c> as the random arguments are varied. The formula is <c>proj[p(def) sum_(use) p(use) factor(use,def,marginal)]/p(def)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableGibbsOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariableGibbs``1(``0,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.GibbsEvidence``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs evidence
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.MarginalGibbs``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal'.
            </summary>
            <param name="Use">Incoming message from 'use'.</param>
            <param name="Def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_marginal"></param>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.UseGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``1)">
            <summary>
            Gibbs sample message to 'Use'
            </summary>
            <param name="marginal">Incoming message from 'marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.UseGibbs``2(``0,``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <param name="Def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.DefGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``1)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <param name="marginal">Incoming message from 'marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableMaxOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariableMax``1(``0,``0@)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableMaxOp.UseMaxConditional``1(``0,``0)">
            <summary/><param name="Def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableMaxOp.UseMaxConditionalInit``1(``0)">
            <summary/><param name="Def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableMaxOp.DefMaxConditional``1(``0)">
            <summary/><param name="Use">Incoming message from <c>use</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableMaxOp.MarginalMaxConditional``1(``0,``0,``0)">
            <summary/><param name="Use">Incoming message from <c>use</c>.</param><param name="Def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableMaxOp.MarginalMaxConditionalInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableVmpOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariableInit``1(``0,``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.AverageLogFactor``1(``0)">
            <summary>Evidence message for VMP.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.MarginalAverageLogarithm``1(``0,``0,``0)">
            <summary>VMP message to <c>marginal</c>.</summary><param name="use">Incoming message from <c>use</c>.</param><param name="def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>marginal</c>. The formula is <c>exp(sum_(use,def) p(use,def) log(factor(use,def,marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.MarginalAverageLogarithmInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.UseAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>use</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>use</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.UseAverageLogarithmInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.DefAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>def</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>def</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DerivedVariableOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableInit``1(``0,``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.LogAverageFactor">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,marginal))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.LogEvidenceRatio">
            <summary>Evidence message for EP.</summary><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.MarginalAverageConditional``1(``0,``0,``0)">
            <summary>EP message to <c>marginal</c>.</summary><param name="Use">Incoming message from <c>use</c>.</param><param name="Def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>marginal</c> as the random arguments are varied. The formula is <c>proj[p(marginal) sum_(use,def) p(use,def) factor(use,def,marginal)]/p(marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.MarginalAverageConditionalInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.UseAverageConditional``1(``0)">
            <summary>EP message to <c>use</c>.</summary><param name="Def">Incoming message from <c>def</c>.</param><returns>The outgoing EP message to the <c>use</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>use</c> as the random arguments are varied. The formula is <c>proj[p(use) sum_(def) p(def) factor(use,def,marginal)]/p(use)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.DefAverageConditional``1(``0)">
            <summary>EP message to <c>def</c>.</summary><param name="Use">Incoming message from <c>use</c>.</param><returns>The outgoing EP message to the <c>def</c> argument.</returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>def</c> as the random arguments are varied. The formula is <c>proj[p(def) sum_(use) p(use) factor(use,def,marginal)]/p(def)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableInitGibbs``1(``0,``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableGibbs``1(``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.GibbsEvidence">
            <summary>
            Evidence message for Gibbs.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.UseGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``0,``1)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <typeparam name="TDist">Gibbs marginal type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="marginal">The Gibbs marginal</param>
            <param name="def"></param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.UseGibbs``1(``0,``0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <typeparam name="T">Domain type</typeparam>
            <param name="def"></param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.DefGibbs``2(``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Use">Incoming message from 'Use'.</param>
            <remarks><para>
            The outgoing message is the product of all the 'Use' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Use"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for distribution Def
            </summary>
            <param name="Use">Incoming message from 'Use'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Use' messages.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``1,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for sample Def
            </summary>
            <typeparam name="TDist"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``1,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for sample Use
            </summary>
            <typeparam name="TDist"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="Use"></param>
            <param name="Def"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableInitVmp``1(``0,``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableVmp``1(``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,init,marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.MarginalAverageLogarithm``2(``1,``0)">
            <summary>VMP message to <c>marginal</c>.</summary><param name="Def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>marginal</c>. The formula is <c>exp(sum_(def) p(def) log(factor(use,def,init,marginal)))</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
            <typeparam name="TDef">The type of the incoming message from <c>Def</c>.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.MarginalAverageLogarithmInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.UseAverageLogarithm``2(``1,``0)">
            <summary>VMP message to <c>use</c>.</summary><param name="Def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>use</c> as the random arguments are varied. The formula is <c>proj[sum_(def) p(def) factor(use,def,init,marginal)]</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
            <typeparam name="TDef"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.UseAverageLogarithmInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.DefAverageLogarithm``1(``0,``0)">
            <summary>VMP message to <c>def</c>.</summary><param name="Use">Incoming message from <c>use</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>def</c> with <c>use</c> integrated out. The formula is <c>sum_use p(use) factor(use,def,init,marginal)</c>.</para>
      </remarks>
            <typeparam name="T">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariablePointOp`1">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariableInit``1(``0,``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableInit``1(``0,``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableInitVmp``1(``0,``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariableVmp``1(``0,``0@)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VariablePoint``1(``0,``0@)"/></description></item></list>, given random arguments to the function.</summary>
            <typeparam name="T">The type of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.LogEvidenceRatio``1(``0,``0,``0)">
            <summary>Evidence message for EP.</summary><param name="use">Incoming message from <c>use</c>.</param><param name="def">Incoming message from <c>def</c>.</param><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(use,def) p(use,def) factor(use,def,marginal) / sum_use p(use) messageTo(use))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.MarginalAverageConditional``1(``0,``0,``0)">
            <summary>EP message to <c>marginal</c>.</summary><param name="use">Incoming message from <c>use</c>.</param><param name="def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>marginal</c> as the random arguments are varied. The formula is <c>proj[p(marginal) sum_(use,def) p(use,def) factor(use,def,marginal)]/p(marginal)</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.MarginalAverageConditionalInit``1(``0)">
            <summary/><param name="def">Incoming message from <c>def</c>.</param><returns/><remarks>
        <para/>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.UseAverageConditional``1(``0)">
            <summary>EP message to <c>use</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>The outgoing EP message to the <c>use</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>use</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.DefAverageConditional``1(``0)">
            <summary>EP message to <c>def</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>The outgoing EP message to the <c>def</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>def</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(use,def,marginal))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.MarginalAverageLogarithm``1(``0,``0,``0)">
            <summary>VMP message to <c>marginal</c>.</summary><param name="use">Incoming message from <c>use</c>.</param><param name="def">Incoming message from <c>def</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>marginal</c>. The formula is <c>exp(sum_(use,def) p(use,def) log(factor(use,def,marginal)))</c>.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.UseAverageLogarithm``1(``0)">
            <summary>VMP message to <c>use</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>The outgoing VMP message to the <c>use</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>use</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariablePointOp`1.DefAverageLogarithm``1(``0)">
            <summary>VMP message to <c>def</c>.</summary><param name="to_marginal">Previous outgoing message to <c>marginal</c>.</param><returns>The outgoing VMP message to the <c>def</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>def</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="TDist">The type of the marginal of the variable.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorFromArrayOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[])"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Double[])">
            <summary>Evidence message for EP.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="array">Constant value for <c>data</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(fromArray,data))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,System.Double[])">
            <summary>Evidence message for EP.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="array">Constant value for <c>data</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(fromArray,data))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Evidence message for EP.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="array">Incoming message from <c>data</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(data) p(data) factor(fromArray,data))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>Evidence message for EP.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="array">Incoming message from <c>data</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(data) p(data) factor(fromArray,data))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="vector">Incoming message from <c>fromArray</c>.</param><param name="to_vector">Outgoing message to <c>vector</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(fromArray) p(fromArray) factor(fromArray,data))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="vector">Incoming message from <c>fromArray</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(fromArray) p(fromArray) factor(fromArray,data) / sum_fromArray p(fromArray) messageTo(fromArray))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.AverageLogFactor">
            <summary>Evidence message for VMP.</summary><returns>Zero.</returns><remarks>
        <para>The formula for the result is <c>log(factor(fromArray,data))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>fromArray</c>.</summary><param name="array">Incoming message from <c>data</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>fromArray</c> as the random arguments are varied. The formula is <c>proj[p(fromArray) sum_(data) p(data) factor(fromArray,data)]/p(fromArray)</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageConditionalInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="array">Incoming message from <c>data</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageLogarithmInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary/><param name="array">Incoming message from <c>data</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>fromArray</c>.</summary><param name="array">Incoming message from <c>data</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>fromArray</c> as the random arguments are varied. The formula is <c>proj[sum_(data) p(data) factor(fromArray,data)]</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>EP message to <c>data</c>.</summary><param name="vector">Incoming message from <c>fromArray</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="array">Incoming message from <c>data</c>.</param><param name="to_vector">Outgoing message to <c>vector</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>data</c> as the random arguments are varied. The formula is <c>proj[p(data) sum_(fromArray) p(fromArray) factor(fromArray,data)]/p(data)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="vector"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>VMP message to <c>data</c>.</summary><param name="vector">Incoming message from <c>fromArray</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="array">Incoming message from <c>data</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>data</c> with <c>fromArray</c> integrated out. The formula is <c>sum_fromArray p(fromArray) factor(fromArray,data)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="vector"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="array"/> is not a proper distribution.</exception>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>EP message to <c>data</c>.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>data</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>VMP message to <c>data</c>.</summary><param name="vector">Constant value for <c>fromArray</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>data</c> conditioned on the given values.</para>
      </remarks>
            <typeparam name="GaussianList">The type of the outgoing message.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Undirected">
            <summary>
            Provides useful factors for undirected models.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements an integer Potts potential which has the value of 1 if a=b and exp(-logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Implements an boolean Potts potential which has the value of 1 if a=b and exp(-logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Linear(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements a linear difference potential which has the value of exp( -|a-b|* logUnitCost ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logUnitCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.LinearTrunc(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Implements a truncated linear difference potential which has the value of  exp( - min( |a-b|* logUnitCost, maxCost) ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logUnitCost"></param>
            <param name="maxCost"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsIntOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Int32,System.Int32,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsIntOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="B">Incoming message from <c>b</c>.</param><param name="logCost">Constant value for <c>logCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsIntOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="A">Incoming message from <c>a</c>.</param><param name="logCost">Constant value for <c>logCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsBoolOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Boolean,System.Boolean,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsBoolOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary/><param name="B">Incoming message from <c>b</c>.</param><param name="logCost">Constant value for <c>logCost</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsBoolOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary/><param name="A">Incoming message from <c>a</c>.</param><param name="logCost">Constant value for <c>logCost</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LinearOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Linear(System.Int32,System.Int32,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="B">Incoming message from <c>b</c>.</param><param name="logUnitCost">Constant value for <c>logUnitCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="A">Incoming message from <c>a</c>.</param><param name="logUnitCost">Constant value for <c>logUnitCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LinearTruncOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.LinearTrunc(System.Int32,System.Int32,System.Double,System.Double)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearTruncOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="B">Incoming message from <c>b</c>.</param><param name="logUnitCost">Constant value for <c>logUnitCost</c>.</param><param name="maxCost">Constant value for <c>maxCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearTruncOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary/><param name="A">Incoming message from <c>a</c>.</param><param name="logUnitCost">Constant value for <c>logUnitCost</c>.</param><param name="maxCost">Constant value for <c>maxCost</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianOp">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>SampleVariance</c>.</summary><param name="Sample">Incoming message from <c>sample</c>.</param><returns>Initial value of buffer <c>SampleVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>SampleVariance</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>SampleMean</c>.</summary><param name="Sample">Incoming message from <c>sample</c>.</param><returns>Initial value of buffer <c>SampleMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>SampleMean</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>MeanVariance</c>.</summary><param name="Mean">Incoming message from <c>mean</c>.</param><returns>Initial value of buffer <c>MeanVariance</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>MeanVariance</c>.</summary><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Initialize the buffer <c>MeanMean</c>.</summary><param name="Mean">Incoming message from <c>mean</c>.</param><returns>Initial value of buffer <c>MeanMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Update the buffer <c>MeanMean</c>.</summary><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMeanInit(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Initialize the buffer <c>PrecisionMean</c>.</summary><param name="Precision">Incoming message from <c>precision</c>.</param><returns>Initial value of buffer <c>PrecisionMean</c>.</returns><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMean(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Update the buffer <c>PrecisionMean</c>.</summary><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMeanLogDet(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Update the buffer <c>PrecisionMeanLogDet</c>.</summary><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>New value of buffer <c>PrecisionMeanLogDet</c>.</returns><remarks>
        <para/>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Gibbs message to <c>sample</c>.</summary><param name="Mean">Constant value for <c>mean</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Gibbs message to <c>mean</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>Gibbs message to <c>precision</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Mean">Constant value for <c>mean</c>.</param><param name="result">Modified to contain the outgoing message.</param><param name="diff"/><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Gibbs message to <c>precision</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Mean">Constant value for <c>mean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="Mean">Constant value for <c>mean</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="Mean">Constant value for <c>mean</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditionalInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="Mean">Incoming message from <c>mean</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>mean</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>mean</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>precision</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Mean">Constant value for <c>mean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precisionMean">Buffer <c>precisionMean</c>.</param><param name="precisionMeanLogDet">Buffer <c>precisionMeanLogDet</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean,precision) p(sample,mean,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precisionMean">Buffer <c>precisionMean</c>.</param><param name="precisionMeanLogDet">Buffer <c>precisionMeanLogDet</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(precision) p(precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precisionMean">Buffer <c>precisionMean</c>.</param><param name="precisionMeanLogDet">Buffer <c>precisionMeanLogDet</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precisionMean">Buffer <c>precisionMean</c>.</param><param name="precisionMeanLogDet">Buffer <c>precisionMeanLogDet</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="precision">Constant value for <c>precision</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="SampleMean">Mean of incoming message from 'sample'</param>
            <param name="SampleVariance">Variance of incoming message from 'sample'</param>
            <param name="MeanMean">Mean of incoming message from 'mean'</param>
            <param name="MeanVariance">Variance of incoming message from 'mean'</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="SampleMean">Mean of incoming sample message</param>
            <param name="SampleVariance">Variance of incoming sample message</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>sample</c>.</summary><param name="Mean">Constant value for <c>mean</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>sample</c>.</summary><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="PrecisionMean">Buffer <c>PrecisionMean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>sample</c>.</summary><param name="Mean">Constant value for <c>mean</c>.</param><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="PrecisionMean">Buffer <c>PrecisionMean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary/><param name="Mean">Constant value for <c>mean</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithmInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary/><param name="Mean">Incoming message from <c>mean</c>.</param><returns/><remarks>
        <para/>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>mean</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>mean</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="PrecisionMean">Buffer <c>PrecisionMean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>mean</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="Precision">Constant value for <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>VMP message to <c>mean</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="PrecisionMean">Buffer <c>PrecisionMean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>mean</c>. The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>precision</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Mean">Constant value for <c>mean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>precision</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>precision</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>precision</c>.</summary><param name="Sample">Constant value for <c>sample</c>.</param><param name="Mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="MeanMean">Buffer <c>MeanMean</c>.</param><param name="MeanVariance">Buffer <c>MeanVariance</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Mean"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>precision</c>.</summary><param name="Sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="SampleMean">Buffer <c>SampleMean</c>.</param><param name="SampleVariance">Buffer <c>SampleVariance</c>.</param><param name="Mean">Constant value for <c>mean</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>precision</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="Sample"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SampleFromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="to_mean">Outgoing message to <c>mean</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,variance))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing VMP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>sample</c>.</summary><param name="mean">Constant value for <c>mean</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.MeanAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="variance">Constant value for <c>variance</c>.</param><returns>The outgoing EP message to the <c>mean</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>mean</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2">
            <summary>Provides outgoing messages for the following factors:<list type="bullet"><item><description><see cref="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/></description></item><item><description><see cref="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/></description></item></list>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>EP message to <c>mean</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>mean</c> as the random arguments are varied. The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp_Laplace2.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>precision</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="mean">Incoming message from <c>mean</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="precision">Incoming message from <c>precision</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_precision">Previous outgoing message to <c>precision</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>precision</c> as the random arguments are varied. The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="mean"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="precision"/> is not a proper distribution.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp">
            <summary>
            UsesEqualDef operator to combine Gaussian and nonconjugate messages. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp.UsesAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double}[],MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP Messages to Uses
            </summary>
            <param name="Uses">Nonconjugate messages from uses</param>
            <param name="Def">Gaussian message from Defintion</param>
            <param name="result">Previous message</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp.MarginalAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double}[],MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            The marginal distribution is the same as the message to uses.  
            </summary>
            <param name="Uses"></param>
            <param name="Def"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,shape,scale))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>The outgoing VMP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="scale">Constant value for <c>scale</c>.</param><returns>The outgoing EP message to the <c>sample</c> argument.</returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(rate) p(rate) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(rate) p(rate) factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,rate) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.RateAverageConditional(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>rate</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>Evidence message for VMP.</summary><param name="sample">Constant value for <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for VMP.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><returns>Average of the factor's log-value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>sum_(sample,rate) p(sample,rate) log(factor(sample,shape,rate))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>sample</c>. The formula is <c>exp(sum_(rate) p(rate) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>VMP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except <c>rate</c>. The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,shape,rate)))</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>sample</c>.</summary><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Constant value for <c>rate</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is the factor viewed as a function of <c>sample</c> conditioned on the given values.</para>
      </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp_Laplace2">
            <summary>Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.</summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp_Laplace2.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's average value across the given argument distributions.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate))</c>.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp_Laplace2.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>Evidence message for EP.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><param name="to_sample">Outgoing message to <c>sample</c>.</param><returns>Logarithm of the factor's contribution the EP model evidence.</returns><remarks>
        <para>The formula for the result is <c>log(sum_(sample,rate) p(sample,rate) factor(sample,shape,rate) / sum_sample p(sample) messageTo(sample))</c>. Adding up these values across all factors and variables gives the log-evidence estimate for EP.</para>
      </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp_Laplace2.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>rate</c>.</summary><param name="sample">Incoming message from <c>sample</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>.</param><param name="to_rate">Previous outgoing message to <c>rate</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>rate</c> as the random arguments are varied. The formula is <c>proj[p(rate) sum_(sample) p(sample) factor(sample,shape,rate)]/p(rate)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="sample"/> is not a proper distribution.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp_Laplace2.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>EP message to <c>sample</c>.</summary><param name="sample">Incoming message from <c>sample</c>.</param><param name="shape">Constant value for <c>shape</c>.</param><param name="rate">Incoming message from <c>rate</c>. Must be a proper distribution. If any element is uniform, the result will be uniform.</param><param name="to_rate">Previous outgoing message to <c>rate</c>.</param><param name="to_sample">Previous outgoing message to <c>sample</c>.</param><param name="result">Modified to contain the outgoing message.</param><returns>
        <paramref name="result"/>
      </returns><remarks>
        <para>The outgoing message is a distribution matching the moments of <c>sample</c> as the random arguments are varied. The formula is <c>proj[p(sample) sum_(rate) p(rate) factor(sample,shape,rate)]/p(sample)</c>.</para>
      </remarks><exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
        <paramref name="rate"/> is not a proper distribution.</exception>
        </member>
    </members>
</doc>
